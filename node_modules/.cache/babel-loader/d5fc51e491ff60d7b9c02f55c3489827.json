{"ast":null,"code":"/**\n * @fileoverview 椭圆\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base'; // 根据椭圆公式计算 x*x/rx*rx + y*y/ry*ry;\n\nfunction ellipseDistance(squareX, squareY, rx, ry) {\n  return squareX / (rx * rx) + squareY / (ry * ry);\n}\n\nvar Ellipse =\n/** @class */\nfunction (_super) {\n  __extends(Ellipse, _super);\n\n  function Ellipse() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Ellipse.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n\n    return __assign(__assign({}, attrs), {\n      x: 0,\n      y: 0,\n      rx: 0,\n      ry: 0\n    });\n  };\n\n  Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n    var attrs = this.attr();\n    var halfLineWith = lineWidth / 2;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var rx = attrs.rx,\n        ry = attrs.ry;\n    var squareX = (x - cx) * (x - cx);\n    var squareY = (y - cy) * (y - cy); // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n\n    if (isFill && isStroke) {\n      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n    }\n\n    if (isFill) {\n      return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n    }\n\n    if (isStroke) {\n      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n    }\n\n    return false;\n  };\n\n  Ellipse.prototype.createPath = function (context) {\n    var attrs = this.attr();\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var rx = attrs.rx;\n    var ry = attrs.ry;\n    context.beginPath(); // 兼容逻辑\n\n    if (context.ellipse) {\n      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);\n    } else {\n      // 如果不支持，则使用圆来绘制，进行变形\n      var r = rx > ry ? rx : ry;\n      var scaleX = rx > ry ? 1 : rx / ry;\n      var scaleY = rx > ry ? ry / rx : 1;\n      context.save();\n      context.translate(cx, cy);\n      context.scale(scaleX, scaleY);\n      context.arc(0, 0, r, 0, Math.PI * 2);\n      context.restore();\n      context.closePath();\n    }\n  };\n\n  return Ellipse;\n}(ShapeBase);\n\nexport default Ellipse;","map":{"version":3,"sources":["../../src/shape/ellipse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileoverview 椭圆\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\n// 根据椭圆公式计算 x*x/rx*rx + y*y/ry*ry;\nfunction ellipseDistance(squareX, squareY, rx, ry) {\n    return squareX / (rx * rx) + squareY / (ry * ry);\n}\nvar Ellipse = /** @class */ (function (_super) {\n    __extends(Ellipse, _super);\n    function Ellipse() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Ellipse.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });\n    };\n    Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var attrs = this.attr();\n        var halfLineWith = lineWidth / 2;\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var rx = attrs.rx, ry = attrs.ry;\n        var squareX = (x - cx) * (x - cx);\n        var squareY = (y - cy) * (y - cy);\n        // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n        if (isFill && isStroke) {\n            return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n        }\n        if (isFill) {\n            return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n        }\n        if (isStroke) {\n            return (ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 &&\n                ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1);\n        }\n        return false;\n    };\n    Ellipse.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var rx = attrs.rx;\n        var ry = attrs.ry;\n        context.beginPath();\n        // 兼容逻辑\n        if (context.ellipse) {\n            context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);\n        }\n        else {\n            // 如果不支持，则使用圆来绘制，进行变形\n            var r = rx > ry ? rx : ry;\n            var scaleX = rx > ry ? 1 : rx / ry;\n            var scaleY = rx > ry ? ry / rx : 1;\n            context.save();\n            context.translate(cx, cy);\n            context.scale(scaleX, scaleY);\n            context.arc(0, 0, r, 0, Math.PI * 2);\n            context.restore();\n            context.closePath();\n        }\n    };\n    return Ellipse;\n}(ShapeBase));\nexport default Ellipse;\n//# sourceMappingURL=ellipse.js.map"]},"metadata":{},"sourceType":"module"}