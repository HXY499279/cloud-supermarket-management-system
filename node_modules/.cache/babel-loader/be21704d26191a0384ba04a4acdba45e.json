{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nvar HALF_PI = Math.PI / 2;\n/**\n * 极坐标下的图形 label\n */\n\nvar PolarLabel =\n/** @class */\nfunction (_super) {\n  __extends(PolarLabel, _super);\n\n  function PolarLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n\n\n  PolarLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      var r = coordinate.getRadius();\n\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n\n    return actualOffset;\n  };\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n\n\n  PolarLabel.prototype.getLabelItems = function (mapppingArray) {\n    var items = _super.prototype.getLabelItems.call(this, mapppingArray);\n\n    var yScale = this.geometry.getYScale();\n    return map(items, function (item) {\n      if (item && yScale) {\n        var percent = yScale.scale(get(item.data, yScale.field));\n        return __assign(__assign({}, item), {\n          percent: percent\n        });\n      }\n\n      return item;\n    });\n  };\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n\n\n  PolarLabel.prototype.getLabelAlign = function (point) {\n    var coordinate = this.getCoordinate();\n    var align;\n\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      var center = coordinate.getCenter();\n      var offset = point.offset;\n\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n\n    return align;\n  };\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n\n\n  PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var factor = 1;\n    var arcPoint;\n    var content = labelCfg.content[index];\n\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n\n    var offset = labelCfg.offset * factor;\n    var middleAngle = this.getPointAngle(arcPoint);\n    var isLabelEmit = labelCfg.labelEmit;\n    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n\n    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y\n    };\n    return labelPositionCfg;\n  };\n  /**\n   * 获取圆弧的位置\n   */\n\n\n  PolarLabel.prototype.getArcPoint = function (mappingData, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y\n      };\n    }\n\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y\n    };\n  };\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n\n\n  PolarLabel.prototype.getPointAngle = function (point) {\n    return getAngleByPoint(this.getCoordinate(), point);\n  };\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n\n\n  PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var r = getDistanceToCenter(coordinate, point);\n\n    if (r === 0) {\n      return __assign(__assign({}, center), {\n        r: r\n      });\n    }\n\n    var labelAngle = angle;\n\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      var appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r: r\n    };\n  };\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n\n\n  PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {\n    var rotate = angle + HALF_PI;\n\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n\n    return rotate;\n  }; // 获取中心的位置\n\n\n  PolarLabel.prototype.getMiddlePoint = function (points) {\n    var coordinate = this.getCoordinate();\n    var count = points.length;\n    var middlePoint = {\n      x: 0,\n      y: 0\n    };\n    each(points, function (point) {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  }; // 是否居中\n\n\n  PolarLabel.prototype.isToMiddle = function (mappingData) {\n    return mappingData.x.length > 2;\n  };\n\n  return PolarLabel;\n}(GeometryLabel);\n\nexport default PolarLabel;","map":{"version":3,"sources":["../../../src/geometry/label/polar.ts"],"names":[],"mappings":"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","sourcesContent":["import { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { MappingDatum, Point } from '../../interface';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, PolarLabelItem, LabelPointCfg, Writeable } from './interface';\n\nconst HALF_PI = Math.PI / 2;\n\n/**\n * 极坐标下的图形 label\n */\nexport default class PolarLabel extends GeometryLabel {\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      let r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n\n    return actualOffset;\n  }\n\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  public getLabelItems(mapppingArray: MappingDatum[]): PolarLabelItem[] {\n    const items = super.getLabelItems(mapppingArray);\n    const yScale = this.geometry.getYScale();\n\n    return map(items, (item) => {\n      if (item && yScale) {\n        const percent = yScale.scale(get(item.data, yScale.field));\n        return { ...item, percent };\n      }\n      return item;\n    });\n  }\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    let align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      const center = coordinate.getCenter();\n      const offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  }\n\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    let factor = 1;\n    let arcPoint;\n    const content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points as Point[]);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n\n    const offset = labelCfg.offset * factor;\n    const middleAngle = this.getPointAngle(arcPoint);\n    const isLabelEmit = labelCfg.labelEmit;\n    const labelPositionCfg: Writeable<LabelPointCfg> = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n\n    labelPositionCfg.rotate = labelCfg.autoRotate\n      ? this.getLabelRotate(middleAngle, offset, isLabelEmit)\n      : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y,\n    };\n    return labelPositionCfg;\n  }\n\n  /**\n   * 获取圆弧的位置\n   */\n  protected getArcPoint(mappingData: MappingDatum, index: number = 0): Point {\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y,\n      };\n    }\n\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y,\n    };\n  }\n\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  protected getPointAngle(point: Point): number {\n    return getAngleByPoint(this.getCoordinate(), point);\n  }\n\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  protected getCirclePoint(angle: number, offset: number, point: Point, isLabelEmit: boolean) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    let r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return {\n        ...center,\n        r,\n      };\n    }\n\n    let labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      const appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r,\n    };\n  }\n\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  protected getLabelRotate(angle: number, offset: number, isLabelEmit: boolean) {\n    let rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  // 获取中心的位置\n  private getMiddlePoint(points: Point[]) {\n    const coordinate = this.getCoordinate();\n    const count = points.length;\n    let middlePoint = {\n      x: 0,\n      y: 0,\n    };\n    each(points, (point: Point) => {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  }\n\n  // 是否居中\n  private isToMiddle(mappingData: MappingDatum) {\n    return (mappingData.x as number[]).length > 2;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}