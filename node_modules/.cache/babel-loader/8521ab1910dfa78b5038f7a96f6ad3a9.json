{"ast":null,"code":"import { each } from '@antv/util';\nvar MAX_TIMES = 100;\n/**\n * @ignore\n * Greedy 贪婪算法\n */\n\nvar Greedy =\n/** @class */\nfunction () {\n  function Greedy(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.bitmap = {};\n    var _a = cfg.xGap,\n        xGap = _a === void 0 ? 1 : _a,\n        _b = cfg.yGap,\n        yGap = _b === void 0 ? 8 : _b;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n\n  Greedy.prototype.hasGap = function (bbox) {\n    var hasGap = true;\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY);\n\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n\n      if (i === minX || i === maxX) {\n        for (var j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n\n    return hasGap;\n  };\n\n  Greedy.prototype.fillGap = function (bbox) {\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY); // filling grid\n\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n\n    for (var i = minX; i <= maxX; i += this.xGap) {\n      for (var j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n\n      bitmap[i][maxY] = true;\n    } // filling y edges\n\n\n    if (this.yGap !== 1) {\n      for (var i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    } // filling x edges\n\n\n    if (this.xGap !== 1) {\n      for (var i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  };\n\n  Greedy.prototype.destroy = function () {\n    this.bitmap = {};\n  };\n\n  return Greedy;\n}();\n\nfunction spiralFill(label, greedy, maxTimes) {\n  if (maxTimes === void 0) {\n    maxTimes = MAX_TIMES;\n  }\n\n  var dt = -1;\n\n  var _a = label.attr(),\n      x = _a.x,\n      y = _a.y;\n\n  var bbox = label.getCanvasBBox();\n  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  var dxdy;\n  var t = -dt;\n  var dx = 0;\n  var dy = 0;\n\n  var f = function f(param) {\n    var nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n\n  var canFill = false;\n  var times = 0;\n  var accessedCache = {};\n\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f(t += dt);\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n\n    if (!dx && !dy || accessedCache[dx + \"-\" + dy]) {\n      continue;\n    }\n\n    label.attr({\n      x: x + dx,\n      y: y + dy\n    });\n\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n\n    times++;\n\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[dx + \"-\" + dy] = true;\n      break;\n    }\n  }\n\n  return canFill;\n}\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\n\n\nfunction adjustLabelPosition(label, x, y, index) {\n  var _a = label.getCanvasBBox(),\n      width = _a.width,\n      height = _a.height;\n\n  var attrs = {\n    x: x,\n    y: y,\n    textAlign: 'center'\n  };\n\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n\n    default:\n      break;\n  }\n\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\n\n\nexport function fixedOverlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\n\nexport function overlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n\n    var _a = labelShape.attr(),\n        x = _a.x,\n        y = _a.y;\n\n    var canFill = false;\n\n    for (var i = 0; i <= 8; i++) {\n      var bbox = adjustLabelPosition(labelShape, x, y, i);\n\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}","map":{"version":3,"sources":["../../../../src/geometry/label/layout/overlap.ts"],"names":[],"mappings":"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","sourcesContent":["import { each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { LabelItem } from '../interface';\n\nconst MAX_TIMES = 100;\n\n/** @ignore */\ninterface Bitmap {\n  [key: number]: {\n    [key: number]: boolean;\n  };\n}\n\n/** @ignore */\ninterface GreedyCfg {\n  readonly xGap?: number;\n  readonly yGap?: number;\n}\n\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nclass Greedy {\n  public readonly xGap: number;\n  /** optimizing for text overlapping detection: use a min text height as gap */\n  public readonly yGap: number;\n\n  private bitmap: Bitmap = {};\n\n  constructor(cfg: GreedyCfg = {}) {\n    const { xGap = 1, yGap = 8 } = cfg;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n\n  public hasGap(bbox: BBox): boolean {\n    let hasGap = true;\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (let j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  }\n\n  public fillGap(bbox: BBox): void {\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (let i = minX; i <= maxX; i += this.xGap) {\n      for (let j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (let i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (let i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  }\n\n  public destroy(): void {\n    this.bitmap = {};\n  }\n}\n\nfunction spiralFill(label: IShape, greedy: Greedy, maxTimes: number = MAX_TIMES) {\n  const dt = -1;\n  const { x, y } = label.attr();\n  const bbox = label.getCanvasBBox();\n  const maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  let dxdy;\n  let t = -dt;\n  let dx = 0;\n  let dy = 0;\n  const f = (param: number) => {\n    const nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  let canFill = false;\n  let times = 0;\n  const accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f((t += dt));\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if ((!dx && !dy) || accessedCache[`${dx}-${dy}`]) {\n      continue;\n    }\n    label.attr({ x: x + dx, y: y + dy });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[`${dx}-${dy}`] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label: IShape, x: number, y: number, index: number) {\n  const { width, height } = label.getCanvasBBox();\n  const attrs = {\n    x,\n    y,\n    textAlign: 'center',\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    const { x, y } = labelShape.attr();\n    let canFill = false;\n    for (let i = 0; i <= 8; i++) {\n      const bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n\n  greedy.destroy();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}