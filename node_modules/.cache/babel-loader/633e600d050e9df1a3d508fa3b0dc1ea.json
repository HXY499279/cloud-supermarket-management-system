{"ast":null,"code":"/**\n * @fileoverview 事件处理器\n * @author dxq613@gmail.com\n */\nimport GraphEvent from './graph-event';\nimport { each, isParent } from '../util/util';\nvar CLICK_OFFSET = 40;\nvar LEFT_BTN_CODE = 0;\nvar DELEGATION_SPLIT = ':';\nvar EVENTS = ['mousedown', 'mouseup', 'dblclick', 'mouseout', 'mouseover', 'mousemove', 'mouseleave', 'mouseenter', 'touchstart', 'touchmove', 'touchend', 'dragenter', 'dragover', 'dragleave', 'drop', 'contextmenu', 'mousewheel']; // 是否有委托事件监听\n\nfunction hasDelegation(events, type) {\n  for (var key in events) {\n    if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\n      return true;\n    }\n  }\n\n  return false;\n} // 触发目标事件，目标只能是 shape 或 canvas\n\n\nfunction emitTargetEvent(target, type, eventObj) {\n  eventObj.name = type;\n  eventObj.target = target;\n  eventObj.currentTarget = target;\n  eventObj.delegateTarget = target;\n  target.emit(type, eventObj);\n} // 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\n\n\nfunction bubbleEvent(container, type, eventObj) {\n  if (eventObj.bubbles) {\n    var relativeShape = void 0;\n    var isOverEvent = false;\n\n    if (type === 'mouseenter') {\n      relativeShape = eventObj.fromShape;\n      isOverEvent = true;\n    } else if (type === 'mouseleave') {\n      isOverEvent = true;\n      relativeShape = eventObj.toShape;\n    } // canvas 上的 mouseenter， mouseleave 事件，仅当进入或者移出 canvas 时触发\n\n\n    if (container.isCanvas() && isOverEvent) {\n      return;\n    } // 如果相关图形同当前图形在同一个容器内，不触发事件\n\n\n    if (relativeShape && isParent(container, relativeShape)) {\n      // 阻止继续向上冒泡\n      eventObj.bubbles = false;\n      return;\n    } // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\n\n\n    eventObj.name = type;\n    eventObj.currentTarget = container;\n    eventObj.delegateTarget = container;\n    container.emit(type, eventObj);\n  }\n}\n\nvar EventController =\n/** @class */\nfunction () {\n  function EventController(cfg) {\n    var _this = this; // 正在被拖拽的图形\n\n\n    this.draggingShape = null;\n    this.dragging = false; // 当前鼠标/touch所在位置的图形\n\n    this.currentShape = null;\n    this.mousedownShape = null;\n    this.mousedownPoint = null; // 统一处理所有的回调\n\n    this._eventCallback = function (ev) {\n      var type = ev.type;\n\n      _this._triggerEvent(type, ev);\n    }; // 在 document 处理拖拽到画布外的事件，处理从图形上移除画布未被捕捉的问题\n\n\n    this._onDocumentMove = function (ev) {\n      var canvas = _this.canvas;\n      var el = canvas.get('el');\n\n      if (el !== ev.target) {\n        // 不在 canvas 上移动\n        if (_this.dragging || _this.currentShape) {\n          var pointInfo = _this._getPointInfo(ev); // 还在拖拽过程中\n\n\n          if (_this.dragging) {\n            _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);\n          } // 说明从某个图形直接移动到了画布外面，\n          // 修复了 mouseleave 的 bug 后不再出现这种情况\n          // if (this.currentShape) {\n          //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);\n          //   this.currentShape = null;\n          // }\n\n        }\n      }\n    }; // 在 document 上处理拖拽到外面，释放鼠标时触发 dragend\n\n\n    this._onDocumentMouseUp = function (ev) {\n      var canvas = _this.canvas;\n      var el = canvas.get('el');\n\n      if (el !== ev.target) {\n        // 不在 canvas 上移动\n        if (_this.dragging) {\n          var pointInfo = _this._getPointInfo(ev);\n\n          if (_this.draggingShape) {\n            // 如果存在拖拽的图形，则也触发 drop 事件\n            _this._emitEvent('drop', ev, pointInfo, null);\n          }\n\n          _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);\n\n          _this._afterDrag(_this.draggingShape, pointInfo, ev);\n        }\n      }\n    };\n\n    this.canvas = cfg.canvas;\n  }\n\n  EventController.prototype.init = function () {\n    this._bindEvents();\n  }; // 注册事件\n\n\n  EventController.prototype._bindEvents = function () {\n    var _this = this;\n\n    var el = this.canvas.get('el');\n    each(EVENTS, function (eventName) {\n      el.addEventListener(eventName, _this._eventCallback);\n    });\n\n    if (document) {\n      // 处理移动到外面没有触发 shape mouse leave 的事件\n      // 处理拖拽到外部的问题\n      document.addEventListener('mousemove', this._onDocumentMove); // 处理拖拽过程中在外部释放鼠标的问题\n\n      document.addEventListener('mouseup', this._onDocumentMouseUp);\n    }\n  }; // 清理事件\n\n\n  EventController.prototype._clearEvents = function () {\n    var _this = this;\n\n    var el = this.canvas.get('el');\n    each(EVENTS, function (eventName) {\n      el.removeEventListener(eventName, _this._eventCallback);\n    });\n\n    if (document) {\n      document.removeEventListener('mousemove', this._onDocumentMove);\n      document.removeEventListener('mouseup', this._onDocumentMouseUp);\n    }\n  };\n\n  EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\n    var eventObj = new GraphEvent(type, event);\n    eventObj.fromShape = fromShape;\n    eventObj.toShape = toShape;\n    eventObj.x = point.x;\n    eventObj.y = point.y;\n    eventObj.clientX = point.clientX;\n    eventObj.clientY = point.clientY;\n    eventObj.propagationPath.push(target); // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\n\n    return eventObj;\n  }; // 根据点获取图形，提取成独立方法，便于后续优化\n\n\n  EventController.prototype._getShape = function (point, ev) {\n    return this.canvas.getShape(point.x, point.y, ev);\n  }; // 获取事件的当前点的信息\n\n\n  EventController.prototype._getPointInfo = function (ev) {\n    var canvas = this.canvas;\n    var clientPoint = canvas.getClientByEvent(ev);\n    var point = canvas.getPointByEvent(ev);\n    return {\n      x: point.x,\n      y: point.y,\n      clientX: clientPoint.x,\n      clientY: clientPoint.y\n    };\n  }; // 触发事件\n\n\n  EventController.prototype._triggerEvent = function (type, ev) {\n    var pointInfo = this._getPointInfo(ev); // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\n\n\n    var shape = this._getShape(pointInfo, ev);\n\n    var method = this[\"_on\" + type];\n    var leaveCanvas = false;\n\n    if (method) {\n      method.call(this, pointInfo, shape, ev);\n    } else {\n      var preShape = this.currentShape; // 如果进入、移出画布时存在图形，则要分别触发事件\n\n      if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {\n        this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\n\n\n        if (shape) {\n          this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\n\n        }\n\n        if (type === 'mouseenter' && this.draggingShape) {\n          // 如果正在拖拽图形, 则触发 dragleave\n          this._emitEvent('dragenter', ev, pointInfo, null);\n        }\n      } else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {\n        leaveCanvas = true;\n\n        if (preShape) {\n          this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\n\n        }\n\n        this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\n\n\n        if (type === 'mouseleave' && this.draggingShape) {\n          this._emitEvent('dragleave', ev, pointInfo, null);\n        }\n      } else {\n        this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\n\n      }\n    }\n\n    if (!leaveCanvas) {\n      this.currentShape = shape;\n    } // 当鼠标从画布移动到 shape 或者从 preShape 移动到 shape 时，应用 shape 上的鼠标样式\n\n\n    if (shape && !shape.get('destroyed')) {\n      var canvas = this.canvas;\n      var el = canvas.get('el');\n      el.style.cursor = shape.attr('cursor') || canvas.get('cursor');\n    }\n  }; // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\n\n\n  EventController.prototype._onmousedown = function (pointInfo, shape, event) {\n    // 只有鼠标左键的 mousedown 事件才会设置 mousedownShape 等属性，避免鼠标右键的 mousedown 事件引起其他事件发生\n    if (event.button === LEFT_BTN_CODE) {\n      this.mousedownShape = shape;\n      this.mousedownPoint = pointInfo;\n      this.mousedownTimeStamp = event.timeStamp;\n    }\n\n    this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown 不考虑fromShape, toShape\n\n  }; // mouseleave 和 mouseenter 都是成对存在的\n  // mouseenter 和 mouseover 同时触发\n\n\n  EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {\n    var el = this.canvas.get('el');\n\n    if (fromShape !== toShape) {\n      if (fromShape) {\n        this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);\n\n        this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape); // 当鼠标从 fromShape 移动到画布上时，重置鼠标样式\n\n\n        if (!toShape || toShape.get('destroyed')) {\n          el.style.cursor = this.canvas.get('cursor');\n        }\n      }\n\n      if (toShape) {\n        this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);\n\n        this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);\n      }\n    }\n  }; // dragover 不等同于 mouseover，而等同于 mousemove\n\n\n  EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\n    if (toShape) {\n      if (toShape !== fromShape) {\n        if (fromShape) {\n          this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n        }\n\n        this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\n      }\n\n      if (!isCanvasEmit) {\n        this._emitEvent('dragover', event, pointInfo, toShape);\n      }\n    } else if (fromShape) {\n      // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\n      // 经过空白区域\n      this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n    }\n\n    if (isCanvasEmit) {\n      this._emitEvent('dragover', event, pointInfo, toShape);\n    }\n  }; // drag 完成后，需要做一些清理工作\n\n\n  EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\n    if (draggingShape) {\n      draggingShape.set('capture', true); // 恢复可以拾取\n\n      this.draggingShape = null;\n    }\n\n    this.dragging = false; // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\n\n    var shape = this._getShape(pointInfo, event); // 拖拽完成后，进行 enter，leave 的判定\n\n\n    if (shape !== draggingShape) {\n      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);\n    }\n\n    this.currentShape = shape; // 更新当前 shape，如果不处理当前图形的 mouseleave 事件可能会出问题\n  }; // 按键抬起时，会终止拖拽、触发点击\n\n\n  EventController.prototype._onmouseup = function (pointInfo, shape, event) {\n    // eevent.button === 0 表示鼠标左键事件，此处加上判断主要是为了避免右键鼠标会触发 mouseup 和 click 事件\n    // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n    if (event.button === LEFT_BTN_CODE) {\n      var draggingShape = this.draggingShape;\n\n      if (this.dragging) {\n        // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\n        if (draggingShape) {\n          this._emitEvent('drop', event, pointInfo, shape);\n        }\n\n        this._emitEvent('dragend', event, pointInfo, draggingShape);\n\n        this._afterDrag(draggingShape, pointInfo, event);\n      } else {\n        this._emitEvent('mouseup', event, pointInfo, shape); // 先触发 mouseup 再触发 click\n\n\n        if (shape === this.mousedownShape) {\n          this._emitEvent('click', event, pointInfo, shape);\n        }\n\n        this.mousedownShape = null;\n        this.mousedownPoint = null;\n      }\n    }\n  }; // 当触发浏览器的 dragover 事件时，不会再触发 mousemove ，所以这时候的 dragenter, dragleave 事件需要重新处理\n\n\n  EventController.prototype._ondragover = function (pointInfo, shape, event) {\n    event.preventDefault(); // 如果不对 dragover 进行 preventDefault，则不会在 canvas 上触发 drop 事件\n\n    var preShape = this.currentShape;\n\n    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\n  }; // 大量的图形事件，都通过 mousemove 模拟\n\n\n  EventController.prototype._onmousemove = function (pointInfo, shape, event) {\n    var canvas = this.canvas;\n    var preShape = this.currentShape;\n    var draggingShape = this.draggingShape; // 正在拖拽时\n\n    if (this.dragging) {\n      // 正在拖拽中\n      if (draggingShape) {\n        // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\n      } // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\n      // 否则在 canvas 上触发 drag 事件\n\n\n      this._emitEvent('drag', event, pointInfo, draggingShape);\n    } else {\n      var mousedownPoint = this.mousedownPoint;\n\n      if (mousedownPoint) {\n        // 当鼠标点击下去，同时移动时，进行 drag 判定\n        var mousedownShape = this.mousedownShape;\n        var now = event.timeStamp;\n        var timeWindow = now - this.mousedownTimeStamp;\n        var dx = mousedownPoint.clientX - pointInfo.clientX;\n        var dy = mousedownPoint.clientY - pointInfo.clientY;\n        var dist = dx * dx + dy * dy;\n\n        if (timeWindow > 120 || dist > CLICK_OFFSET) {\n          if (mousedownShape && mousedownShape.get('draggable')) {\n            // 设置了 draggable 的 shape 才能触发 drag 相关的事件\n            draggingShape = this.mousedownShape; // 拖动鼠标点下时的 shape\n\n            draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\n\n            this.draggingShape = draggingShape;\n            this.dragging = true;\n\n            this._emitEvent('dragstart', event, pointInfo, draggingShape); // 清理按下鼠标时缓存的值\n\n\n            this.mousedownShape = null;\n            this.mousedownPoint = null;\n          } else if (!mousedownShape && canvas.get('draggable')) {\n            // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\n            this.dragging = true;\n\n            this._emitEvent('dragstart', event, pointInfo, null); // 清理按下鼠标时缓存的值\n\n\n            this.mousedownShape = null;\n            this.mousedownPoint = null;\n          } else {\n            this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n\n            this._emitEvent('mousemove', event, pointInfo, shape);\n          }\n        } else {\n          this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n\n          this._emitEvent('mousemove', event, pointInfo, shape);\n        }\n      } else {\n        // 没有按键按下时，则直接触发 mouse over 相关的各种事件\n        this._emitMouseoverEvents(event, pointInfo, preShape, shape); // 始终触发移动\n\n\n        this._emitEvent('mousemove', event, pointInfo, shape);\n      }\n    }\n  }; // 触发事件\n\n\n  EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\n    var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape); // 存在 shape 触发，则进行冒泡处理\n\n\n    if (shape) {\n      eventObj.shape = shape; // 触发 shape 上的事件\n\n      emitTargetEvent(shape, type, eventObj);\n      var parent_1 = shape.getParent(); // 执行冒泡\n\n      while (parent_1) {\n        // 委托事件要先触发\n        parent_1.emitDelegation(type, eventObj); // 事件冒泡停止，不能妨碍委托事件\n\n        if (!eventObj.propagationStopped) {\n          bubbleEvent(parent_1, type, eventObj);\n        }\n\n        eventObj.propagationPath.push(parent_1);\n        parent_1 = parent_1.getParent();\n      }\n    } else {\n      // 如果没有 shape 直接在 canvas 上触发\n      var canvas = this.canvas; // 直接触发 canvas 上的事件\n\n      emitTargetEvent(canvas, type, eventObj);\n    }\n  };\n\n  EventController.prototype.destroy = function () {\n    // 清理事件\n    this._clearEvents(); // 清理缓存的对象\n\n\n    this.canvas = null;\n    this.currentShape = null;\n    this.draggingShape = null;\n    this.mousedownPoint = null;\n    this.mousedownShape = null;\n    this.mousedownTimeStamp = null;\n  };\n\n  return EventController;\n}();\n\nexport default EventController;","map":{"version":3,"sources":["../../src/event/event-contoller.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileoverview 事件处理器\n * @author dxq613@gmail.com\n */\nimport GraphEvent from './graph-event';\nimport { each, isParent } from '../util/util';\nvar CLICK_OFFSET = 40;\nvar LEFT_BTN_CODE = 0;\nvar DELEGATION_SPLIT = ':';\nvar EVENTS = [\n    'mousedown',\n    'mouseup',\n    'dblclick',\n    'mouseout',\n    'mouseover',\n    'mousemove',\n    'mouseleave',\n    'mouseenter',\n    'touchstart',\n    'touchmove',\n    'touchend',\n    'dragenter',\n    'dragover',\n    'dragleave',\n    'drop',\n    'contextmenu',\n    'mousewheel',\n];\n// 是否有委托事件监听\nfunction hasDelegation(events, type) {\n    for (var key in events) {\n        if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\n            return true;\n        }\n    }\n    return false;\n}\n// 触发目标事件，目标只能是 shape 或 canvas\nfunction emitTargetEvent(target, type, eventObj) {\n    eventObj.name = type;\n    eventObj.target = target;\n    eventObj.currentTarget = target;\n    eventObj.delegateTarget = target;\n    target.emit(type, eventObj);\n}\n// 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\nfunction bubbleEvent(container, type, eventObj) {\n    if (eventObj.bubbles) {\n        var relativeShape = void 0;\n        var isOverEvent = false;\n        if (type === 'mouseenter') {\n            relativeShape = eventObj.fromShape;\n            isOverEvent = true;\n        }\n        else if (type === 'mouseleave') {\n            isOverEvent = true;\n            relativeShape = eventObj.toShape;\n        }\n        // canvas 上的 mouseenter， mouseleave 事件，仅当进入或者移出 canvas 时触发\n        if (container.isCanvas() && isOverEvent) {\n            return;\n        }\n        // 如果相关图形同当前图形在同一个容器内，不触发事件\n        if (relativeShape && isParent(container, relativeShape)) {\n            // 阻止继续向上冒泡\n            eventObj.bubbles = false;\n            return;\n        }\n        // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\n        eventObj.name = type;\n        eventObj.currentTarget = container;\n        eventObj.delegateTarget = container;\n        container.emit(type, eventObj);\n    }\n}\nvar EventController = /** @class */ (function () {\n    function EventController(cfg) {\n        var _this = this;\n        // 正在被拖拽的图形\n        this.draggingShape = null;\n        this.dragging = false;\n        // 当前鼠标/touch所在位置的图形\n        this.currentShape = null;\n        this.mousedownShape = null;\n        this.mousedownPoint = null;\n        // 统一处理所有的回调\n        this._eventCallback = function (ev) {\n            var type = ev.type;\n            _this._triggerEvent(type, ev);\n        };\n        // 在 document 处理拖拽到画布外的事件，处理从图形上移除画布未被捕捉的问题\n        this._onDocumentMove = function (ev) {\n            var canvas = _this.canvas;\n            var el = canvas.get('el');\n            if (el !== ev.target) {\n                // 不在 canvas 上移动\n                if (_this.dragging || _this.currentShape) {\n                    var pointInfo = _this._getPointInfo(ev);\n                    // 还在拖拽过程中\n                    if (_this.dragging) {\n                        _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);\n                    }\n                    // 说明从某个图形直接移动到了画布外面，\n                    // 修复了 mouseleave 的 bug 后不再出现这种情况\n                    // if (this.currentShape) {\n                    //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);\n                    //   this.currentShape = null;\n                    // }\n                }\n            }\n        };\n        // 在 document 上处理拖拽到外面，释放鼠标时触发 dragend\n        this._onDocumentMouseUp = function (ev) {\n            var canvas = _this.canvas;\n            var el = canvas.get('el');\n            if (el !== ev.target) {\n                // 不在 canvas 上移动\n                if (_this.dragging) {\n                    var pointInfo = _this._getPointInfo(ev);\n                    if (_this.draggingShape) {\n                        // 如果存在拖拽的图形，则也触发 drop 事件\n                        _this._emitEvent('drop', ev, pointInfo, null);\n                    }\n                    _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);\n                    _this._afterDrag(_this.draggingShape, pointInfo, ev);\n                }\n            }\n        };\n        this.canvas = cfg.canvas;\n    }\n    EventController.prototype.init = function () {\n        this._bindEvents();\n    };\n    // 注册事件\n    EventController.prototype._bindEvents = function () {\n        var _this = this;\n        var el = this.canvas.get('el');\n        each(EVENTS, function (eventName) {\n            el.addEventListener(eventName, _this._eventCallback);\n        });\n        if (document) {\n            // 处理移动到外面没有触发 shape mouse leave 的事件\n            // 处理拖拽到外部的问题\n            document.addEventListener('mousemove', this._onDocumentMove);\n            // 处理拖拽过程中在外部释放鼠标的问题\n            document.addEventListener('mouseup', this._onDocumentMouseUp);\n        }\n    };\n    // 清理事件\n    EventController.prototype._clearEvents = function () {\n        var _this = this;\n        var el = this.canvas.get('el');\n        each(EVENTS, function (eventName) {\n            el.removeEventListener(eventName, _this._eventCallback);\n        });\n        if (document) {\n            document.removeEventListener('mousemove', this._onDocumentMove);\n            document.removeEventListener('mouseup', this._onDocumentMouseUp);\n        }\n    };\n    EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\n        var eventObj = new GraphEvent(type, event);\n        eventObj.fromShape = fromShape;\n        eventObj.toShape = toShape;\n        eventObj.x = point.x;\n        eventObj.y = point.y;\n        eventObj.clientX = point.clientX;\n        eventObj.clientY = point.clientY;\n        eventObj.propagationPath.push(target);\n        // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\n        return eventObj;\n    };\n    // 根据点获取图形，提取成独立方法，便于后续优化\n    EventController.prototype._getShape = function (point, ev) {\n        return this.canvas.getShape(point.x, point.y, ev);\n    };\n    // 获取事件的当前点的信息\n    EventController.prototype._getPointInfo = function (ev) {\n        var canvas = this.canvas;\n        var clientPoint = canvas.getClientByEvent(ev);\n        var point = canvas.getPointByEvent(ev);\n        return {\n            x: point.x,\n            y: point.y,\n            clientX: clientPoint.x,\n            clientY: clientPoint.y,\n        };\n    };\n    // 触发事件\n    EventController.prototype._triggerEvent = function (type, ev) {\n        var pointInfo = this._getPointInfo(ev);\n        // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\n        var shape = this._getShape(pointInfo, ev);\n        var method = this[\"_on\" + type];\n        var leaveCanvas = false;\n        if (method) {\n            method.call(this, pointInfo, shape, ev);\n        }\n        else {\n            var preShape = this.currentShape;\n            // 如果进入、移出画布时存在图形，则要分别触发事件\n            if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {\n                this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\n                if (shape) {\n                    this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\n                }\n                if (type === 'mouseenter' && this.draggingShape) {\n                    // 如果正在拖拽图形, 则触发 dragleave\n                    this._emitEvent('dragenter', ev, pointInfo, null);\n                }\n            }\n            else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {\n                leaveCanvas = true;\n                if (preShape) {\n                    this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\n                }\n                this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\n                if (type === 'mouseleave' && this.draggingShape) {\n                    this._emitEvent('dragleave', ev, pointInfo, null);\n                }\n            }\n            else {\n                this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\n            }\n        }\n        if (!leaveCanvas) {\n            this.currentShape = shape;\n        }\n        // 当鼠标从画布移动到 shape 或者从 preShape 移动到 shape 时，应用 shape 上的鼠标样式\n        if (shape && !shape.get('destroyed')) {\n            var canvas = this.canvas;\n            var el = canvas.get('el');\n            el.style.cursor = shape.attr('cursor') || canvas.get('cursor');\n        }\n    };\n    // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\n    EventController.prototype._onmousedown = function (pointInfo, shape, event) {\n        // 只有鼠标左键的 mousedown 事件才会设置 mousedownShape 等属性，避免鼠标右键的 mousedown 事件引起其他事件发生\n        if (event.button === LEFT_BTN_CODE) {\n            this.mousedownShape = shape;\n            this.mousedownPoint = pointInfo;\n            this.mousedownTimeStamp = event.timeStamp;\n        }\n        this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown 不考虑fromShape, toShape\n    };\n    // mouseleave 和 mouseenter 都是成对存在的\n    // mouseenter 和 mouseover 同时触发\n    EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {\n        var el = this.canvas.get('el');\n        if (fromShape !== toShape) {\n            if (fromShape) {\n                this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);\n                this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape);\n                // 当鼠标从 fromShape 移动到画布上时，重置鼠标样式\n                if (!toShape || toShape.get('destroyed')) {\n                    el.style.cursor = this.canvas.get('cursor');\n                }\n            }\n            if (toShape) {\n                this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);\n                this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n        }\n    };\n    // dragover 不等同于 mouseover，而等同于 mousemove\n    EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\n        if (toShape) {\n            if (toShape !== fromShape) {\n                if (fromShape) {\n                    this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n                }\n                this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n            if (!isCanvasEmit) {\n                this._emitEvent('dragover', event, pointInfo, toShape);\n            }\n        }\n        else if (fromShape) {\n            // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\n            // 经过空白区域\n            this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n        }\n        if (isCanvasEmit) {\n            this._emitEvent('dragover', event, pointInfo, toShape);\n        }\n    };\n    // drag 完成后，需要做一些清理工作\n    EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\n        if (draggingShape) {\n            draggingShape.set('capture', true); // 恢复可以拾取\n            this.draggingShape = null;\n        }\n        this.dragging = false;\n        // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\n        var shape = this._getShape(pointInfo, event);\n        // 拖拽完成后，进行 enter，leave 的判定\n        if (shape !== draggingShape) {\n            this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);\n        }\n        this.currentShape = shape; // 更新当前 shape，如果不处理当前图形的 mouseleave 事件可能会出问题\n    };\n    // 按键抬起时，会终止拖拽、触发点击\n    EventController.prototype._onmouseup = function (pointInfo, shape, event) {\n        // eevent.button === 0 表示鼠标左键事件，此处加上判断主要是为了避免右键鼠标会触发 mouseup 和 click 事件\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n        if (event.button === LEFT_BTN_CODE) {\n            var draggingShape = this.draggingShape;\n            if (this.dragging) {\n                // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\n                if (draggingShape) {\n                    this._emitEvent('drop', event, pointInfo, shape);\n                }\n                this._emitEvent('dragend', event, pointInfo, draggingShape);\n                this._afterDrag(draggingShape, pointInfo, event);\n            }\n            else {\n                this._emitEvent('mouseup', event, pointInfo, shape); // 先触发 mouseup 再触发 click\n                if (shape === this.mousedownShape) {\n                    this._emitEvent('click', event, pointInfo, shape);\n                }\n                this.mousedownShape = null;\n                this.mousedownPoint = null;\n            }\n        }\n    };\n    // 当触发浏览器的 dragover 事件时，不会再触发 mousemove ，所以这时候的 dragenter, dragleave 事件需要重新处理\n    EventController.prototype._ondragover = function (pointInfo, shape, event) {\n        event.preventDefault(); // 如果不对 dragover 进行 preventDefault，则不会在 canvas 上触发 drop 事件\n        var preShape = this.currentShape;\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\n    };\n    // 大量的图形事件，都通过 mousemove 模拟\n    EventController.prototype._onmousemove = function (pointInfo, shape, event) {\n        var canvas = this.canvas;\n        var preShape = this.currentShape;\n        var draggingShape = this.draggingShape;\n        // 正在拖拽时\n        if (this.dragging) {\n            // 正在拖拽中\n            if (draggingShape) {\n                // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\n                this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\n            }\n            // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\n            // 否则在 canvas 上触发 drag 事件\n            this._emitEvent('drag', event, pointInfo, draggingShape);\n        }\n        else {\n            var mousedownPoint = this.mousedownPoint;\n            if (mousedownPoint) {\n                // 当鼠标点击下去，同时移动时，进行 drag 判定\n                var mousedownShape = this.mousedownShape;\n                var now = event.timeStamp;\n                var timeWindow = now - this.mousedownTimeStamp;\n                var dx = mousedownPoint.clientX - pointInfo.clientX;\n                var dy = mousedownPoint.clientY - pointInfo.clientY;\n                var dist = dx * dx + dy * dy;\n                if (timeWindow > 120 || dist > CLICK_OFFSET) {\n                    if (mousedownShape && mousedownShape.get('draggable')) {\n                        // 设置了 draggable 的 shape 才能触发 drag 相关的事件\n                        draggingShape = this.mousedownShape; // 拖动鼠标点下时的 shape\n                        draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\n                        this.draggingShape = draggingShape;\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, draggingShape);\n                        // 清理按下鼠标时缓存的值\n                        this.mousedownShape = null;\n                        this.mousedownPoint = null;\n                    }\n                    else if (!mousedownShape && canvas.get('draggable')) {\n                        // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, null);\n                        // 清理按下鼠标时缓存的值\n                        this.mousedownShape = null;\n                        this.mousedownPoint = null;\n                    }\n                    else {\n                        this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                        this._emitEvent('mousemove', event, pointInfo, shape);\n                    }\n                }\n                else {\n                    this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                    this._emitEvent('mousemove', event, pointInfo, shape);\n                }\n            }\n            else {\n                // 没有按键按下时，则直接触发 mouse over 相关的各种事件\n                this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                // 始终触发移动\n                this._emitEvent('mousemove', event, pointInfo, shape);\n            }\n        }\n    };\n    // 触发事件\n    EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\n        var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\n        // 存在 shape 触发，则进行冒泡处理\n        if (shape) {\n            eventObj.shape = shape;\n            // 触发 shape 上的事件\n            emitTargetEvent(shape, type, eventObj);\n            var parent_1 = shape.getParent();\n            // 执行冒泡\n            while (parent_1) {\n                // 委托事件要先触发\n                parent_1.emitDelegation(type, eventObj);\n                // 事件冒泡停止，不能妨碍委托事件\n                if (!eventObj.propagationStopped) {\n                    bubbleEvent(parent_1, type, eventObj);\n                }\n                eventObj.propagationPath.push(parent_1);\n                parent_1 = parent_1.getParent();\n            }\n        }\n        else {\n            // 如果没有 shape 直接在 canvas 上触发\n            var canvas = this.canvas;\n            // 直接触发 canvas 上的事件\n            emitTargetEvent(canvas, type, eventObj);\n        }\n    };\n    EventController.prototype.destroy = function () {\n        // 清理事件\n        this._clearEvents();\n        // 清理缓存的对象\n        this.canvas = null;\n        this.currentShape = null;\n        this.draggingShape = null;\n        this.mousedownPoint = null;\n        this.mousedownShape = null;\n        this.mousedownTimeStamp = null;\n    };\n    return EventController;\n}());\nexport default EventController;\n//# sourceMappingURL=event-contoller.js.map"]},"metadata":{},"sourceType":"module"}