{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each } from '@antv/util';\nimport GridBase from './base';\n\nfunction distance(x1, y1, x2, y2) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nvar Circle =\n/** @class */\nfunction (_super) {\n  __extends(Circle, _super);\n\n  function Circle() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Circle.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n\n      /**\n       * 中心点\n       * @type {object}\n       */\n      center: null,\n\n      /**\n       * 栅格线是否封闭\n       * @type {true}\n       */\n      closed: true\n    });\n  };\n\n  Circle.prototype.getGridPath = function (points, reversed) {\n    var lineType = this.getLineType();\n    var closed = this.get('closed');\n    var path = [];\n\n    if (points.length) {\n      // 防止出错\n      if (lineType === 'circle') {\n        var center = this.get('center');\n        var firstPoint = points[0];\n        var radius_1 = distance(center.x, center.y, firstPoint.x, firstPoint.y);\n        var sweepFlag_1 = reversed ? 0 : 1; // 顺时针还是逆时针\n\n        if (closed) {\n          // 封闭时，绘制整个圆\n          path.push(['M', center.x, center.y - radius_1]);\n          path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);\n          path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);\n          path.push(['Z']);\n        } else {\n          each(points, function (point, index) {\n            if (index === 0) {\n              path.push(['M', point.x, point.y]);\n            } else {\n              path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);\n            }\n          });\n        }\n      } else {\n        each(points, function (point, index) {\n          if (index === 0) {\n            path.push(['M', point.x, point.y]);\n          } else {\n            path.push(['L', point.x, point.y]);\n          }\n        });\n\n        if (closed) {\n          path.push(['Z']);\n        }\n      }\n    }\n\n    return path;\n  };\n\n  return Circle;\n}(GridBase);\n\nexport default Circle;","map":{"version":3,"sources":["../../src/grid/circle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { each } from '@antv/util';\nimport GridBase from './base';\nfunction distance(x1, y1, x2, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    return Math.sqrt(dx * dx + dy * dy);\n}\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Circle.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'circle', \n            /**\n             * 中心点\n             * @type {object}\n             */\n            center: null, \n            /**\n             * 栅格线是否封闭\n             * @type {true}\n             */\n            closed: true });\n    };\n    Circle.prototype.getGridPath = function (points, reversed) {\n        var lineType = this.getLineType();\n        var closed = this.get('closed');\n        var path = [];\n        if (points.length) {\n            // 防止出错\n            if (lineType === 'circle') {\n                var center = this.get('center');\n                var firstPoint = points[0];\n                var radius_1 = distance(center.x, center.y, firstPoint.x, firstPoint.y);\n                var sweepFlag_1 = reversed ? 0 : 1; // 顺时针还是逆时针\n                if (closed) {\n                    // 封闭时，绘制整个圆\n                    path.push(['M', center.x, center.y - radius_1]);\n                    path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);\n                    path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);\n                    path.push(['Z']);\n                }\n                else {\n                    each(points, function (point, index) {\n                        if (index === 0) {\n                            path.push(['M', point.x, point.y]);\n                        }\n                        else {\n                            path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);\n                        }\n                    });\n                }\n            }\n            else {\n                each(points, function (point, index) {\n                    if (index === 0) {\n                        path.push(['M', point.x, point.y]);\n                    }\n                    else {\n                        path.push(['L', point.x, point.y]);\n                    }\n                });\n                if (closed) {\n                    path.push(['Z']);\n                }\n            }\n        }\n        return path;\n    };\n    return Circle;\n}(GridBase));\nexport default Circle;\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"module"}