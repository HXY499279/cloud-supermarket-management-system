{"ast":null,"code":"import { each, isNil } from '@antv/util'; // 求以a为次幂，结果为b的基数，如 x^^a = b;求x\n// 虽然数学上 b 不支持负数，但是这里需要支持 负数\n\nexport function calBase(a, b) {\n  var e = Math.E;\n  var value;\n\n  if (b >= 0) {\n    value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底\n  } else {\n    value = Math.pow(e, Math.log(-b) / a) * -1; // 使用换底公式求底\n  }\n\n  return value;\n}\nexport function log(a, b) {\n  if (a === 1) {\n    return 1;\n  }\n\n  return Math.log(b) / Math.log(a);\n}\nexport function getLogPositiveMin(values, base, max) {\n  if (isNil(max)) {\n    max = Math.max.apply(null, values);\n  }\n\n  var positiveMin = max;\n  each(values, function (value) {\n    if (value > 0 && value < positiveMin) {\n      positiveMin = value;\n    }\n  });\n\n  if (positiveMin === max) {\n    positiveMin = max / base;\n  }\n\n  if (positiveMin > 1) {\n    positiveMin = 1;\n  }\n\n  return positiveMin;\n}\n\nfunction digitLength(num) {\n  // Get digit length of e\n  var eSplit = num.toString().split(/[eE]/);\n  var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);\n  return len > 0 ? len : 0;\n}\n/**\n * 高精度加法，解决 0.1 + 0.2 !== 0.3 的经典问题\n *\n * @param num1 加数\n * @param num2 被加数\n * @return {number} 返回值\n */\n\n\nexport function precisionAdd(num1, num2) {\n  var num1Digits = digitLength(num1);\n  var num2Digits = digitLength(num2);\n  var baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n  return (num1 * baseNum + num2 * baseNum) / baseNum;\n}","map":{"version":3,"sources":["../../src/util/math.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,EAAe,KAAf,QAA4B,YAA5B,C,CAEA;AACA;;AACA,OAAM,SAAU,OAAV,CAAkB,CAAlB,EAA6B,CAA7B,EAAsC;AAC1C,MAAM,CAAC,GAAG,IAAI,CAAC,CAAf;AACA,MAAI,KAAJ;;AACA,MAAI,CAAC,IAAI,CAAT,EAAY;AACV,IAAA,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,GAAL,CAAS,CAAT,IAAc,CAA1B,CAAR,CADU,CAC4B;AACvC,GAFD,MAEO;AACL,IAAA,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,GAAL,CAAS,CAAC,CAAV,IAAe,CAA3B,IAAgC,CAAC,CAAzC,CADK,CACuC;AAC7C;;AACD,SAAO,KAAP;AACD;AAED,OAAM,SAAU,GAAV,CAAc,CAAd,EAAyB,CAAzB,EAAkC;AACtC,MAAI,CAAC,KAAK,CAAV,EAAa;AACX,WAAO,CAAP;AACD;;AACD,SAAO,IAAI,CAAC,GAAL,CAAS,CAAT,IAAc,IAAI,CAAC,GAAL,CAAS,CAAT,CAArB;AACD;AAED,OAAM,SAAU,iBAAV,CAA4B,MAA5B,EAAoC,IAApC,EAA0C,GAA1C,EAAsD;AAC1D,MAAI,KAAK,CAAC,GAAD,CAAT,EAAgB;AACd,IAAA,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAe,IAAf,EAAqB,MAArB,CAAN;AACD;;AACD,MAAI,WAAW,GAAG,GAAlB;AACA,EAAA,IAAI,CAAC,MAAD,EAAS,UAAC,KAAD,EAAM;AACjB,QAAI,KAAK,GAAG,CAAR,IAAa,KAAK,GAAG,WAAzB,EAAsC;AACpC,MAAA,WAAW,GAAG,KAAd;AACD;AACF,GAJG,CAAJ;;AAKA,MAAI,WAAW,KAAK,GAApB,EAAyB;AACvB,IAAA,WAAW,GAAG,GAAG,GAAG,IAApB;AACD;;AACD,MAAI,WAAW,GAAG,CAAlB,EAAqB;AACnB,IAAA,WAAW,GAAG,CAAd;AACD;;AACD,SAAO,WAAP;AACD;;AAED,SAAS,WAAT,CAAqB,GAArB,EAAgC;AAC9B;AACA,MAAM,MAAM,GAAG,GAAG,CAAC,QAAJ,GAAe,KAAf,CAAqB,MAArB,CAAf;AACA,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAD,CAAN,CAAU,KAAV,CAAgB,GAAhB,EAAqB,CAArB,KAA2B,EAA5B,EAAgC,MAAhC,GAAyC,EAAE,MAAM,CAAC,CAAD,CAAN,IAAa,CAAf,CAArD;AACA,SAAO,GAAG,GAAG,CAAN,GAAU,GAAV,GAAgB,CAAvB;AACD;AAED;;;;;;AAMG;;;AACH,OAAM,SAAU,YAAV,CAAuB,IAAvB,EAAqC,IAArC,EAAiD;AACrD,MAAM,UAAU,GAAG,WAAW,CAAC,IAAD,CAA9B;AACA,MAAM,UAAU,GAAG,WAAW,CAAC,IAAD,CAA9B;AACA,MAAM,OAAO,GAAG,IAAA,CAAA,GAAA,CAAA,EAAA,EAAM,IAAI,CAAC,GAAL,CAAS,UAAT,EAAqB,UAArB,CAAN,CAAhB;AACA,SAAO,CAAC,IAAI,GAAG,OAAP,GAAiB,IAAI,GAAG,OAAzB,IAAoC,OAA3C;AACD","sourceRoot":"","sourcesContent":["import { each, isNil } from '@antv/util';\n// 求以a为次幂，结果为b的基数，如 x^^a = b;求x\n// 虽然数学上 b 不支持负数，但是这里需要支持 负数\nexport function calBase(a, b) {\n    var e = Math.E;\n    var value;\n    if (b >= 0) {\n        value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底\n    }\n    else {\n        value = Math.pow(e, Math.log(-b) / a) * -1; // 使用换底公式求底\n    }\n    return value;\n}\nexport function log(a, b) {\n    if (a === 1) {\n        return 1;\n    }\n    return Math.log(b) / Math.log(a);\n}\nexport function getLogPositiveMin(values, base, max) {\n    if (isNil(max)) {\n        max = Math.max.apply(null, values);\n    }\n    var positiveMin = max;\n    each(values, function (value) {\n        if (value > 0 && value < positiveMin) {\n            positiveMin = value;\n        }\n    });\n    if (positiveMin === max) {\n        positiveMin = max / base;\n    }\n    if (positiveMin > 1) {\n        positiveMin = 1;\n    }\n    return positiveMin;\n}\nfunction digitLength(num) {\n    // Get digit length of e\n    var eSplit = num.toString().split(/[eE]/);\n    var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);\n    return len > 0 ? len : 0;\n}\n/**\n * 高精度加法，解决 0.1 + 0.2 !== 0.3 的经典问题\n *\n * @param num1 加数\n * @param num2 被加数\n * @return {number} 返回值\n */\nexport function precisionAdd(num1, num2) {\n    var num1Digits = digitLength(num1);\n    var num2Digits = digitLength(num2);\n    var baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n    return (num1 * baseNum + num2 * baseNum) / baseNum;\n}\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"module"}