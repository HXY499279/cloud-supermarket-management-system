{"ast":null,"code":"import { isArray, isNil, get } from '@antv/util';\nimport { getAngle, getSectorPath } from '../../../util/graphics';\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @param [isPyramid] 是否为尖底漏斗图\n * @returns rect points 返回矩形四个顶点信息\n */\n\nexport function getRectPoints(pointInfo, isPyramid) {\n  if (isPyramid === void 0) {\n    isPyramid = false;\n  }\n\n  var x = pointInfo.x,\n      y = pointInfo.y,\n      y0 = pointInfo.y0,\n      size = pointInfo.size; // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n\n  var yMin;\n  var yMax;\n\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  var xMin;\n  var xMax;\n\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }];\n\n  if (isPyramid) {\n    // 绘制尖底漏斗图\n    // 金字塔漏斗图的关键点\n    // 1\n    // |   2\n    // 0\n    points.push({\n      x: xMax,\n      y: (yMax + yMin) / 2\n    });\n  } else {\n    // 矩形的四个关键点，结构如下（左下角顺时针连接）\n    // 1 ---- 2\n    // |      |\n    // 0 ---- 3\n    points.push({\n      x: xMax,\n      y: yMax\n    }, {\n      x: xMax,\n      y: yMin\n    });\n  }\n\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\n\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  } // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n\n\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n\n    path.push(['z']);\n  }\n\n  return path;\n}\n/**\n * 处理 rect path 的 radius\n * @returns 返回矩形 path 的四个角的 arc 半径\n */\n\nexport function parseRadius(radius, minLength) {\n  var r1 = 0;\n  var r2 = 0;\n  var r3 = 0;\n  var r4 = 0;\n\n  if (isArray(radius)) {\n    if (radius.length === 1) {\n      r1 = r2 = r3 = r4 = radius[0];\n    } else if (radius.length === 2) {\n      r1 = r3 = radius[0];\n      r2 = r4 = radius[1];\n    } else if (radius.length === 3) {\n      r1 = radius[0];\n      r2 = r4 = radius[1];\n      r3 = radius[2];\n    } else {\n      r1 = radius[0];\n      r2 = radius[1];\n      r3 = radius[2];\n      r4 = radius[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = radius;\n  } // 处理 边界值\n\n\n  if (r1 + r2 > minLength) {\n    r1 = r1 ? minLength / (1 + r2 / r1) : 0;\n    r2 = minLength - r1;\n  }\n\n  if (r3 + r4 > minLength) {\n    r3 = r3 ? minLength / (1 + r4 / r3) : 0;\n    r4 = minLength - r3;\n  }\n\n  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];\n}\n/**\n * 获取 interval 矩形背景的 path\n * @param cfg 关键点的信息\n * @param points 已转化为画布坐标的 4 个关键点\n * @param coordinate 坐标系\n * @returns 返回矩形背景的 path\n */\n\nexport function getBackgroundRectPath(cfg, points, coordinate) {\n  var path = [];\n\n  if (coordinate.isRect) {\n    var p0 = coordinate.isTransposed ? {\n      x: coordinate.start.x,\n      y: points[0].y\n    } : {\n      x: points[0].x,\n      y: coordinate.start.y\n    };\n    var p1 = coordinate.isTransposed ? {\n      x: coordinate.end.x,\n      y: points[2].y\n    } : {\n      x: points[3].x,\n      y: coordinate.end.y\n    }; // corner radius of background shape works only in 笛卡尔坐标系\n\n    var radius = get(cfg, ['background', 'style', 'radius']);\n\n    if (radius) {\n      var width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;\n      var height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();\n\n      var _a = parseRadius(radius, Math.min(width, height)),\n          r1 = _a[0],\n          r2 = _a[1],\n          r3 = _a[2],\n          r4 = _a[3];\n\n      path.push(['M', p0.x, p1.y + r1]);\n      r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p0.x + r1, p1.y]);\n      path.push(['L', p1.x - r2, p1.y]);\n      r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p1.x, p1.y + r2]);\n      path.push(['L', p1.x, p0.y - r3]);\n      r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p1.x - r3, p0.y]);\n      path.push(['L', p0.x + r4, p0.y]);\n      r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);\n    } else {\n      path.push(['M', p0.x, p0.y]);\n      path.push(['L', p1.x, p0.y]);\n      path.push(['L', p1.x, p1.y]);\n      path.push(['L', p0.x, p1.y]);\n      path.push(['L', p0.x, p0.y]);\n    }\n\n    path.push(['z']);\n  }\n\n  if (coordinate.isPolar) {\n    var center = coordinate.getCenter();\n\n    var _b = getAngle(cfg, coordinate),\n        startAngle = _b.startAngle,\n        endAngle = _b.endAngle;\n\n    if (coordinate.type !== 'theta' && !coordinate.isTransposed) {\n      // 获取扇形 path\n      path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);\n    } else {\n      var pow = function (v) {\n        return Math.pow(v, 2);\n      };\n\n      var r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));\n      var r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y)); // 获取扇形 path（其实是一个圆环，从 coordinate 的起始角度到结束角度）\n\n      path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);\n    }\n  }\n\n  return path;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param lineCap 'round'圆角样式\n * @param coor 坐标\n * @returns 返回矩形的 path\n */\n\nexport function getIntervalRectPath(points, lineCap, coor) {\n  var width = coor.getWidth();\n  var height = coor.getHeight();\n  var isRect = coor.type === 'rect';\n  var path = [];\n  var r = (points[2].x - points[1].x) / 2;\n  var ry = coor.isTransposed ? r * height / width : r * width / height;\n\n  if (lineCap === 'round') {\n    if (isRect) {\n      path.push(['M', points[0].x, points[0].y + ry]);\n      path.push(['L', points[1].x, points[1].y - ry]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y - ry]);\n      path.push(['L', points[3].x, points[3].y + ry]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y + ry]);\n    } else {\n      path.push(['M', points[0].x, points[0].y]);\n      path.push(['L', points[1].x, points[1].y]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y]);\n      path.push(['L', points[3].x, points[3].y]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y]);\n    }\n\n    path.push(['z']);\n  } else {\n    path = getRectPath(points);\n  }\n\n  return path;\n}\n/**\n * @ignore\n * 根据 funnel 关键点绘制漏斗图的 path\n * @param points 图形关键点信息\n * @param nextPoints 下一个数据的图形关键点信息\n * @param isPyramid 是否为尖底漏斗图\n * @returns 返回漏斗图的图形 path\n */\n\nexport function getFunnelPath(points, nextPoints, isPyramid) {\n  var path = [];\n\n  if (!isNil(nextPoints)) {\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);\n  } else if (isPyramid) {\n    // 金字塔最底部\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[2].x, points[2].y], ['Z']);\n  } else {\n    // 漏斗图最底部\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);\n  }\n\n  return path;\n}\n/**\n * 获取 倒角 矩形\n * - 目前只适用于笛卡尔坐标系下\n */\n\nexport function getRectWithCornerRadius(points, coordinate, radius) {\n  var _a, _b, _c, _d; // 获取 四个关键点\n\n\n  var p0 = points[0],\n      p1 = points[1],\n      p2 = points[2],\n      p3 = points[3];\n  var _e = [0, 0, 0, 0],\n      r1 = _e[0],\n      r2 = _e[1],\n      r3 = _e[2],\n      r4 = _e[3];\n  /**\n   *  p1 → p2\n   *  ↑    ↓\n   *  p0 ← p3\n   *\n   *  负数的情况，关键点会变成下面的形式\n   *\n   *  p0 ← p3\n   *  ↓    ↑\n   *  p1 → p2\n   */\n\n  if (p0.y < p1.y\n  /** 负数情况 */\n  ) {\n      p1 = points[0], p0 = points[1], p3 = points[2], p2 = points[3];\n      _a = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r4 = _a[0], r3 = _a[1], r2 = _a[2], r1 = _a[3];\n    } else {\n    _b = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _b[0], r2 = _b[1], r3 = _b[2], r4 = _b[3];\n  }\n  /**\n   * 转置前\n   *  p1 → p2\n   *  ↑    ↓\n   *  p0 ← p3\n   *\n   * 转置后(↓ 是 x 轴递增，→ 是 y 轴递增)，从 p0 开始绘制，对应的 radius: [r3, r2, r1, r4]\n   * p3 ← p2\n   * ↓    ↑\n   * P0 → p1（points[3]）\n   *\n   *  负数的情况，y 轴翻转\n   *\n   *  p0 → p1\n   *  ↑    ↓\n   *  p3 ← p2\n   */\n\n\n  if (coordinate.isTransposed) {\n    p0 = points[0], p3 = points[1], p2 = points[2], p1 = points[3];\n\n    if (points[0].x > points[1].x\n    /** 负数情况 */\n    ) {\n        p3 = points[0], p0 = points[1], p1 = points[2], p2 = points[3];\n        _c = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _c[0], r4 = _c[1], r3 = _c[2], r2 = _c[3];\n      } else {\n      _d = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r2 = _d[0], r3 = _d[1], r4 = _d[2], r1 = _d[3];\n    }\n  }\n\n  var path = [];\n  path.push(['M', p1.x, p1.y + r1]);\n  r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p1.x + r1, p1.y]);\n  path.push(['L', p2.x - r2, p2.y]);\n  r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p2.x, p2.y + r2]);\n  path.push(['L', p3.x, p3.y - r3]);\n  r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p3.x - r3, p3.y]);\n  path.push(['L', p0.x + r4, p0.y]);\n  r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);\n  path.push(['L', p1.x, p1.y + r1]);\n  path.push(['z']);\n  return path;\n}","map":{"version":3,"sources":["../../../../src/geometry/shape/interval/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { isArray, isNil, get } from '@antv/util';\nimport { getAngle, getSectorPath } from '../../../util/graphics';\nimport { PathCommand } from '../../../dependents';\nimport { Point, ShapeInfo, ShapePoint } from '../../../interface';\n\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @param [isPyramid] 是否为尖底漏斗图\n * @returns rect points 返回矩形四个顶点信息\n */\nexport function getRectPoints(pointInfo: ShapePoint, isPyramid = false): Point[] {\n  const { x, y, y0, size } = pointInfo;\n  // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n  let yMin;\n  let yMax;\n  if (isArray(y)) {\n    [yMin, yMax] = y;\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  let xMin;\n  let xMax;\n  if (isArray(x)) {\n    [xMin, xMax] = x;\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  const points = [\n    { x: xMin, y: yMin },\n    { x: xMin, y: yMax },\n  ];\n\n  if (isPyramid) {\n    // 绘制尖底漏斗图\n    // 金字塔漏斗图的关键点\n    // 1\n    // |   2\n    // 0\n    points.push({\n      x: xMax,\n      y: (yMax + yMin) / 2,\n    });\n  } else {\n    // 矩形的四个关键点，结构如下（左下角顺时针连接）\n    // 1 ---- 2\n    // |      |\n    // 0 ---- 3\n    points.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });\n  }\n\n  return points;\n}\n\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\nexport function getRectPath(points: Point[], isClosed: boolean = true): PathCommand[] {\n  const path = [];\n  const firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n  for (let i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  }\n  // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n    path.push(['z']);\n  }\n  return path;\n}\n\n/**\n * 处理 rect path 的 radius\n * @returns 返回矩形 path 的四个角的 arc 半径\n */\nexport function parseRadius(radius: number | number[], minLength: number): number[] {\n  let r1 = 0;\n  let r2 = 0;\n  let r3 = 0;\n  let r4 = 0;\n  if (isArray(radius)) {\n    if (radius.length === 1) {\n      r1 = r2 = r3 = r4 = radius[0];\n    } else if (radius.length === 2) {\n      r1 = r3 = radius[0];\n      r2 = r4 = radius[1];\n    } else if (radius.length === 3) {\n      r1 = radius[0];\n      r2 = r4 = radius[1];\n      r3 = radius[2];\n    } else {\n      r1 = radius[0];\n      r2 = radius[1];\n      r3 = radius[2];\n      r4 = radius[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = radius;\n  }\n\n  // 处理 边界值\n  if (r1 + r2 > minLength) {\n    r1 = r1 ? minLength / (1 + r2 / r1) : 0;\n    r2 = minLength - r1;\n  }\n\n  if (r3 + r4 > minLength) {\n    r3 = r3 ? minLength / (1 + r4 / r3) : 0;\n    r4 = minLength - r3;\n  }\n\n  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];\n}\n\n/**\n * 获取 interval 矩形背景的 path\n * @param cfg 关键点的信息\n * @param points 已转化为画布坐标的 4 个关键点\n * @param coordinate 坐标系\n * @returns 返回矩形背景的 path\n */\nexport function getBackgroundRectPath(cfg: ShapeInfo, points: Point[], coordinate: Coordinate): PathCommand[] {\n  let path = [];\n  if (coordinate.isRect) {\n    const p0 = coordinate.isTransposed\n      ? { x: coordinate.start.x, y: points[0].y }\n      : { x: points[0].x, y: coordinate.start.y };\n    const p1 = coordinate.isTransposed\n      ? { x: coordinate.end.x, y: points[2].y }\n      : { x: points[3].x, y: coordinate.end.y };\n\n    // corner radius of background shape works only in 笛卡尔坐标系\n    const radius = get(cfg, ['background', 'style', 'radius']);\n    if (radius) {\n      const width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;\n      const height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();\n      const [r1, r2, r3, r4] = parseRadius(radius, Math.min(width, height));\n\n      path.push(['M', p0.x, p1.y + r1]);\n      r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p0.x + r1, p1.y]);\n      path.push(['L', p1.x - r2, p1.y]);\n      r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p1.x, p1.y + r2]);\n      path.push(['L', p1.x, p0.y - r3]);\n      r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p1.x - r3, p0.y]);\n      path.push(['L', p0.x + r4, p0.y]);\n      r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);\n    } else {\n      path.push(['M', p0.x, p0.y]);\n      path.push(['L', p1.x, p0.y]);\n      path.push(['L', p1.x, p1.y]);\n      path.push(['L', p0.x, p1.y]);\n      path.push(['L', p0.x, p0.y]);\n    }\n\n    path.push(['z']);\n  }\n\n  if (coordinate.isPolar) {\n    const center = coordinate.getCenter();\n    const { startAngle, endAngle } = getAngle(cfg, coordinate);\n    if (coordinate.type !== 'theta' && !coordinate.isTransposed) {\n      // 获取扇形 path\n      path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);\n    } else {\n      const pow = (v) => Math.pow(v, 2);\n      const r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));\n      const r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y));\n      // 获取扇形 path（其实是一个圆环，从 coordinate 的起始角度到结束角度）\n      path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);\n    }\n  }\n  return path;\n}\n\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param lineCap 'round'圆角样式\n * @param coor 坐标\n * @returns 返回矩形的 path\n */\nexport function getIntervalRectPath(points: Point[], lineCap: CanvasLineCap, coor: Coordinate): PathCommand[] {\n  const width = coor.getWidth();\n  const height = coor.getHeight();\n  const isRect = coor.type === 'rect';\n  let path = [];\n  const r = (points[2].x - points[1].x) / 2;\n  const ry = coor.isTransposed ? (r * height) / width : (r * width) / height;\n  if (lineCap === 'round') {\n    if (isRect) {\n      path.push(['M', points[0].x, points[0].y + ry]);\n      path.push(['L', points[1].x, points[1].y - ry]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y - ry]);\n      path.push(['L', points[3].x, points[3].y + ry]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y + ry]);\n    } else {\n      path.push(['M', points[0].x, points[0].y]);\n      path.push(['L', points[1].x, points[1].y]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y]);\n      path.push(['L', points[3].x, points[3].y]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y]);\n    }\n    path.push(['z']);\n  } else {\n    path = getRectPath(points);\n  }\n  return path;\n}\n\n/**\n * @ignore\n * 根据 funnel 关键点绘制漏斗图的 path\n * @param points 图形关键点信息\n * @param nextPoints 下一个数据的图形关键点信息\n * @param isPyramid 是否为尖底漏斗图\n * @returns 返回漏斗图的图形 path\n */\nexport function getFunnelPath(points: Point[], nextPoints: Point[], isPyramid: boolean) {\n  const path = [];\n  if (!isNil(nextPoints)) {\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', nextPoints[1].x, nextPoints[1].y],\n      ['L', nextPoints[0].x, nextPoints[0].y],\n      ['Z']\n    );\n  } else if (isPyramid) {\n    // 金字塔最底部\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', points[2].x, points[2].y],\n      ['L', points[2].x, points[2].y],\n      ['Z']\n    );\n  } else {\n    // 漏斗图最底部\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', points[2].x, points[2].y],\n      ['L', points[3].x, points[3].y],\n      ['Z']\n    );\n  }\n\n  return path;\n}\n\n/**\n * 获取 倒角 矩形\n * - 目前只适用于笛卡尔坐标系下\n */\nexport function getRectWithCornerRadius(points: Point[], coordinate: Coordinate, radius?: number | number[]) {\n  // 获取 四个关键点\n  let [p0, p1, p2, p3] = points;\n  let [r1, r2, r3, r4] = [0, 0, 0, 0];\n\n  /**\n   *  p1 → p2\n   *  ↑    ↓\n   *  p0 ← p3\n   *\n   *  负数的情况，关键点会变成下面的形式\n   *\n   *  p0 ← p3\n   *  ↓    ↑\n   *  p1 → p2\n   */\n  if (p0.y < p1.y /** 负数情况 */) {\n    [p1, p0, p3, p2] = points;\n    [r4, r3, r2, r1] = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y));\n  } else {\n    [r1, r2, r3, r4] = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y));\n  }\n\n  /**\n   * 转置前\n   *  p1 → p2\n   *  ↑    ↓\n   *  p0 ← p3\n   *\n   * 转置后(↓ 是 x 轴递增，→ 是 y 轴递增)，从 p0 开始绘制，对应的 radius: [r3, r2, r1, r4]\n   * p3 ← p2\n   * ↓    ↑\n   * P0 → p1（points[3]）\n   *\n   *  负数的情况，y 轴翻转\n   *\n   *  p0 → p1\n   *  ↑    ↓\n   *  p3 ← p2\n   */\n  if (coordinate.isTransposed) {\n    [p0, p3, p2, p1] = points;\n    if (points[0].x > points[1].x /** 负数情况 */) {\n      [p3, p0, p1, p2] = points;\n      [r1, r4, r3, r2] = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y));\n    } else {\n      [r2, r3, r4, r1] = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y));\n    }\n  }\n\n  const path = [];\n  path.push(['M', p1.x, p1.y + r1]);\n  r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p1.x + r1, p1.y]);\n  path.push(['L', p2.x - r2, p2.y]);\n  r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p2.x, p2.y + r2]);\n  path.push(['L', p3.x, p3.y - r3]);\n  r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p3.x - r3, p3.y]);\n  path.push(['L', p0.x + r4, p0.y]);\n  r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);\n  path.push(['L', p1.x, p1.y + r1]);\n  path.push(['z']);\n\n  return path;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}