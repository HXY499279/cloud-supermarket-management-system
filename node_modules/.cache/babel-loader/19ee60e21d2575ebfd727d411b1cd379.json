{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\n\nvar Symmetric =\n/** @class */\nfunction (_super) {\n  __extends(Symmetric, _super);\n\n  function Symmetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Symmetric.prototype.process = function (groupDataArray) {\n    var mergeData = _.flatten(groupDataArray);\n\n    var _a = this,\n        xField = _a.xField,\n        yField = _a.yField; // 每个 x 值对应的 最大值\n\n\n    var cache = this.getXValuesMaxMap(mergeData); // 所有数据的最大的值\n\n    var max = Math.max.apply(Math, Object.keys(cache).map(function (key) {\n      return cache[key];\n    }));\n    return _.map(groupDataArray, function (dataArray) {\n      return _.map(dataArray, function (data) {\n        var _a, _b;\n\n        var yValue = data[yField];\n        var xValue = data[xField]; // 数组处理逻辑\n\n        if (_.isArray(yValue)) {\n          var off_1 = (max - cache[xValue]) / 2;\n          return __assign(__assign({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) {\n            return off_1 + y;\n          }), _a));\n        } // 非数组处理逻辑\n\n\n        var offset = (max - yValue) / 2;\n        return __assign(__assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));\n      });\n    });\n  }; // 获取每个 x 对应的最大的值\n\n\n  Symmetric.prototype.getXValuesMaxMap = function (mergeData) {\n    var _this = this;\n\n    var _a = this,\n        xField = _a.xField,\n        yField = _a.yField; // 根据 xField 的值进行分组\n\n\n    var groupDataArray = _.groupBy(mergeData, function (data) {\n      return data[xField];\n    }); // 获取每个 xField 值中的最大值\n\n\n    return _.mapValues(groupDataArray, function (dataArray) {\n      return _this.getDimMaxValue(dataArray, yField);\n    });\n  };\n\n  Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {\n    // 所有的 value 值\n    var dimValues = _.map(mergeData, function (data) {\n      return _.get(data, dim, []);\n    }); // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n\n\n    var flattenValues = _.flatten(dimValues); // 求出数组的最大值\n\n\n    return Math.max.apply(Math, flattenValues);\n  };\n\n  return Symmetric;\n}(Adjust);\n\nexport default Symmetric;","map":{"version":3,"sources":["../../src/adjusts/symmetric.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\nvar Symmetric = /** @class */ (function (_super) {\n    __extends(Symmetric, _super);\n    function Symmetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Symmetric.prototype.process = function (groupDataArray) {\n        var mergeData = _.flatten(groupDataArray);\n        var _a = this, xField = _a.xField, yField = _a.yField;\n        // 每个 x 值对应的 最大值\n        var cache = this.getXValuesMaxMap(mergeData);\n        // 所有数据的最大的值\n        var max = Math.max.apply(Math, Object.keys(cache).map(function (key) { return cache[key]; }));\n        return _.map(groupDataArray, function (dataArray) {\n            return _.map(dataArray, function (data) {\n                var _a, _b;\n                var yValue = data[yField];\n                var xValue = data[xField];\n                // 数组处理逻辑\n                if (_.isArray(yValue)) {\n                    var off_1 = (max - cache[xValue]) / 2;\n                    return __assign(__assign({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) { return off_1 + y; }), _a));\n                }\n                // 非数组处理逻辑\n                var offset = (max - yValue) / 2;\n                return __assign(__assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));\n            });\n        });\n    };\n    // 获取每个 x 对应的最大的值\n    Symmetric.prototype.getXValuesMaxMap = function (mergeData) {\n        var _this = this;\n        var _a = this, xField = _a.xField, yField = _a.yField;\n        // 根据 xField 的值进行分组\n        var groupDataArray = _.groupBy(mergeData, function (data) { return data[xField]; });\n        // 获取每个 xField 值中的最大值\n        return _.mapValues(groupDataArray, function (dataArray) { return _this.getDimMaxValue(dataArray, yField); });\n    };\n    Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {\n        // 所有的 value 值\n        var dimValues = _.map(mergeData, function (data) { return _.get(data, dim, []); });\n        // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n        var flattenValues = _.flatten(dimValues);\n        // 求出数组的最大值\n        return Math.max.apply(Math, flattenValues);\n    };\n    return Symmetric;\n}(Adjust));\nexport default Symmetric;\n//# sourceMappingURL=symmetric.js.map"]},"metadata":{},"sourceType":"module"}