{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { each, isEqual, isFunction, isNumber, isObject, isArray, noop, mix, upperFirst, uniqueId } from '@antv/util';\nimport { ext } from '@antv/matrix-util';\nimport { removeFromArray, isParent } from '../util/util';\nimport { multiplyMatrix, multiplyVec2, invert } from '../util/matrix';\nimport Base from './base';\nvar transform = ext.transform;\nvar MATRIX = 'matrix';\nvar CLONE_CFGS = ['zIndex', 'capture', 'visible', 'type']; // 可以在 toAttrs 中设置，但不属于绘图属性的字段\n\nvar RESERVED_PORPS = ['repeat'];\nvar DELEGATION_SPLIT = ':';\nvar WILDCARD = '*'; // 需要考虑数组嵌套数组的场景\n// 数组嵌套对象的场景不考虑\n\nfunction _cloneArrayAttr(arr) {\n  var result = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (isArray(arr[i])) {\n      result.push([].concat(arr[i]));\n    } else {\n      result.push(arr[i]);\n    }\n  }\n\n  return result;\n}\n\nfunction getFormatFromAttrs(toAttrs, shape) {\n  var fromAttrs = {};\n  var attrs = shape.attrs;\n\n  for (var k in toAttrs) {\n    fromAttrs[k] = attrs[k];\n  }\n\n  return fromAttrs;\n}\n\nfunction getFormatToAttrs(props, shape) {\n  var toAttrs = {};\n  var attrs = shape.attr();\n  each(props, function (v, k) {\n    if (RESERVED_PORPS.indexOf(k) === -1 && !isEqual(attrs[k], v)) {\n      toAttrs[k] = v;\n    }\n  });\n  return toAttrs;\n}\n\nfunction checkExistedAttrs(animations, animation) {\n  if (animation.onFrame) {\n    return animations;\n  }\n\n  var startTime = animation.startTime,\n      delay = animation.delay,\n      duration = animation.duration;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  each(animations, function (item) {\n    // 后一个动画开始执行的时间 < 前一个动画的结束时间 && 后一个动画的执行时间 > 前一个动画的延迟\n    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {\n      each(animation.toAttrs, function (v, k) {\n        if (hasOwnProperty.call(item.toAttrs, k)) {\n          delete item.toAttrs[k];\n          delete item.fromAttrs[k];\n        }\n      });\n    }\n  });\n  return animations;\n}\n\nvar Element =\n/** @class */\nfunction (_super) {\n  __extends(Element, _super);\n\n  function Element(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /**\n     * @protected\n     * 图形属性\n     * @type {ShapeAttrs}\n     */\n\n\n    _this.attrs = {};\n\n    var attrs = _this.getDefaultAttrs();\n\n    mix(attrs, cfg.attrs);\n    _this.attrs = attrs;\n\n    _this.initAttrs(attrs);\n\n    _this.initAnimate(); // 初始化动画\n\n\n    return _this;\n  } // override\n\n\n  Element.prototype.getDefaultCfg = function () {\n    return {\n      visible: true,\n      capture: true,\n      zIndex: 0\n    };\n  };\n  /**\n   * @protected\n   * 获取默认的属相\n   */\n\n\n  Element.prototype.getDefaultAttrs = function () {\n    return {\n      matrix: this.getDefaultMatrix(),\n      opacity: 1\n    };\n  };\n  /**\n   * @protected\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n\n\n  Element.prototype.onCanvasChange = function (changeType) {};\n  /**\n   * @protected\n   * 初始化属性，有些属性需要加工\n   * @param {object} attrs 属性值\n   */\n\n\n  Element.prototype.initAttrs = function (attrs) {};\n  /**\n   * @protected\n   * 初始化动画\n   */\n\n\n  Element.prototype.initAnimate = function () {\n    this.set('animable', true);\n    this.set('animating', false);\n  };\n\n  Element.prototype.isGroup = function () {\n    return false;\n  };\n\n  Element.prototype.getParent = function () {\n    return this.get('parent');\n  };\n\n  Element.prototype.getCanvas = function () {\n    return this.get('canvas');\n  };\n\n  Element.prototype.attr = function () {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var name = args[0],\n        value = args[1];\n    if (!name) return this.attrs;\n\n    if (isObject(name)) {\n      for (var k in name) {\n        this.setAttr(k, name[k]);\n      }\n\n      this.afterAttrsChange(name);\n      return this;\n    }\n\n    if (args.length === 2) {\n      this.setAttr(name, value);\n      this.afterAttrsChange((_a = {}, _a[name] = value, _a));\n      return this;\n    }\n\n    return this.attrs[name];\n  }; // 是否被裁剪，被裁剪则不显示，不参与拾取\n\n\n  Element.prototype.isClipped = function (refX, refY) {\n    var clip = this.getClip();\n    return clip && !clip.isHit(refX, refY);\n  };\n  /**\n   * 内部设置属性值的接口\n   * @param {string} name 属性名\n   * @param {any} value 属性值\n   */\n\n\n  Element.prototype.setAttr = function (name, value) {\n    var originValue = this.attrs[name];\n\n    if (originValue !== value) {\n      this.attrs[name] = value;\n      this.onAttrChange(name, value, originValue);\n    }\n  };\n  /**\n   * @protected\n   * 属性值发生改变\n   * @param {string} name 属性名\n   * @param {any} value 属性值\n   * @param {any} originValue 属性值\n   */\n\n\n  Element.prototype.onAttrChange = function (name, value, originValue) {\n    if (name === 'matrix') {\n      this.set('totalMatrix', null);\n    }\n  };\n  /**\n   * 属性更改后需要做的事情\n   * @protected\n   */\n\n\n  Element.prototype.afterAttrsChange = function (targetAttrs) {\n    if (this.cfg.isClipShape) {\n      var applyTo = this.cfg.applyTo;\n\n      if (applyTo) {\n        applyTo.onCanvasChange('clip');\n      }\n    } else {\n      this.onCanvasChange('attr');\n    }\n  };\n\n  Element.prototype.show = function () {\n    // 不是高频操作直接使用 set\n    this.set('visible', true);\n    this.onCanvasChange('show');\n    return this;\n  };\n\n  Element.prototype.hide = function () {\n    // 不是高频操作直接使用 set\n    this.set('visible', false);\n    this.onCanvasChange('hide');\n    return this;\n  };\n\n  Element.prototype.setZIndex = function (zIndex) {\n    this.set('zIndex', zIndex);\n    var parent = this.getParent();\n\n    if (parent) {\n      // 改变 zIndex 不应该立即触发渲染 (调用 onCanvasChange('zIndex'))，需要经过 sort 再触发\n      parent.sort();\n    }\n\n    return this;\n  };\n\n  Element.prototype.toFront = function () {\n    var parent = this.getParent();\n\n    if (!parent) {\n      return;\n    }\n\n    var children = parent.getChildren();\n    var el = this.get('el');\n    var index = children.indexOf(this);\n    children.splice(index, 1);\n    children.push(this);\n    this.onCanvasChange('zIndex');\n  };\n\n  Element.prototype.toBack = function () {\n    var parent = this.getParent();\n\n    if (!parent) {\n      return;\n    }\n\n    var children = parent.getChildren();\n    var el = this.get('el');\n    var index = children.indexOf(this);\n    children.splice(index, 1);\n    children.unshift(this);\n    this.onCanvasChange('zIndex');\n  };\n\n  Element.prototype.remove = function (destroy) {\n    if (destroy === void 0) {\n      destroy = true;\n    }\n\n    var parent = this.getParent();\n\n    if (parent) {\n      removeFromArray(parent.getChildren(), this);\n\n      if (!parent.get('clearing')) {\n        // 如果父元素正在清理，当前元素不触发 remove\n        this.onCanvasChange('remove');\n      }\n    } else {\n      this.onCanvasChange('remove');\n    }\n\n    if (destroy) {\n      this.destroy();\n    }\n  };\n\n  Element.prototype.resetMatrix = function () {\n    this.attr(MATRIX, this.getDefaultMatrix());\n    this.onCanvasChange('matrix');\n  };\n\n  Element.prototype.getMatrix = function () {\n    return this.attr(MATRIX);\n  };\n\n  Element.prototype.setMatrix = function (m) {\n    this.attr(MATRIX, m);\n    this.onCanvasChange('matrix');\n  }; // 获取总的 matrix\n\n\n  Element.prototype.getTotalMatrix = function () {\n    var totalMatrix = this.cfg.totalMatrix;\n\n    if (!totalMatrix) {\n      var currentMatrix = this.attr('matrix');\n      var parentMatrix = this.cfg.parentMatrix;\n\n      if (parentMatrix && currentMatrix) {\n        totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);\n      } else {\n        totalMatrix = currentMatrix || parentMatrix;\n      }\n\n      this.set('totalMatrix', totalMatrix);\n    }\n\n    return totalMatrix;\n  }; // 上层分组设置 matrix\n\n\n  Element.prototype.applyMatrix = function (matrix) {\n    var currentMatrix = this.attr('matrix');\n    var totalMatrix = null;\n\n    if (matrix && currentMatrix) {\n      totalMatrix = multiplyMatrix(matrix, currentMatrix);\n    } else {\n      totalMatrix = currentMatrix || matrix;\n    }\n\n    this.set('totalMatrix', totalMatrix);\n    this.set('parentMatrix', matrix);\n  };\n  /**\n   * @protected\n   * 获取默认的矩阵\n   * @returns {number[]|null} 默认的矩阵\n   */\n\n\n  Element.prototype.getDefaultMatrix = function () {\n    return null;\n  }; // 将向量应用设置的矩阵\n\n\n  Element.prototype.applyToMatrix = function (v) {\n    var matrix = this.attr('matrix');\n\n    if (matrix) {\n      return multiplyVec2(matrix, v);\n    }\n\n    return v;\n  }; // 根据设置的矩阵，将向量转换相对于图形/分组的位置\n\n\n  Element.prototype.invertFromMatrix = function (v) {\n    var matrix = this.attr('matrix');\n\n    if (matrix) {\n      var invertMatrix = invert(matrix);\n\n      if (invertMatrix) {\n        return multiplyVec2(invertMatrix, v);\n      }\n    }\n\n    return v;\n  }; // 设置 clip\n\n\n  Element.prototype.setClip = function (clipCfg) {\n    var canvas = this.getCanvas(); // 应该只设置当前元素的 clip，不应该去修改 clip 本身，方便 clip 被复用\n    // TODO: setClip 的传参既 shape 配置，也支持 shape 对象\n    // const preShape = this.get('clipShape');\n    // if (preShape) {\n    //   // 将之前的 clipShape 销毁\n    //   preShape.destroy();\n    // }\n\n    var clipShape = null; // 如果配置项为 null，则不移除 clipShape\n\n    if (clipCfg) {\n      var ShapeBase = this.getShapeBase();\n      var shapeType = upperFirst(clipCfg.type);\n      var Cons = ShapeBase[shapeType];\n\n      if (Cons) {\n        clipShape = new Cons({\n          type: clipCfg.type,\n          isClipShape: true,\n          applyTo: this,\n          attrs: clipCfg.attrs,\n          canvas: canvas\n        });\n      }\n    }\n\n    this.set('clipShape', clipShape);\n    this.onCanvasChange('clip');\n    return clipShape;\n  };\n\n  Element.prototype.getClip = function () {\n    // 高频率调用的地方直接使用 this.cfg.xxx\n    var clipShape = this.cfg.clipShape; // 未设置时返回 Null，保证一致性\n\n    if (!clipShape) {\n      return null;\n    }\n\n    return clipShape;\n  };\n\n  Element.prototype.clone = function () {\n    var _this = this;\n\n    var originAttrs = this.attrs;\n    var attrs = {};\n    each(originAttrs, function (i, k) {\n      if (isArray(originAttrs[k])) {\n        attrs[k] = _cloneArrayAttr(originAttrs[k]);\n      } else {\n        attrs[k] = originAttrs[k];\n      }\n    });\n    var cons = this.constructor; // @ts-ignore\n\n    var clone = new cons({\n      attrs: attrs\n    });\n    each(CLONE_CFGS, function (cfgName) {\n      clone.set(cfgName, _this.get(cfgName));\n    });\n    return clone;\n  };\n\n  Element.prototype.destroy = function () {\n    var destroyed = this.destroyed;\n\n    if (destroyed) {\n      return;\n    }\n\n    this.attrs = {};\n\n    _super.prototype.destroy.call(this); // this.onCanvasChange('destroy');\n\n  };\n  /**\n   * 是否处于动画暂停状态\n   * @return {boolean} 是否处于动画暂停状态\n   */\n\n\n  Element.prototype.isAnimatePaused = function () {\n    return this.get('_pause').isPaused;\n  };\n  /**\n   * 执行动画，支持多种函数签名\n   * 1. animate(toAttrs: ElementAttrs, duration: number, easing?: string, callback?: () => void, delay?: number)\n   * 2. animate(onFrame: OnFrame, duration: number, easing?: string, callback?: () => void, delay?: number)\n   * 3. animate(toAttrs: ElementAttrs, cfg: AnimateCfg)\n   * 4. animate(onFrame: OnFrame, cfg: AnimateCfg)\n   * 各个参数的含义为:\n   *   toAttrs  动画最终状态\n   *   onFrame  自定义帧动画函数\n   *   duration 动画执行时间\n   *   easing   动画缓动效果\n   *   callback 动画执行后的回调\n   *   delay    动画延迟时间\n   */\n\n\n  Element.prototype.animate = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (!this.get('timeline') && !this.get('canvas')) {\n      return;\n    }\n\n    this.set('animating', true);\n    var timeline = this.get('timeline');\n\n    if (!timeline) {\n      timeline = this.get('canvas').get('timeline');\n      this.set('timeline', timeline);\n    }\n\n    var animations = this.get('animations') || []; // 初始化 tick\n\n    if (!timeline.timer) {\n      timeline.initTimer();\n    }\n\n    var toAttrs = args[0],\n        duration = args[1],\n        _a = args[2],\n        easing = _a === void 0 ? 'easeLinear' : _a,\n        _b = args[3],\n        callback = _b === void 0 ? noop : _b,\n        _c = args[4],\n        delay = _c === void 0 ? 0 : _c;\n    var onFrame;\n    var repeat;\n    var pauseCallback;\n    var resumeCallback;\n    var animateCfg; // 第二个参数，既可以是动画最终状态 toAttrs，也可以是自定义帧动画函数 onFrame\n\n    if (isFunction(toAttrs)) {\n      onFrame = toAttrs;\n      toAttrs = {};\n    } else if (isObject(toAttrs) && toAttrs.onFrame) {\n      // 兼容 3.0 中的写法，onFrame 和 repeat 可在 toAttrs 中设置\n      onFrame = toAttrs.onFrame;\n      repeat = toAttrs.repeat;\n    } // 第二个参数，既可以是执行时间 duration，也可以是动画参数 animateCfg\n\n\n    if (isObject(duration)) {\n      animateCfg = duration;\n      duration = animateCfg.duration;\n      easing = animateCfg.easing || 'easeLinear';\n      delay = animateCfg.delay || 0; // animateCfg 中的设置优先级更高\n\n      repeat = animateCfg.repeat || repeat || false;\n      callback = animateCfg.callback || noop;\n      pauseCallback = animateCfg.pauseCallback || noop;\n      resumeCallback = animateCfg.resumeCallback || noop;\n    } else {\n      // 第四个参数，既可以是回调函数 callback，也可以是延迟时间 delay\n      if (isNumber(callback)) {\n        delay = callback;\n        callback = null;\n      } // 第三个参数，既可以是缓动参数 easing，也可以是回调函数 callback\n\n\n      if (isFunction(easing)) {\n        callback = easing;\n        easing = 'easeLinear';\n      } else {\n        easing = easing || 'easeLinear';\n      }\n    }\n\n    var formatToAttrs = getFormatToAttrs(toAttrs, this);\n    var animation = {\n      fromAttrs: getFormatFromAttrs(formatToAttrs, this),\n      toAttrs: formatToAttrs,\n      duration: duration,\n      easing: easing,\n      repeat: repeat,\n      callback: callback,\n      pauseCallback: pauseCallback,\n      resumeCallback: resumeCallback,\n      delay: delay,\n      startTime: timeline.getTime(),\n      id: uniqueId(),\n      onFrame: onFrame,\n      pathFormatted: false\n    }; // 如果动画元素队列中已经有这个图形了\n\n    if (animations.length > 0) {\n      // 先检查是否需要合并属性。若有相同的动画，将该属性从前一个动画中删除,直接用后一个动画中\n      animations = checkExistedAttrs(animations, animation);\n    } else {\n      // 否则将图形添加到动画元素队列\n      timeline.addAnimator(this);\n    }\n\n    animations.push(animation);\n    this.set('animations', animations);\n    this.set('_pause', {\n      isPaused: false\n    });\n  };\n  /**\n   * 停止动画\n   * @param {boolean} toEnd 是否到动画的最终状态\n   */\n\n\n  Element.prototype.stopAnimate = function (toEnd) {\n    var _this = this;\n\n    if (toEnd === void 0) {\n      toEnd = true;\n    }\n\n    var animations = this.get('animations');\n    each(animations, function (animation) {\n      // 将动画执行到最后一帧\n      if (toEnd) {\n        if (animation.onFrame) {\n          _this.attr(animation.onFrame(1));\n        } else {\n          _this.attr(animation.toAttrs);\n        }\n      }\n\n      if (animation.callback) {\n        // 动画停止时的回调\n        animation.callback();\n      }\n    });\n    this.set('animating', false);\n    this.set('animations', []);\n  };\n  /**\n   * 暂停动画\n   */\n\n\n  Element.prototype.pauseAnimate = function () {\n    var timeline = this.get('timeline');\n    var animations = this.get('animations');\n    var pauseTime = timeline.getTime();\n    each(animations, function (animation) {\n      animation._paused = true;\n      animation._pauseTime = pauseTime;\n\n      if (animation.pauseCallback) {\n        // 动画暂停时的回调\n        animation.pauseCallback();\n      }\n    }); // 记录下是在什么时候暂停的\n\n    this.set('_pause', {\n      isPaused: true,\n      pauseTime: pauseTime\n    });\n    return this;\n  };\n  /**\n   * 恢复动画\n   */\n\n\n  Element.prototype.resumeAnimate = function () {\n    var timeline = this.get('timeline');\n    var current = timeline.getTime();\n    var animations = this.get('animations');\n    var pauseTime = this.get('_pause').pauseTime; // 之后更新属性需要计算动画已经执行的时长，如果暂停了，就把初始时间调后\n\n    each(animations, function (animation) {\n      animation.startTime = animation.startTime + (current - pauseTime);\n      animation._paused = false;\n      animation._pauseTime = null;\n\n      if (animation.resumeCallback) {\n        animation.resumeCallback();\n      }\n    });\n    this.set('_pause', {\n      isPaused: false\n    });\n    this.set('animations', animations);\n    return this;\n  };\n  /**\n   * 触发委托事件\n   * @param  {string}     type 事件类型\n   * @param  {GraphEvent} eventObj 事件对象\n   */\n\n\n  Element.prototype.emitDelegation = function (type, eventObj) {\n    var _this = this;\n\n    var paths = eventObj.propagationPath;\n    var events = this.getEvents();\n    var relativeShape;\n\n    if (type === 'mouseenter') {\n      relativeShape = eventObj.fromShape;\n    } else if (type === 'mouseleave') {\n      relativeShape = eventObj.toShape;\n    }\n\n    var _loop_1 = function (i) {\n      var element = paths[i]; // 暂定跟 name 绑定\n\n      var name_1 = element.get('name');\n\n      if (name_1) {\n        // 第一个 mouseenter 和 mouseleave 的停止即可，因为后面的都是前面的 Parent\n        if ( // 只有 element 是 Group 或者 Canvas 的时候，才需要判断 isParent\n        (element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)) {\n          return \"break\";\n        }\n\n        if (isArray(name_1)) {\n          each(name_1, function (subName) {\n            _this.emitDelegateEvent(element, subName, eventObj);\n          });\n        } else {\n          this_1.emitDelegateEvent(element, name_1, eventObj);\n        }\n      }\n    };\n\n    var this_1 = this; // 至少有一个对象，且第一个对象为 shape\n\n    for (var i = 0; i < paths.length; i++) {\n      var state_1 = _loop_1(i);\n\n      if (state_1 === \"break\") break;\n    }\n  };\n\n  Element.prototype.emitDelegateEvent = function (element, name, eventObj) {\n    var events = this.getEvents(); // 事件委托的形式 name:type\n\n    var eventName = name + DELEGATION_SPLIT + eventObj.type;\n\n    if (events[eventName] || events[WILDCARD]) {\n      // 对于通配符 *，事件名称 = 委托事件名称\n      eventObj.name = eventName;\n      eventObj.currentTarget = element;\n      eventObj.delegateTarget = this; // 将委托事件的监听对象 delegateObject 挂载到事件对象上\n\n      eventObj.delegateObject = element.get('delegateObject');\n      this.emit(eventName, eventObj);\n    }\n  };\n  /**\n   * 移动元素\n   * @param {number} translateX 水平移动距离\n   * @param {number} translateY 垂直移动距离\n   * @return {IElement} 元素\n   */\n\n\n  Element.prototype.translate = function (translateX, translateY) {\n    if (translateX === void 0) {\n      translateX = 0;\n    }\n\n    if (translateY === void 0) {\n      translateY = 0;\n    }\n\n    var matrix = this.getMatrix();\n    var newMatrix = transform(matrix, [['t', translateX, translateY]]);\n    this.setMatrix(newMatrix);\n    return this;\n  };\n  /**\n   * 移动元素到目标位置\n   * @param {number} targetX 目标位置的水平坐标\n   * @param {number} targetX 目标位置的垂直坐标\n   * @return {IElement} 元素\n   */\n\n\n  Element.prototype.move = function (targetX, targetY) {\n    var x = this.attr('x') || 0;\n    var y = this.attr('y') || 0;\n    this.translate(targetX - x, targetY - y);\n    return this;\n  };\n  /**\n   * 移动元素到目标位置，等价于 move 方法。由于 moveTo 的语义性更强，因此在文档中推荐使用 moveTo 方法\n   * @param {number} targetX 目标位置的 x 轴坐标\n   * @param {number} targetY 目标位置的 y 轴坐标\n   * @return {IElement} 元素\n   */\n\n\n  Element.prototype.moveTo = function (targetX, targetY) {\n    return this.move(targetX, targetY);\n  };\n  /**\n   * 缩放元素\n   * @param {number} ratioX 水平缩放比例\n   * @param {number} ratioY 垂直缩放比例\n   * @return {IElement} 元素\n   */\n\n\n  Element.prototype.scale = function (ratioX, ratioY) {\n    var matrix = this.getMatrix();\n    var newMatrix = transform(matrix, [['s', ratioX, ratioY || ratioX]]);\n    this.setMatrix(newMatrix);\n    return this;\n  };\n  /**\n   * 以画布左上角 (0, 0) 为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n\n\n  Element.prototype.rotate = function (radian) {\n    var matrix = this.getMatrix();\n    var newMatrix = transform(matrix, [['r', radian]]);\n    this.setMatrix(newMatrix);\n    return this;\n  };\n  /**\n   * 以起始点为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n\n\n  Element.prototype.rotateAtStart = function (rotate) {\n    var _a = this.attr(),\n        x = _a.x,\n        y = _a.y;\n\n    var matrix = this.getMatrix();\n    var newMatrix = transform(matrix, [['t', -x, -y], ['r', rotate], ['t', x, y]]);\n    this.setMatrix(newMatrix);\n    return this;\n  };\n  /**\n   * 以任意点 (x, y) 为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n\n\n  Element.prototype.rotateAtPoint = function (x, y, rotate) {\n    var matrix = this.getMatrix();\n    var newMatrix = transform(matrix, [['t', -x, -y], ['r', rotate], ['t', x, y]]);\n    this.setMatrix(newMatrix);\n    return this;\n  };\n\n  return Element;\n}(Base);\n\nexport default Element;","map":{"version":3,"sources":["../../src/abstract/element.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { each, isEqual, isFunction, isNumber, isObject, isArray, noop, mix, upperFirst, uniqueId } from '@antv/util';\nimport { ext } from '@antv/matrix-util';\nimport { removeFromArray, isParent } from '../util/util';\nimport { multiplyMatrix, multiplyVec2, invert } from '../util/matrix';\nimport Base from './base';\nvar transform = ext.transform;\nvar MATRIX = 'matrix';\nvar CLONE_CFGS = ['zIndex', 'capture', 'visible', 'type'];\n// 可以在 toAttrs 中设置，但不属于绘图属性的字段\nvar RESERVED_PORPS = ['repeat'];\nvar DELEGATION_SPLIT = ':';\nvar WILDCARD = '*';\n// 需要考虑数组嵌套数组的场景\n// 数组嵌套对象的场景不考虑\nfunction _cloneArrayAttr(arr) {\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (isArray(arr[i])) {\n            result.push([].concat(arr[i]));\n        }\n        else {\n            result.push(arr[i]);\n        }\n    }\n    return result;\n}\nfunction getFormatFromAttrs(toAttrs, shape) {\n    var fromAttrs = {};\n    var attrs = shape.attrs;\n    for (var k in toAttrs) {\n        fromAttrs[k] = attrs[k];\n    }\n    return fromAttrs;\n}\nfunction getFormatToAttrs(props, shape) {\n    var toAttrs = {};\n    var attrs = shape.attr();\n    each(props, function (v, k) {\n        if (RESERVED_PORPS.indexOf(k) === -1 && !isEqual(attrs[k], v)) {\n            toAttrs[k] = v;\n        }\n    });\n    return toAttrs;\n}\nfunction checkExistedAttrs(animations, animation) {\n    if (animation.onFrame) {\n        return animations;\n    }\n    var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    each(animations, function (item) {\n        // 后一个动画开始执行的时间 < 前一个动画的结束时间 && 后一个动画的执行时间 > 前一个动画的延迟\n        if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {\n            each(animation.toAttrs, function (v, k) {\n                if (hasOwnProperty.call(item.toAttrs, k)) {\n                    delete item.toAttrs[k];\n                    delete item.fromAttrs[k];\n                }\n            });\n        }\n    });\n    return animations;\n}\nvar Element = /** @class */ (function (_super) {\n    __extends(Element, _super);\n    function Element(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        /**\n         * @protected\n         * 图形属性\n         * @type {ShapeAttrs}\n         */\n        _this.attrs = {};\n        var attrs = _this.getDefaultAttrs();\n        mix(attrs, cfg.attrs);\n        _this.attrs = attrs;\n        _this.initAttrs(attrs);\n        _this.initAnimate(); // 初始化动画\n        return _this;\n    }\n    // override\n    Element.prototype.getDefaultCfg = function () {\n        return {\n            visible: true,\n            capture: true,\n            zIndex: 0,\n        };\n    };\n    /**\n     * @protected\n     * 获取默认的属相\n     */\n    Element.prototype.getDefaultAttrs = function () {\n        return {\n            matrix: this.getDefaultMatrix(),\n            opacity: 1,\n        };\n    };\n    /**\n     * @protected\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    Element.prototype.onCanvasChange = function (changeType) { };\n    /**\n     * @protected\n     * 初始化属性，有些属性需要加工\n     * @param {object} attrs 属性值\n     */\n    Element.prototype.initAttrs = function (attrs) { };\n    /**\n     * @protected\n     * 初始化动画\n     */\n    Element.prototype.initAnimate = function () {\n        this.set('animable', true);\n        this.set('animating', false);\n    };\n    Element.prototype.isGroup = function () {\n        return false;\n    };\n    Element.prototype.getParent = function () {\n        return this.get('parent');\n    };\n    Element.prototype.getCanvas = function () {\n        return this.get('canvas');\n    };\n    Element.prototype.attr = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var name = args[0], value = args[1];\n        if (!name)\n            return this.attrs;\n        if (isObject(name)) {\n            for (var k in name) {\n                this.setAttr(k, name[k]);\n            }\n            this.afterAttrsChange(name);\n            return this;\n        }\n        if (args.length === 2) {\n            this.setAttr(name, value);\n            this.afterAttrsChange((_a = {},\n                _a[name] = value,\n                _a));\n            return this;\n        }\n        return this.attrs[name];\n    };\n    // 是否被裁剪，被裁剪则不显示，不参与拾取\n    Element.prototype.isClipped = function (refX, refY) {\n        var clip = this.getClip();\n        return clip && !clip.isHit(refX, refY);\n    };\n    /**\n     * 内部设置属性值的接口\n     * @param {string} name 属性名\n     * @param {any} value 属性值\n     */\n    Element.prototype.setAttr = function (name, value) {\n        var originValue = this.attrs[name];\n        if (originValue !== value) {\n            this.attrs[name] = value;\n            this.onAttrChange(name, value, originValue);\n        }\n    };\n    /**\n     * @protected\n     * 属性值发生改变\n     * @param {string} name 属性名\n     * @param {any} value 属性值\n     * @param {any} originValue 属性值\n     */\n    Element.prototype.onAttrChange = function (name, value, originValue) {\n        if (name === 'matrix') {\n            this.set('totalMatrix', null);\n        }\n    };\n    /**\n     * 属性更改后需要做的事情\n     * @protected\n     */\n    Element.prototype.afterAttrsChange = function (targetAttrs) {\n        if (this.cfg.isClipShape) {\n            var applyTo = this.cfg.applyTo;\n            if (applyTo) {\n                applyTo.onCanvasChange('clip');\n            }\n        }\n        else {\n            this.onCanvasChange('attr');\n        }\n    };\n    Element.prototype.show = function () {\n        // 不是高频操作直接使用 set\n        this.set('visible', true);\n        this.onCanvasChange('show');\n        return this;\n    };\n    Element.prototype.hide = function () {\n        // 不是高频操作直接使用 set\n        this.set('visible', false);\n        this.onCanvasChange('hide');\n        return this;\n    };\n    Element.prototype.setZIndex = function (zIndex) {\n        this.set('zIndex', zIndex);\n        var parent = this.getParent();\n        if (parent) {\n            // 改变 zIndex 不应该立即触发渲染 (调用 onCanvasChange('zIndex'))，需要经过 sort 再触发\n            parent.sort();\n        }\n        return this;\n    };\n    Element.prototype.toFront = function () {\n        var parent = this.getParent();\n        if (!parent) {\n            return;\n        }\n        var children = parent.getChildren();\n        var el = this.get('el');\n        var index = children.indexOf(this);\n        children.splice(index, 1);\n        children.push(this);\n        this.onCanvasChange('zIndex');\n    };\n    Element.prototype.toBack = function () {\n        var parent = this.getParent();\n        if (!parent) {\n            return;\n        }\n        var children = parent.getChildren();\n        var el = this.get('el');\n        var index = children.indexOf(this);\n        children.splice(index, 1);\n        children.unshift(this);\n        this.onCanvasChange('zIndex');\n    };\n    Element.prototype.remove = function (destroy) {\n        if (destroy === void 0) { destroy = true; }\n        var parent = this.getParent();\n        if (parent) {\n            removeFromArray(parent.getChildren(), this);\n            if (!parent.get('clearing')) {\n                // 如果父元素正在清理，当前元素不触发 remove\n                this.onCanvasChange('remove');\n            }\n        }\n        else {\n            this.onCanvasChange('remove');\n        }\n        if (destroy) {\n            this.destroy();\n        }\n    };\n    Element.prototype.resetMatrix = function () {\n        this.attr(MATRIX, this.getDefaultMatrix());\n        this.onCanvasChange('matrix');\n    };\n    Element.prototype.getMatrix = function () {\n        return this.attr(MATRIX);\n    };\n    Element.prototype.setMatrix = function (m) {\n        this.attr(MATRIX, m);\n        this.onCanvasChange('matrix');\n    };\n    // 获取总的 matrix\n    Element.prototype.getTotalMatrix = function () {\n        var totalMatrix = this.cfg.totalMatrix;\n        if (!totalMatrix) {\n            var currentMatrix = this.attr('matrix');\n            var parentMatrix = this.cfg.parentMatrix;\n            if (parentMatrix && currentMatrix) {\n                totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);\n            }\n            else {\n                totalMatrix = currentMatrix || parentMatrix;\n            }\n            this.set('totalMatrix', totalMatrix);\n        }\n        return totalMatrix;\n    };\n    // 上层分组设置 matrix\n    Element.prototype.applyMatrix = function (matrix) {\n        var currentMatrix = this.attr('matrix');\n        var totalMatrix = null;\n        if (matrix && currentMatrix) {\n            totalMatrix = multiplyMatrix(matrix, currentMatrix);\n        }\n        else {\n            totalMatrix = currentMatrix || matrix;\n        }\n        this.set('totalMatrix', totalMatrix);\n        this.set('parentMatrix', matrix);\n    };\n    /**\n     * @protected\n     * 获取默认的矩阵\n     * @returns {number[]|null} 默认的矩阵\n     */\n    Element.prototype.getDefaultMatrix = function () {\n        return null;\n    };\n    // 将向量应用设置的矩阵\n    Element.prototype.applyToMatrix = function (v) {\n        var matrix = this.attr('matrix');\n        if (matrix) {\n            return multiplyVec2(matrix, v);\n        }\n        return v;\n    };\n    // 根据设置的矩阵，将向量转换相对于图形/分组的位置\n    Element.prototype.invertFromMatrix = function (v) {\n        var matrix = this.attr('matrix');\n        if (matrix) {\n            var invertMatrix = invert(matrix);\n            if (invertMatrix) {\n                return multiplyVec2(invertMatrix, v);\n            }\n        }\n        return v;\n    };\n    // 设置 clip\n    Element.prototype.setClip = function (clipCfg) {\n        var canvas = this.getCanvas();\n        // 应该只设置当前元素的 clip，不应该去修改 clip 本身，方便 clip 被复用\n        // TODO: setClip 的传参既 shape 配置，也支持 shape 对象\n        // const preShape = this.get('clipShape');\n        // if (preShape) {\n        //   // 将之前的 clipShape 销毁\n        //   preShape.destroy();\n        // }\n        var clipShape = null;\n        // 如果配置项为 null，则不移除 clipShape\n        if (clipCfg) {\n            var ShapeBase = this.getShapeBase();\n            var shapeType = upperFirst(clipCfg.type);\n            var Cons = ShapeBase[shapeType];\n            if (Cons) {\n                clipShape = new Cons({\n                    type: clipCfg.type,\n                    isClipShape: true,\n                    applyTo: this,\n                    attrs: clipCfg.attrs,\n                    canvas: canvas,\n                });\n            }\n        }\n        this.set('clipShape', clipShape);\n        this.onCanvasChange('clip');\n        return clipShape;\n    };\n    Element.prototype.getClip = function () {\n        // 高频率调用的地方直接使用 this.cfg.xxx\n        var clipShape = this.cfg.clipShape;\n        // 未设置时返回 Null，保证一致性\n        if (!clipShape) {\n            return null;\n        }\n        return clipShape;\n    };\n    Element.prototype.clone = function () {\n        var _this = this;\n        var originAttrs = this.attrs;\n        var attrs = {};\n        each(originAttrs, function (i, k) {\n            if (isArray(originAttrs[k])) {\n                attrs[k] = _cloneArrayAttr(originAttrs[k]);\n            }\n            else {\n                attrs[k] = originAttrs[k];\n            }\n        });\n        var cons = this.constructor;\n        // @ts-ignore\n        var clone = new cons({ attrs: attrs });\n        each(CLONE_CFGS, function (cfgName) {\n            clone.set(cfgName, _this.get(cfgName));\n        });\n        return clone;\n    };\n    Element.prototype.destroy = function () {\n        var destroyed = this.destroyed;\n        if (destroyed) {\n            return;\n        }\n        this.attrs = {};\n        _super.prototype.destroy.call(this);\n        // this.onCanvasChange('destroy');\n    };\n    /**\n     * 是否处于动画暂停状态\n     * @return {boolean} 是否处于动画暂停状态\n     */\n    Element.prototype.isAnimatePaused = function () {\n        return this.get('_pause').isPaused;\n    };\n    /**\n     * 执行动画，支持多种函数签名\n     * 1. animate(toAttrs: ElementAttrs, duration: number, easing?: string, callback?: () => void, delay?: number)\n     * 2. animate(onFrame: OnFrame, duration: number, easing?: string, callback?: () => void, delay?: number)\n     * 3. animate(toAttrs: ElementAttrs, cfg: AnimateCfg)\n     * 4. animate(onFrame: OnFrame, cfg: AnimateCfg)\n     * 各个参数的含义为:\n     *   toAttrs  动画最终状态\n     *   onFrame  自定义帧动画函数\n     *   duration 动画执行时间\n     *   easing   动画缓动效果\n     *   callback 动画执行后的回调\n     *   delay    动画延迟时间\n     */\n    Element.prototype.animate = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (!this.get('timeline') && !this.get('canvas')) {\n            return;\n        }\n        this.set('animating', true);\n        var timeline = this.get('timeline');\n        if (!timeline) {\n            timeline = this.get('canvas').get('timeline');\n            this.set('timeline', timeline);\n        }\n        var animations = this.get('animations') || [];\n        // 初始化 tick\n        if (!timeline.timer) {\n            timeline.initTimer();\n        }\n        var toAttrs = args[0], duration = args[1], _a = args[2], easing = _a === void 0 ? 'easeLinear' : _a, _b = args[3], callback = _b === void 0 ? noop : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;\n        var onFrame;\n        var repeat;\n        var pauseCallback;\n        var resumeCallback;\n        var animateCfg;\n        // 第二个参数，既可以是动画最终状态 toAttrs，也可以是自定义帧动画函数 onFrame\n        if (isFunction(toAttrs)) {\n            onFrame = toAttrs;\n            toAttrs = {};\n        }\n        else if (isObject(toAttrs) && toAttrs.onFrame) {\n            // 兼容 3.0 中的写法，onFrame 和 repeat 可在 toAttrs 中设置\n            onFrame = toAttrs.onFrame;\n            repeat = toAttrs.repeat;\n        }\n        // 第二个参数，既可以是执行时间 duration，也可以是动画参数 animateCfg\n        if (isObject(duration)) {\n            animateCfg = duration;\n            duration = animateCfg.duration;\n            easing = animateCfg.easing || 'easeLinear';\n            delay = animateCfg.delay || 0;\n            // animateCfg 中的设置优先级更高\n            repeat = animateCfg.repeat || repeat || false;\n            callback = animateCfg.callback || noop;\n            pauseCallback = animateCfg.pauseCallback || noop;\n            resumeCallback = animateCfg.resumeCallback || noop;\n        }\n        else {\n            // 第四个参数，既可以是回调函数 callback，也可以是延迟时间 delay\n            if (isNumber(callback)) {\n                delay = callback;\n                callback = null;\n            }\n            // 第三个参数，既可以是缓动参数 easing，也可以是回调函数 callback\n            if (isFunction(easing)) {\n                callback = easing;\n                easing = 'easeLinear';\n            }\n            else {\n                easing = easing || 'easeLinear';\n            }\n        }\n        var formatToAttrs = getFormatToAttrs(toAttrs, this);\n        var animation = {\n            fromAttrs: getFormatFromAttrs(formatToAttrs, this),\n            toAttrs: formatToAttrs,\n            duration: duration,\n            easing: easing,\n            repeat: repeat,\n            callback: callback,\n            pauseCallback: pauseCallback,\n            resumeCallback: resumeCallback,\n            delay: delay,\n            startTime: timeline.getTime(),\n            id: uniqueId(),\n            onFrame: onFrame,\n            pathFormatted: false,\n        };\n        // 如果动画元素队列中已经有这个图形了\n        if (animations.length > 0) {\n            // 先检查是否需要合并属性。若有相同的动画，将该属性从前一个动画中删除,直接用后一个动画中\n            animations = checkExistedAttrs(animations, animation);\n        }\n        else {\n            // 否则将图形添加到动画元素队列\n            timeline.addAnimator(this);\n        }\n        animations.push(animation);\n        this.set('animations', animations);\n        this.set('_pause', { isPaused: false });\n    };\n    /**\n     * 停止动画\n     * @param {boolean} toEnd 是否到动画的最终状态\n     */\n    Element.prototype.stopAnimate = function (toEnd) {\n        var _this = this;\n        if (toEnd === void 0) { toEnd = true; }\n        var animations = this.get('animations');\n        each(animations, function (animation) {\n            // 将动画执行到最后一帧\n            if (toEnd) {\n                if (animation.onFrame) {\n                    _this.attr(animation.onFrame(1));\n                }\n                else {\n                    _this.attr(animation.toAttrs);\n                }\n            }\n            if (animation.callback) {\n                // 动画停止时的回调\n                animation.callback();\n            }\n        });\n        this.set('animating', false);\n        this.set('animations', []);\n    };\n    /**\n     * 暂停动画\n     */\n    Element.prototype.pauseAnimate = function () {\n        var timeline = this.get('timeline');\n        var animations = this.get('animations');\n        var pauseTime = timeline.getTime();\n        each(animations, function (animation) {\n            animation._paused = true;\n            animation._pauseTime = pauseTime;\n            if (animation.pauseCallback) {\n                // 动画暂停时的回调\n                animation.pauseCallback();\n            }\n        });\n        // 记录下是在什么时候暂停的\n        this.set('_pause', {\n            isPaused: true,\n            pauseTime: pauseTime,\n        });\n        return this;\n    };\n    /**\n     * 恢复动画\n     */\n    Element.prototype.resumeAnimate = function () {\n        var timeline = this.get('timeline');\n        var current = timeline.getTime();\n        var animations = this.get('animations');\n        var pauseTime = this.get('_pause').pauseTime;\n        // 之后更新属性需要计算动画已经执行的时长，如果暂停了，就把初始时间调后\n        each(animations, function (animation) {\n            animation.startTime = animation.startTime + (current - pauseTime);\n            animation._paused = false;\n            animation._pauseTime = null;\n            if (animation.resumeCallback) {\n                animation.resumeCallback();\n            }\n        });\n        this.set('_pause', {\n            isPaused: false,\n        });\n        this.set('animations', animations);\n        return this;\n    };\n    /**\n     * 触发委托事件\n     * @param  {string}     type 事件类型\n     * @param  {GraphEvent} eventObj 事件对象\n     */\n    Element.prototype.emitDelegation = function (type, eventObj) {\n        var _this = this;\n        var paths = eventObj.propagationPath;\n        var events = this.getEvents();\n        var relativeShape;\n        if (type === 'mouseenter') {\n            relativeShape = eventObj.fromShape;\n        }\n        else if (type === 'mouseleave') {\n            relativeShape = eventObj.toShape;\n        }\n        var _loop_1 = function (i) {\n            var element = paths[i];\n            // 暂定跟 name 绑定\n            var name_1 = element.get('name');\n            if (name_1) {\n                // 第一个 mouseenter 和 mouseleave 的停止即可，因为后面的都是前面的 Parent\n                if (\n                // 只有 element 是 Group 或者 Canvas 的时候，才需要判断 isParent\n                (element.isGroup() || (element.isCanvas && element.isCanvas())) &&\n                    relativeShape &&\n                    isParent(element, relativeShape)) {\n                    return \"break\";\n                }\n                if (isArray(name_1)) {\n                    each(name_1, function (subName) {\n                        _this.emitDelegateEvent(element, subName, eventObj);\n                    });\n                }\n                else {\n                    this_1.emitDelegateEvent(element, name_1, eventObj);\n                }\n            }\n        };\n        var this_1 = this;\n        // 至少有一个对象，且第一个对象为 shape\n        for (var i = 0; i < paths.length; i++) {\n            var state_1 = _loop_1(i);\n            if (state_1 === \"break\")\n                break;\n        }\n    };\n    Element.prototype.emitDelegateEvent = function (element, name, eventObj) {\n        var events = this.getEvents();\n        // 事件委托的形式 name:type\n        var eventName = name + DELEGATION_SPLIT + eventObj.type;\n        if (events[eventName] || events[WILDCARD]) {\n            // 对于通配符 *，事件名称 = 委托事件名称\n            eventObj.name = eventName;\n            eventObj.currentTarget = element;\n            eventObj.delegateTarget = this;\n            // 将委托事件的监听对象 delegateObject 挂载到事件对象上\n            eventObj.delegateObject = element.get('delegateObject');\n            this.emit(eventName, eventObj);\n        }\n    };\n    /**\n     * 移动元素\n     * @param {number} translateX 水平移动距离\n     * @param {number} translateY 垂直移动距离\n     * @return {IElement} 元素\n     */\n    Element.prototype.translate = function (translateX, translateY) {\n        if (translateX === void 0) { translateX = 0; }\n        if (translateY === void 0) { translateY = 0; }\n        var matrix = this.getMatrix();\n        var newMatrix = transform(matrix, [['t', translateX, translateY]]);\n        this.setMatrix(newMatrix);\n        return this;\n    };\n    /**\n     * 移动元素到目标位置\n     * @param {number} targetX 目标位置的水平坐标\n     * @param {number} targetX 目标位置的垂直坐标\n     * @return {IElement} 元素\n     */\n    Element.prototype.move = function (targetX, targetY) {\n        var x = this.attr('x') || 0;\n        var y = this.attr('y') || 0;\n        this.translate(targetX - x, targetY - y);\n        return this;\n    };\n    /**\n     * 移动元素到目标位置，等价于 move 方法。由于 moveTo 的语义性更强，因此在文档中推荐使用 moveTo 方法\n     * @param {number} targetX 目标位置的 x 轴坐标\n     * @param {number} targetY 目标位置的 y 轴坐标\n     * @return {IElement} 元素\n     */\n    Element.prototype.moveTo = function (targetX, targetY) {\n        return this.move(targetX, targetY);\n    };\n    /**\n     * 缩放元素\n     * @param {number} ratioX 水平缩放比例\n     * @param {number} ratioY 垂直缩放比例\n     * @return {IElement} 元素\n     */\n    Element.prototype.scale = function (ratioX, ratioY) {\n        var matrix = this.getMatrix();\n        var newMatrix = transform(matrix, [['s', ratioX, ratioY || ratioX]]);\n        this.setMatrix(newMatrix);\n        return this;\n    };\n    /**\n     * 以画布左上角 (0, 0) 为中心旋转元素\n     * @param {number} radian 旋转角度(弧度值)\n     * @return {IElement} 元素\n     */\n    Element.prototype.rotate = function (radian) {\n        var matrix = this.getMatrix();\n        var newMatrix = transform(matrix, [['r', radian]]);\n        this.setMatrix(newMatrix);\n        return this;\n    };\n    /**\n     * 以起始点为中心旋转元素\n     * @param {number} radian 旋转角度(弧度值)\n     * @return {IElement} 元素\n     */\n    Element.prototype.rotateAtStart = function (rotate) {\n        var _a = this.attr(), x = _a.x, y = _a.y;\n        var matrix = this.getMatrix();\n        var newMatrix = transform(matrix, [\n            ['t', -x, -y],\n            ['r', rotate],\n            ['t', x, y],\n        ]);\n        this.setMatrix(newMatrix);\n        return this;\n    };\n    /**\n     * 以任意点 (x, y) 为中心旋转元素\n     * @param {number} radian 旋转角度(弧度值)\n     * @return {IElement} 元素\n     */\n    Element.prototype.rotateAtPoint = function (x, y, rotate) {\n        var matrix = this.getMatrix();\n        var newMatrix = transform(matrix, [\n            ['t', -x, -y],\n            ['r', rotate],\n            ['t', x, y],\n        ]);\n        this.setMatrix(newMatrix);\n        return this;\n    };\n    return Element;\n}(Base));\nexport default Element;\n//# sourceMappingURL=element.js.map"]},"metadata":{},"sourceType":"module"}