{"ast":null,"code":"import { getLogPositiveMin, log } from '../util/math';\n/**\n * 计算 log 的 ticks，考虑 min = 0 的场景\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\n\nexport default function calculateLogTicks(cfg) {\n  var base = cfg.base,\n      tickCount = cfg.tickCount,\n      min = cfg.min,\n      max = cfg.max,\n      values = cfg.values;\n  var minTick;\n  var maxTick = log(base, max);\n\n  if (min > 0) {\n    minTick = Math.floor(log(base, min));\n  } else {\n    var positiveMin = getLogPositiveMin(values, base, max);\n    minTick = Math.floor(log(base, positiveMin));\n  }\n\n  var count = maxTick - minTick;\n  var avg = Math.ceil(count / tickCount);\n  var ticks = [];\n\n  for (var i = minTick; i < maxTick + avg; i = i + avg) {\n    ticks.push(Math.pow(base, i));\n  }\n\n  if (min <= 0) {\n    // 最小值 <= 0 时显示 0\n    ticks.unshift(0);\n  }\n\n  return ticks;\n}","map":{"version":3,"sources":["../../src/tick-method/log.ts"],"names":[],"mappings":"AAEA,SAAS,iBAAT,EAA4B,GAA5B,QAAuC,cAAvC;AAEA;;;;AAIG;;AACH,eAAc,SAAU,iBAAV,CAA4B,GAA5B,EAA4C;AAChD,MAAA,IAAI,GAAkC,GAAG,CAArC,IAAJ;AAAA,MAAM,SAAS,GAAuB,GAAG,CAA1B,SAAf;AAAA,MAAiB,GAAG,GAAkB,GAAG,CAArB,GAApB;AAAA,MAAsB,GAAG,GAAa,GAAG,CAAhB,GAAzB;AAAA,MAA2B,MAAM,GAAK,GAAG,CAAR,MAAjC;AACR,MAAI,OAAJ;AACA,MAAM,OAAO,GAAG,GAAG,CAAC,IAAD,EAAO,GAAP,CAAnB;;AACA,MAAI,GAAG,GAAG,CAAV,EAAa;AACX,IAAA,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,GAAG,CAAC,IAAD,EAAO,GAAP,CAAd,CAAV;AACD,GAFD,MAEO;AACL,QAAM,WAAW,GAAG,iBAAiB,CAAC,MAAD,EAAS,IAAT,EAAe,GAAf,CAArC;AACA,IAAA,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,GAAG,CAAC,IAAD,EAAO,WAAP,CAAd,CAAV;AACD;;AACD,MAAM,KAAK,GAAG,OAAO,GAAG,OAAxB;AACA,MAAM,GAAG,GAAG,IAAI,CAAC,IAAL,CAAU,KAAK,GAAG,SAAlB,CAAZ;AACA,MAAM,KAAK,GAAG,EAAd;;AACA,OAAK,IAAI,CAAC,GAAG,OAAb,EAAsB,CAAC,GAAG,OAAO,GAAG,GAApC,EAAyC,CAAC,GAAG,CAAC,GAAG,GAAjD,EAAsD;AACpD,IAAA,KAAK,CAAC,IAAN,CAAW,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,CAAf,CAAX;AACD;;AACD,MAAI,GAAG,IAAI,CAAX,EAAc;AACZ;AACA,IAAA,KAAK,CAAC,OAAN,CAAc,CAAd;AACD;;AACD,SAAO,KAAP;AACD","sourceRoot":"","sourcesContent":["import { getLogPositiveMin, log } from '../util/math';\n/**\n * 计算 log 的 ticks，考虑 min = 0 的场景\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nexport default function calculateLogTicks(cfg) {\n    var base = cfg.base, tickCount = cfg.tickCount, min = cfg.min, max = cfg.max, values = cfg.values;\n    var minTick;\n    var maxTick = log(base, max);\n    if (min > 0) {\n        minTick = Math.floor(log(base, min));\n    }\n    else {\n        var positiveMin = getLogPositiveMin(values, base, max);\n        minTick = Math.floor(log(base, positiveMin));\n    }\n    var count = maxTick - minTick;\n    var avg = Math.ceil(count / tickCount);\n    var ticks = [];\n    for (var i = minTick; i < maxTick + avg; i = i + avg) {\n        ticks.push(Math.pow(base, i));\n    }\n    if (min <= 0) {\n        // 最小值 <= 0 时显示 0\n        ticks.unshift(0);\n    }\n    return ticks;\n}\n//# sourceMappingURL=log.js.map"]},"metadata":{},"sourceType":"module"}