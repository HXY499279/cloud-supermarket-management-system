{"ast":null,"code":"/**\n * 碰撞检测算法\n */\nexport function antiCollision(items, labelHeight, plotRange) {\n  var labels = items.filter(function (item) {\n    return !item.invisible;\n  }); // sorted by y, mutable\n\n  labels.sort(function (a, b) {\n    return a.y - b.y;\n  }); // adjust y position of labels to avoid overlapping\n\n  var overlapping = true;\n  var startY = plotRange.minY;\n  var endY = plotRange.maxY;\n  var totalHeight = Math.abs(startY - endY);\n  var i;\n  var maxY = 0;\n  var minY = Number.MIN_VALUE;\n  var boxes = labels.map(function (label) {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n\n    if (label.y < minY) {\n      minY = label.y;\n    }\n\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null\n    };\n  });\n  minY -= startY;\n\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach(function (box) {\n      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    }); // detect overlapping and join boxes\n\n    overlapping = false;\n    i = boxes.length;\n\n    while (i--) {\n      if (i > 0) {\n        var previousBox = boxes[i - 1];\n        var box = boxes[i];\n\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up\n\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n\n          boxes.splice(i, 1); // removing box\n\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0; // step 4: normalize y and adjust x\n\n  boxes.forEach(function (b) {\n    var posInCompositeBox = startY + labelHeight / 2; // middle of the label\n\n    b.targets.forEach(function () {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/geometry/label/layout/pie/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { PolarLabelItem } from '../../interface';\n\n/**\n * 碰撞检测算法\n */\nexport function antiCollision(\n  items: PolarLabelItem[],\n  labelHeight: number,\n  plotRange: { minY: number; maxY: number; minX: number; maxX: number }\n) {\n  const labels = items.filter((item) => !item.invisible);\n\n  // sorted by y, mutable\n  labels.sort((a, b) => a.y - b.y);\n  // adjust y position of labels to avoid overlapping\n  let overlapping = true;\n  const startY = plotRange.minY;\n  const endY = plotRange.maxY;\n  let totalHeight = Math.abs(startY - endY);\n  let i;\n\n  let maxY = 0;\n  let minY = Number.MIN_VALUE;\n  const boxes = labels.map((label) => {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null,\n    };\n  });\n\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach((box) => {\n      const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    });\n\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        const previousBox = boxes[i - 1];\n        const box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach((b) => {\n    let posInCompositeBox = startY + labelHeight / 2; // middle of the label\n    b.targets.forEach(() => {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}