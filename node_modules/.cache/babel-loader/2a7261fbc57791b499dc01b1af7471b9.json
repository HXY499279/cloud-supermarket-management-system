{"ast":null,"code":"import { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\n\nexport function getXDimensionLength(coordinate) {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  } // 直角坐标系\n\n\n  var start = coordinate.convert({\n    x: 0,\n    y: 0\n  });\n  var end = coordinate.convert({\n    x: 1,\n    y: 0\n  }); // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\n\nexport function isFullCircle(coordinate) {\n  if (coordinate.isPolar) {\n    var startAngle = coordinate.startAngle,\n        endAngle = coordinate.endAngle;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n\n  return false;\n}\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\n\nexport function getDistanceToCenter(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n}\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\n\nexport function isPointInCoordinate(coordinate, point) {\n  var result = false;\n\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      var start = coordinate.start,\n          end = coordinate.end;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      var invertPoint = coordinate.invert(point);\n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n\n  return result;\n}\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\n\nexport function getAngleByPoint(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\n\nexport function getCoordinateClipCfg(coordinate, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var start = coordinate.start,\n      end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n\n  if (coordinate.isPolar) {\n    var startAngle_1 = coordinate.startAngle,\n        endAngle_1 = coordinate.endAngle;\n    var center_1 = coordinate.getCenter();\n    var radius_1 = coordinate.getRadius();\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)\n      },\n      endState: function (ratio) {\n        var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;\n        var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);\n        return {\n          path: path\n        };\n      },\n      attrs: {\n        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)\n      }\n    };\n  }\n\n  var endState;\n\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2\n    };\n  } else {\n    endState = {\n      width: width + margin * 2\n    };\n  }\n\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2\n    },\n    endState: endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2\n    }\n  };\n}\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\n\nexport function getCoordinateBBox(coordinate, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var start = coordinate.start,\n      end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n  var minX = Math.min(start.x, end.x);\n  var minY = Math.min(start.y, end.y);\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}","map":{"version":3,"sources":["../../src/util/coordinate.ts"],"names":[],"mappings":"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","sourcesContent":["import { Coordinate } from '../dependents';\nimport { Point } from '../interface';\nimport { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\nexport function getXDimensionLength(coordinate): number {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  }\n\n  // 直角坐标系\n  const start = coordinate.convert({ x: 0, y: 0 });\n  const end = coordinate.convert({ x: 1, y: 0 });\n  // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\nexport function isFullCircle(coordinate: Coordinate): boolean {\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n  return false;\n}\n\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\nexport function getDistanceToCenter(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter() as Point;\n  return Math.sqrt((point.x - center.x) ** 2 + (point.y - center.y) ** 2);\n}\n\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\nexport function isPointInCoordinate(coordinate: Coordinate, point: Point) {\n  let result = false;\n\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      const { start, end } = coordinate;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      const invertPoint = coordinate.invert(point);\n\n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n\n  return result;\n}\n\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\nexport function getAngleByPoint(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\nexport function getCoordinateClipCfg(coordinate: Coordinate, margin: number = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    const center = coordinate.getCenter();\n    const radius = coordinate.getRadius();\n\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, startAngle),\n      },\n      endState: (ratio) => {\n        const diff = (endAngle - startAngle) * ratio + startAngle;\n        const path = getSectorPath(center.x, center.y, radius + margin, startAngle, diff);\n        return {\n          path,\n        };\n      },\n      attrs: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, endAngle),\n      },\n    };\n  }\n\n  let endState;\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2,\n    };\n  } else {\n    endState = {\n      width: width + margin * 2,\n    };\n  }\n\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2,\n    },\n    endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2,\n    },\n  };\n}\n\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\nexport function getCoordinateBBox(coordinate: Coordinate, margin = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n  const minX = Math.min(start.x, end.x);\n  const minY = Math.min(start.y, end.y);\n\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}