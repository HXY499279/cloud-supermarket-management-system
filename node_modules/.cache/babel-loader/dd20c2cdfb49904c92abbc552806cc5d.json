{"ast":null,"code":"import { Line as LineUtil } from '@antv/g-math';\nexport default function inLine(x1, y1, x2, y2, lineWidth, x, y) {\n  var minX = Math.min(x1, x2);\n  var maxX = Math.max(x1, x2);\n  var minY = Math.min(y1, y2);\n  var maxY = Math.max(y1, y2);\n  var halfWidth = lineWidth / 2; // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\n  // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\n\n  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {\n    return false;\n  } // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\n\n\n  return LineUtil.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\n}","map":{"version":3,"sources":["../../../src/util/in-stroke/line.ts"],"names":[],"mappings":"AAAA,SAAS,IAAI,IAAI,QAAjB,QAAiC,cAAjC;AAEA,eAAc,SAAU,MAAV,CAAiB,EAAjB,EAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,SAAjC,EAA4C,CAA5C,EAA+C,CAA/C,EAAgD;AAC5D,MAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,EAAb,CAAb;AACA,MAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,EAAb,CAAb;AACA,MAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,EAAb,CAAb;AACA,MAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,EAAb,CAAb;AACA,MAAM,SAAS,GAAG,SAAS,GAAG,CAA9B,CAL4D,CAM5D;AACA;;AACA,MAAI,EAAE,CAAC,IAAI,IAAI,GAAG,SAAZ,IAAyB,CAAC,IAAI,IAAI,GAAG,SAArC,IAAkD,CAAC,IAAI,IAAI,GAAG,SAA9D,IAA2E,CAAC,IAAI,IAAI,GAAG,SAAzF,CAAJ,EAAyG;AACvG,WAAO,KAAP;AACD,GAV2D,CAW5D;;;AACA,SAAO,QAAQ,CAAC,WAAT,CAAqB,EAArB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC,EAAqC,CAArC,EAAwC,CAAxC,KAA8C,SAAS,GAAG,CAAjE;AACD","sourceRoot":"","sourcesContent":["import { Line as LineUtil } from '@antv/g-math';\nexport default function inLine(x1, y1, x2, y2, lineWidth, x, y) {\n    var minX = Math.min(x1, x2);\n    var maxX = Math.max(x1, x2);\n    var minY = Math.min(y1, y2);\n    var maxY = Math.max(y1, y2);\n    var halfWidth = lineWidth / 2;\n    // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\n    // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\n    if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {\n        return false;\n    }\n    // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\n    return LineUtil.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\n}\n//# sourceMappingURL=line.js.map"]},"metadata":{},"sourceType":"module"}