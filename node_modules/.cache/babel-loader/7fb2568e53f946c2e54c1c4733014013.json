{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { AbstractShape } from '@antv/g-base';\nimport { isNil, intersectRect } from '../util/util';\nimport { applyAttrsToContext, refreshElement } from '../util/draw';\nimport { getBBoxMethod } from '@antv/g-base';\nimport * as Shape from './index';\nimport Group from '../group';\n\nvar ShapeBase =\n/** @class */\nfunction (_super) {\n  __extends(ShapeBase, _super);\n\n  function ShapeBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ShapeBase.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this); // 设置默认值\n\n\n    return __assign(__assign({}, attrs), {\n      lineWidth: 1,\n      lineAppendWidth: 0,\n      strokeOpacity: 1,\n      fillOpacity: 1\n    });\n  };\n\n  ShapeBase.prototype.getShapeBase = function () {\n    return Shape;\n  };\n\n  ShapeBase.prototype.getGroupBase = function () {\n    return Group;\n  };\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n\n\n  ShapeBase.prototype.onCanvasChange = function (changeType) {\n    refreshElement(this, changeType);\n  };\n\n  ShapeBase.prototype.calculateBBox = function () {\n    var type = this.get('type');\n    var lineWidth = this.getHitLineWidth(); // const attrs = this.attr();\n\n    var bboxMethod = getBBoxMethod(type);\n    var box = bboxMethod(this);\n    var halfLineWidth = lineWidth / 2;\n    var minX = box.x - halfLineWidth;\n    var minY = box.y - halfLineWidth;\n    var maxX = box.x + box.width + halfLineWidth;\n    var maxY = box.y + box.height + halfLineWidth;\n    return {\n      x: minX,\n      minX: minX,\n      y: minY,\n      minY: minY,\n      width: box.width + lineWidth,\n      height: box.height + lineWidth,\n      maxX: maxX,\n      maxY: maxY\n    };\n  };\n\n  ShapeBase.prototype.isFill = function () {\n    return !!this.attrs['fill'] || this.isClipShape();\n  };\n\n  ShapeBase.prototype.isStroke = function () {\n    return !!this.attrs['stroke'];\n  }; // 同 shape 中的方法重复了\n\n\n  ShapeBase.prototype._applyClip = function (context, clip) {\n    if (clip) {\n      context.save(); // 将 clip 的属性挂载到 context 上\n\n      applyAttrsToContext(context, clip); // 绘制 clip 路径\n\n      clip.createPath(context);\n      context.restore(); // 裁剪\n\n      context.clip();\n\n      clip._afterDraw();\n    }\n  }; // 绘制图形时需要考虑 region 限制\n\n\n  ShapeBase.prototype.draw = function (context, region) {\n    var clip = this.cfg.clipShape; // 如果指定了 region，同时不允许刷新时，直接返回\n\n    if (region) {\n      if (this.cfg.refresh === false) {\n        // this._afterDraw();\n        this.set('hasChanged', false);\n        return;\n      } // 是否相交需要考虑 clip 的包围盒\n\n\n      var bbox = this.getCanvasBBox();\n\n      if (!intersectRect(region, bbox)) {\n        // 图形的包围盒与重绘区域不相交时，也需要清除标记\n        this.set('hasChanged', false); // 存在多种情形需要更新 cacheCanvasBBox 和 isInview 的判定\n        // 1. 之前图形在视窗内，但是现在不再视窗内\n        // 2. 如果当前的图形以及父元素都没有发生过变化，refresh = false 不会走到这里，所以这里的图形都是父元素发生变化，但是没有在视图内的元素\n\n        if (this.cfg.isInView) {\n          this._afterDraw();\n        }\n\n        return;\n      }\n    }\n\n    context.save(); // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n\n    applyAttrsToContext(context, this);\n\n    this._applyClip(context, clip);\n\n    this.drawPath(context);\n    context.restore();\n\n    this._afterDraw();\n  };\n\n  ShapeBase.prototype.getCanvasViewBox = function () {\n    var canvas = this.cfg.canvas;\n\n    if (canvas) {\n      // @ts-ignore\n      return canvas.getViewRange();\n    }\n\n    return null;\n  };\n\n  ShapeBase.prototype.cacheCanvasBBox = function () {\n    var canvasBBox = this.getCanvasViewBox(); // 绘制的时候缓存包围盒\n\n    if (canvasBBox) {\n      var bbox = this.getCanvasBBox();\n      var isInView = intersectRect(bbox, canvasBBox);\n      this.set('isInView', isInView); // 不再视窗内 cacheCanvasBBox 设置成 null，会提升局部渲染的性能，\n      // 因为在局部渲染影响的包围盒计算时不考虑这个图形的包围盒\n      // 父元素 cacheCanvasBBox 计算的时候也不计算\n\n      if (isInView) {\n        this.set('cacheCanvasBBox', bbox);\n      } else {\n        this.set('cacheCanvasBBox', null);\n      }\n    }\n  };\n\n  ShapeBase.prototype._afterDraw = function () {\n    this.cacheCanvasBBox(); // 绘制后消除标记\n\n    this.set('hasChanged', false);\n    this.set('refresh', null);\n  };\n\n  ShapeBase.prototype.skipDraw = function () {\n    this.set('cacheCanvasBBox', null);\n    this.set('isInView', null);\n    this.set('hasChanged', false);\n  };\n  /**\n   * 绘制图形的路径\n   * @param {CanvasRenderingContext2D} context 上下文\n   */\n\n\n  ShapeBase.prototype.drawPath = function (context) {\n    this.createPath(context);\n    this.strokeAndFill(context);\n    this.afterDrawPath(context);\n  };\n  /**\n   * @protected\n   * 填充图形\n   * @param {CanvasRenderingContext2D} context context 上下文\n   */\n\n\n  ShapeBase.prototype.fill = function (context) {\n    context.fill();\n  };\n  /**\n   * @protected\n   * 绘制图形边框\n   * @param {CanvasRenderingContext2D} context context 上下文\n   */\n\n\n  ShapeBase.prototype.stroke = function (context) {\n    context.stroke();\n  }; // 绘制或者填充\n\n\n  ShapeBase.prototype.strokeAndFill = function (context) {\n    var _a = this.attrs,\n        lineWidth = _a.lineWidth,\n        opacity = _a.opacity,\n        strokeOpacity = _a.strokeOpacity,\n        fillOpacity = _a.fillOpacity;\n\n    if (this.isFill()) {\n      if (!isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        this.fill(context);\n        context.globalAlpha = opacity;\n      } else {\n        this.fill(context);\n      }\n    }\n\n    if (this.isStroke()) {\n      if (lineWidth > 0) {\n        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = strokeOpacity;\n        }\n\n        this.stroke(context);\n      }\n    }\n\n    this.afterDrawPath(context);\n  };\n  /**\n   * @protected\n   * 绘制图形的路径\n   * @param {CanvasRenderingContext2D} context 上下文\n   */\n\n\n  ShapeBase.prototype.createPath = function (context) {};\n  /**\n   * 绘制完成 path 后的操作\n   * @param {CanvasRenderingContext2D} context 上下文\n   */\n\n\n  ShapeBase.prototype.afterDrawPath = function (context) {};\n\n  ShapeBase.prototype.isInShape = function (refX, refY) {\n    // return HitUtil.isHitShape(this, refX, refY);\n    var isStroke = this.isStroke();\n    var isFill = this.isFill();\n    var lineWidth = this.getHitLineWidth();\n    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);\n  }; // 之所以不拆成 isInStroke 和 isInPath 在于两者存在一些共同的计算\n\n\n  ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n    return false;\n  };\n  /**\n   * 获取线拾取的宽度\n   * @returns {number} 线的拾取宽度\n   */\n\n\n  ShapeBase.prototype.getHitLineWidth = function () {\n    if (!this.isStroke()) {\n      return 0;\n    }\n\n    var attrs = this.attrs;\n    return attrs['lineWidth'] + attrs['lineAppendWidth'];\n  };\n\n  return ShapeBase;\n}(AbstractShape);\n\nexport default ShapeBase;","map":{"version":3,"sources":["../../src/shape/base.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { AbstractShape } from '@antv/g-base';\nimport { isNil, intersectRect } from '../util/util';\nimport { applyAttrsToContext, refreshElement } from '../util/draw';\nimport { getBBoxMethod } from '@antv/g-base';\nimport * as Shape from './index';\nimport Group from '../group';\nvar ShapeBase = /** @class */ (function (_super) {\n    __extends(ShapeBase, _super);\n    function ShapeBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ShapeBase.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        // 设置默认值\n        return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });\n    };\n    ShapeBase.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    ShapeBase.prototype.getGroupBase = function () {\n        return Group;\n    };\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    ShapeBase.prototype.onCanvasChange = function (changeType) {\n        refreshElement(this, changeType);\n    };\n    ShapeBase.prototype.calculateBBox = function () {\n        var type = this.get('type');\n        var lineWidth = this.getHitLineWidth();\n        // const attrs = this.attr();\n        var bboxMethod = getBBoxMethod(type);\n        var box = bboxMethod(this);\n        var halfLineWidth = lineWidth / 2;\n        var minX = box.x - halfLineWidth;\n        var minY = box.y - halfLineWidth;\n        var maxX = box.x + box.width + halfLineWidth;\n        var maxY = box.y + box.height + halfLineWidth;\n        return {\n            x: minX,\n            minX: minX,\n            y: minY,\n            minY: minY,\n            width: box.width + lineWidth,\n            height: box.height + lineWidth,\n            maxX: maxX,\n            maxY: maxY,\n        };\n    };\n    ShapeBase.prototype.isFill = function () {\n        return !!this.attrs['fill'] || this.isClipShape();\n    };\n    ShapeBase.prototype.isStroke = function () {\n        return !!this.attrs['stroke'];\n    };\n    // 同 shape 中的方法重复了\n    ShapeBase.prototype._applyClip = function (context, clip) {\n        if (clip) {\n            context.save();\n            // 将 clip 的属性挂载到 context 上\n            applyAttrsToContext(context, clip);\n            // 绘制 clip 路径\n            clip.createPath(context);\n            context.restore();\n            // 裁剪\n            context.clip();\n            clip._afterDraw();\n        }\n    };\n    // 绘制图形时需要考虑 region 限制\n    ShapeBase.prototype.draw = function (context, region) {\n        var clip = this.cfg.clipShape;\n        // 如果指定了 region，同时不允许刷新时，直接返回\n        if (region) {\n            if (this.cfg.refresh === false) {\n                // this._afterDraw();\n                this.set('hasChanged', false);\n                return;\n            }\n            // 是否相交需要考虑 clip 的包围盒\n            var bbox = this.getCanvasBBox();\n            if (!intersectRect(region, bbox)) {\n                // 图形的包围盒与重绘区域不相交时，也需要清除标记\n                this.set('hasChanged', false);\n                // 存在多种情形需要更新 cacheCanvasBBox 和 isInview 的判定\n                // 1. 之前图形在视窗内，但是现在不再视窗内\n                // 2. 如果当前的图形以及父元素都没有发生过变化，refresh = false 不会走到这里，所以这里的图形都是父元素发生变化，但是没有在视图内的元素\n                if (this.cfg.isInView) {\n                    this._afterDraw();\n                }\n                return;\n            }\n        }\n        context.save();\n        // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n        applyAttrsToContext(context, this);\n        this._applyClip(context, clip);\n        this.drawPath(context);\n        context.restore();\n        this._afterDraw();\n    };\n    ShapeBase.prototype.getCanvasViewBox = function () {\n        var canvas = this.cfg.canvas;\n        if (canvas) {\n            // @ts-ignore\n            return canvas.getViewRange();\n        }\n        return null;\n    };\n    ShapeBase.prototype.cacheCanvasBBox = function () {\n        var canvasBBox = this.getCanvasViewBox();\n        // 绘制的时候缓存包围盒\n        if (canvasBBox) {\n            var bbox = this.getCanvasBBox();\n            var isInView = intersectRect(bbox, canvasBBox);\n            this.set('isInView', isInView);\n            // 不再视窗内 cacheCanvasBBox 设置成 null，会提升局部渲染的性能，\n            // 因为在局部渲染影响的包围盒计算时不考虑这个图形的包围盒\n            // 父元素 cacheCanvasBBox 计算的时候也不计算\n            if (isInView) {\n                this.set('cacheCanvasBBox', bbox);\n            }\n            else {\n                this.set('cacheCanvasBBox', null);\n            }\n        }\n    };\n    ShapeBase.prototype._afterDraw = function () {\n        this.cacheCanvasBBox();\n        // 绘制后消除标记\n        this.set('hasChanged', false);\n        this.set('refresh', null);\n    };\n    ShapeBase.prototype.skipDraw = function () {\n        this.set('cacheCanvasBBox', null);\n        this.set('isInView', null);\n        this.set('hasChanged', false);\n    };\n    /**\n     * 绘制图形的路径\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.drawPath = function (context) {\n        this.createPath(context);\n        this.strokeAndFill(context);\n        this.afterDrawPath(context);\n    };\n    /**\n     * @protected\n     * 填充图形\n     * @param {CanvasRenderingContext2D} context context 上下文\n     */\n    ShapeBase.prototype.fill = function (context) {\n        context.fill();\n    };\n    /**\n     * @protected\n     * 绘制图形边框\n     * @param {CanvasRenderingContext2D} context context 上下文\n     */\n    ShapeBase.prototype.stroke = function (context) {\n        context.stroke();\n    };\n    // 绘制或者填充\n    ShapeBase.prototype.strokeAndFill = function (context) {\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\n        if (this.isFill()) {\n            if (!isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                this.fill(context);\n                context.globalAlpha = opacity;\n            }\n            else {\n                this.fill(context);\n            }\n        }\n        if (this.isStroke()) {\n            if (lineWidth > 0) {\n                if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = strokeOpacity;\n                }\n                this.stroke(context);\n            }\n        }\n        this.afterDrawPath(context);\n    };\n    /**\n     * @protected\n     * 绘制图形的路径\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.createPath = function (context) { };\n    /**\n     * 绘制完成 path 后的操作\n     * @param {CanvasRenderingContext2D} context 上下文\n     */\n    ShapeBase.prototype.afterDrawPath = function (context) { };\n    ShapeBase.prototype.isInShape = function (refX, refY) {\n        // return HitUtil.isHitShape(this, refX, refY);\n        var isStroke = this.isStroke();\n        var isFill = this.isFill();\n        var lineWidth = this.getHitLineWidth();\n        return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);\n    };\n    // 之所以不拆成 isInStroke 和 isInPath 在于两者存在一些共同的计算\n    ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        return false;\n    };\n    /**\n     * 获取线拾取的宽度\n     * @returns {number} 线的拾取宽度\n     */\n    ShapeBase.prototype.getHitLineWidth = function () {\n        if (!this.isStroke()) {\n            return 0;\n        }\n        var attrs = this.attrs;\n        return attrs['lineWidth'] + attrs['lineAppendWidth'];\n    };\n    return ShapeBase;\n}(AbstractShape));\nexport default ShapeBase;\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}