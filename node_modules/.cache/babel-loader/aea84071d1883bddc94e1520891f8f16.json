{"ast":null,"code":"import { groupBy, keys, map } from '@antv/util';\nimport { findLabelTextShape } from '../../util';\n/**\n * 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...\n * @param geometry\n * @param labels\n */\n\nfunction sortLabels(geometry, labels) {\n  var yField = geometry.getXYFields()[1];\n  var result = [];\n  var sortedLabels = labels.sort(function (left, right) {\n    return left.get('data')[yField] - left.get('data')[yField];\n  });\n\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.shift());\n  }\n\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.pop());\n  }\n\n  result.push.apply(result, sortedLabels);\n  return result;\n}\n\nfunction hasSome(dones, current, compare) {\n  return dones.some(function (done) {\n    return compare(done, current);\n  });\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\n\n\nfunction getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/**\n * 判断新添加的 Label 是否和已存在的发生重叠\n * @param dones\n * @param current\n */\n\n\nfunction checkShapeOverlap(dones, current) {\n  return hasSome(dones, current, function (left, right) {\n    var leftText = findLabelTextShape(left);\n    var rightText = findLabelTextShape(right);\n    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;\n  });\n}\n/**\n * 适用于 point geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n * @param region\n * @param cfg\n */\n\n\nexport function pointAdjustPosition(items, labels, shapes, region, cfg) {\n  var _a, _b;\n\n  if (shapes.length === 0) {\n    return;\n  }\n\n  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');\n  var geometry = element === null || element === void 0 ? void 0 : element.geometry;\n\n  if (!geometry || geometry.type !== 'point') {\n    return;\n  }\n\n  var _c = geometry.getXYFields(),\n      xField = _c[0],\n      yField = _c[1];\n\n  var groupedLabels = groupBy(labels, function (label) {\n    return label.get('data')[xField];\n  });\n  var dones = [];\n  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;\n  map(keys(groupedLabels).reverse(), function (xValue) {\n    var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);\n\n    while (sortedCollections.length) {\n      var current = sortedCollections.shift();\n      var textShape = findLabelTextShape(current);\n\n      if (hasSome(dones, current, function (left, right) {\n        return left.get('data')[xField] === right.get('data')[xField] && left.get('data')[yField] === right.get('data')[yField];\n      })) {\n        // 重复位置，直接隐藏\n        textShape.set('visible', false);\n        continue;\n      }\n\n      var upFail = checkShapeOverlap(dones, current);\n      var downFail = false;\n\n      if (upFail) {\n        textShape.attr('y', textShape.attr('y') + 2 * offset);\n        downFail = checkShapeOverlap(dones, current);\n      }\n\n      if (downFail) {\n        textShape.set('visible', false);\n        continue;\n      }\n\n      dones.push(current);\n    }\n  });\n}","map":{"version":3,"sources":["../../../../../src/geometry/label/layout/point/adjust-position.ts"],"names":[],"mappings":"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","sourcesContent":["import { groupBy, keys, map } from '@antv/util';\nimport { IElement, IGroup, IShape, BBox } from '../../../../dependents';\nimport Geometry from '../../../base';\nimport Element from '../../../element';\nimport { LabelItem } from '../../interface';\nimport { findLabelTextShape } from '../../util';\n\n/**\n * point-adjust-position layout 的配置类型\n */\nexport interface PointAdjustPositionLayoutCfg {\n  offset?: number;\n}\n\n/**\n * 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...\n * @param geometry\n * @param labels\n */\nfunction sortLabels(geometry: Geometry, labels: IGroup[]) {\n  const yField = geometry.getXYFields()[1];\n  const result: IGroup[] = [];\n  const sortedLabels = labels.sort((left, right) => left.get('data')[yField] - left.get('data')[yField]);\n\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.shift());\n  }\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.pop());\n  }\n  result.push(...sortedLabels);\n\n  return result;\n}\n\nfunction hasSome(dones: IGroup[], current: IGroup, compare: (left: IGroup, right: IGroup) => boolean): boolean {\n  return dones.some((done) => compare(done, current));\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nfunction getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/**\n * 判断新添加的 Label 是否和已存在的发生重叠\n * @param dones\n * @param current\n */\nfunction checkShapeOverlap(dones: IGroup[], current: IGroup): boolean {\n  return hasSome(dones, current, (left, right) => {\n    const leftText = findLabelTextShape(left);\n    const rightText = findLabelTextShape(right);\n\n    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;\n  });\n}\n/**\n * 适用于 point geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n * @param region\n * @param cfg\n */\nexport function pointAdjustPosition(\n  items: LabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox,\n  cfg: PointAdjustPositionLayoutCfg\n): void {\n  if (shapes.length === 0) {\n    return;\n  }\n\n  const element: Element = shapes[0]?.get('element');\n  const geometry: Geometry = element?.geometry;\n  if (!geometry || geometry.type !== 'point') {\n    return;\n  }\n  const [xField, yField] = geometry.getXYFields();\n  const groupedLabels = groupBy(labels, (label) => label.get('data')[xField]);\n  const dones: IGroup[] = [];\n  const offset = (cfg && cfg.offset) || items[0]?.offset || 12;\n\n  map(keys(groupedLabels).reverse(), (xValue) => {\n    const sortedCollections = sortLabels(geometry, groupedLabels[xValue]);\n    while (sortedCollections.length) {\n      const current = sortedCollections.shift();\n      const textShape = findLabelTextShape(current);\n      if (\n        hasSome(\n          dones,\n          current,\n          (left, right) =>\n            left.get('data')[xField] === right.get('data')[xField] &&\n            left.get('data')[yField] === right.get('data')[yField]\n        )\n      ) {\n        // 重复位置，直接隐藏\n        textShape.set('visible', false);\n        continue;\n      }\n      const upFail = checkShapeOverlap(dones, current);\n      let downFail: boolean = false;\n      if (upFail) {\n        textShape.attr('y', textShape.attr('y') + 2 * offset);\n        downFail = checkShapeOverlap(dones, current);\n      }\n      if (downFail) {\n        textShape.set('visible', false);\n        continue;\n      }\n      dones.push(current);\n    }\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}