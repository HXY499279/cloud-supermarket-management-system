{"ast":null,"code":"import { distance } from './util';\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\n\nexport function nearestPoint(xArr, yArr, x, y, tCallback, length) {\n  var t;\n  var d = Infinity;\n  var v0 = [x, y];\n  var segNum = 20;\n\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n\n  var increaseRate = 1 / segNum;\n  var interval = increaseRate / 10;\n\n  for (var i = 0; i <= segNum; i++) {\n    var _t = i * increaseRate;\n\n    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  } // 提前终止\n\n\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0]\n    };\n  }\n\n  if (t === 1) {\n    var count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1]\n    };\n  }\n\n  d = Infinity;\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval;\n    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];\n      var d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  return {\n    x: tCallback.apply(null, xArr.concat([t])),\n    y: tCallback.apply(null, yArr.concat([t]))\n  };\n} // 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\n\nexport function snapLength(xArr, yArr) {\n  var totalLength = 0;\n  var count = xArr.length;\n\n  for (var i = 0; i < count; i++) {\n    var x = xArr[i];\n    var y = yArr[i];\n    var nextX = xArr[(i + 1) % count];\n    var nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n\n  return totalLength / 2;\n}","map":{"version":3,"sources":["../src/bezier.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { distance } from './util';\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nexport function nearestPoint(xArr, yArr, x, y, tCallback, length) {\n    var t;\n    var d = Infinity;\n    var v0 = [x, y];\n    var segNum = 20;\n    if (length && length > 200) {\n        segNum = length / 10;\n    }\n    var increaseRate = 1 / segNum;\n    var interval = increaseRate / 10;\n    for (var i = 0; i <= segNum; i++) {\n        var _t = i * increaseRate;\n        var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];\n        var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n        if (d1 < d) {\n            t = _t;\n            d = d1;\n        }\n    }\n    // 提前终止\n    if (t === 0) {\n        return {\n            x: xArr[0],\n            y: yArr[0],\n        };\n    }\n    if (t === 1) {\n        var count = xArr.length;\n        return {\n            x: xArr[count - 1],\n            y: yArr[count - 1],\n        };\n    }\n    d = Infinity;\n    for (var i = 0; i < 32; i++) {\n        if (interval < EPSILON) {\n            break;\n        }\n        var prev = t - interval;\n        var next = t + interval;\n        var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];\n        var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n        if (prev >= 0 && d1 < d) {\n            t = prev;\n            d = d1;\n        }\n        else {\n            var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];\n            var d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n            if (next <= 1 && d2 < d) {\n                t = next;\n                d = d2;\n            }\n            else {\n                interval *= 0.5;\n            }\n        }\n    }\n    return {\n        x: tCallback.apply(null, xArr.concat([t])),\n        y: tCallback.apply(null, yArr.concat([t])),\n    };\n}\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nexport function snapLength(xArr, yArr) {\n    var totalLength = 0;\n    var count = xArr.length;\n    for (var i = 0; i < count; i++) {\n        var x = xArr[i];\n        var y = yArr[i];\n        var nextX = xArr[(i + 1) % count];\n        var nextY = yArr[(i + 1) % count];\n        totalLength += distance(x, y, nextX, nextY);\n    }\n    return totalLength / 2;\n}\n//# sourceMappingURL=bezier.js.map"]},"metadata":{},"sourceType":"module"}