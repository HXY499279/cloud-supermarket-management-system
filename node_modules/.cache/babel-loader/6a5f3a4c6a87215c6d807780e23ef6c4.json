{"ast":null,"code":"import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport * as d3Ease from 'd3-ease';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\n\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\n\nfunction _update(shape, animation, ratio) {\n  var cProps = {}; // 此刻属性\n\n  var fromAttrs = animation.fromAttrs,\n      toAttrs = animation.toAttrs;\n\n  if (shape.destroyed) {\n    return;\n  }\n\n  var interf; //  差值函数\n\n  for (var k in toAttrs) {\n    if (!isEqual(fromAttrs[k], toAttrs[k])) {\n      if (k === 'path') {\n        var toPath = toAttrs[k];\n        var fromPath = fromAttrs[k];\n\n        if (toPath.length > fromPath.length) {\n          toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n\n          fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n\n          fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n        } else if (!animation.pathFormatted) {\n          toPath = PathUtil.parsePathString(toAttrs[k]);\n          fromPath = PathUtil.parsePathString(fromAttrs[k]);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n          animation.pathFormatted = true;\n        }\n\n        cProps[k] = [];\n\n        for (var i = 0; i < toPath.length; i++) {\n          var toPathPoint = toPath[i];\n          var fromPathPoint = fromPath[i];\n          var cPathPoint = [];\n\n          for (var j = 0; j < toPathPoint.length; j++) {\n            if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n              interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n              cPathPoint.push(interf(ratio));\n            } else {\n              cPathPoint.push(toPathPoint[j]);\n            }\n          }\n\n          cProps[k].push(cPathPoint);\n        }\n      } else if (k === 'matrix') {\n        /*\n         对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n         TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n         */\n        var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n        var currentMatrix = matrixFn(ratio);\n        cProps[k] = currentMatrix;\n      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n        cProps[k] = toAttrs[k];\n      } else if (!isFunction(toAttrs[k])) {\n        // 非函数类型的值才能做插值\n        interf = interpolate(fromAttrs[k], toAttrs[k]);\n        cProps[k] = interf(ratio);\n      }\n    }\n  }\n\n  shape.attr(cProps);\n}\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\n\n\nfunction update(shape, animation, elapsed) {\n  var startTime = animation.startTime,\n      delay = animation.delay; // 如果还没有开始执行或暂停，先不更新\n\n  if (elapsed < startTime + delay || animation._paused) {\n    return false;\n  }\n\n  var ratio;\n  var duration = animation.duration;\n  var easing = animation.easing; // 已执行时间\n\n  elapsed = elapsed - startTime - animation.delay;\n\n  if (animation.repeat) {\n    // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n    ratio = elapsed % duration / duration;\n    ratio = d3Ease[easing](ratio);\n  } else {\n    ratio = elapsed / duration;\n\n    if (ratio < 1) {\n      // 动画未执行完\n      ratio = d3Ease[easing](ratio);\n    } else {\n      // 动画已执行完\n      if (animation.onFrame) {\n        shape.attr(animation.onFrame(1));\n      } else {\n        shape.attr(animation.toAttrs);\n      }\n\n      return true;\n    }\n  }\n\n  if (animation.onFrame) {\n    var attrs = animation.onFrame(ratio);\n    shape.attr(attrs);\n  } else {\n    _update(shape, animation, ratio);\n  }\n\n  return false;\n}\n\nvar Timeline =\n/** @class */\nfunction () {\n  /**\n   * 时间轴构造函数，依赖于画布\n   * @param {}\n   */\n  function Timeline(canvas) {\n    /**\n     * 执行动画的元素列表\n     * @type {IElement[]}\n     */\n    this.animators = [];\n    /**\n     * 当前时间\n     * @type {number}\n     */\n\n    this.current = 0;\n    /**\n     * 定时器\n     * @type {d3Timer.Timer}\n     */\n\n    this.timer = null;\n    this.canvas = canvas;\n  }\n  /**\n   * 初始化定时器\n   */\n\n\n  Timeline.prototype.initTimer = function () {\n    var _this = this;\n\n    var isFinished = false;\n    var shape;\n    var animations;\n    var animation;\n    this.timer = d3Timer.timer(function (elapsed) {\n      _this.current = elapsed;\n\n      if (_this.animators.length > 0) {\n        for (var i = _this.animators.length - 1; i >= 0; i--) {\n          shape = _this.animators[i];\n\n          if (shape.destroyed) {\n            // 如果已经被销毁，直接移出队列\n            _this.removeAnimator(i);\n\n            continue;\n          }\n\n          if (!shape.isAnimatePaused()) {\n            animations = shape.get('animations');\n\n            for (var j = animations.length - 1; j >= 0; j--) {\n              animation = animations[j];\n              isFinished = update(shape, animation, elapsed);\n\n              if (isFinished) {\n                animations.splice(j, 1);\n                isFinished = false;\n\n                if (animation.callback) {\n                  animation.callback();\n                }\n              }\n            }\n          }\n\n          if (animations.length === 0) {\n            _this.removeAnimator(i);\n          }\n        }\n\n        var autoDraw = _this.canvas.get('autoDraw'); // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n\n\n        if (!autoDraw) {\n          _this.canvas.draw();\n        }\n      }\n    });\n  };\n  /**\n   * 增加动画元素\n   */\n\n\n  Timeline.prototype.addAnimator = function (shape) {\n    this.animators.push(shape);\n  };\n  /**\n   * 移除动画元素\n   */\n\n\n  Timeline.prototype.removeAnimator = function (index) {\n    this.animators.splice(index, 1);\n  };\n  /**\n   * 是否有动画在执行\n   */\n\n\n  Timeline.prototype.isAnimating = function () {\n    return !!this.animators.length;\n  };\n  /**\n   * 停止定时器\n   */\n\n\n  Timeline.prototype.stop = function () {\n    if (this.timer) {\n      this.timer.stop();\n    }\n  };\n  /**\n   * 停止时间轴上所有元素的动画，并置空动画元素列表\n   * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n   */\n\n\n  Timeline.prototype.stopAllAnimations = function (toEnd) {\n    if (toEnd === void 0) {\n      toEnd = true;\n    }\n\n    this.animators.forEach(function (animator) {\n      animator.stopAnimate(toEnd);\n    });\n    this.animators = [];\n    this.canvas.draw();\n  };\n  /**\n   * 获取当前时间\n   */\n\n\n  Timeline.prototype.getTime = function () {\n    return this.current;\n  };\n\n  return Timeline;\n}();\n\nexport default Timeline;","map":{"version":3,"sources":["../../src/animate/timeline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport * as d3Ease from 'd3-ease';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\nfunction _update(shape, animation, ratio) {\n    var cProps = {}; // 此刻属性\n    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;\n    if (shape.destroyed) {\n        return;\n    }\n    var interf; //  差值函数\n    for (var k in toAttrs) {\n        if (!isEqual(fromAttrs[k], toAttrs[k])) {\n            if (k === 'path') {\n                var toPath = toAttrs[k];\n                var fromPath = fromAttrs[k];\n                if (toPath.length > fromPath.length) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n                    fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                }\n                else if (!animation.pathFormatted) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]);\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                    animation.pathFormatted = true;\n                }\n                cProps[k] = [];\n                for (var i = 0; i < toPath.length; i++) {\n                    var toPathPoint = toPath[i];\n                    var fromPathPoint = fromPath[i];\n                    var cPathPoint = [];\n                    for (var j = 0; j < toPathPoint.length; j++) {\n                        if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n                            interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n                            cPathPoint.push(interf(ratio));\n                        }\n                        else {\n                            cPathPoint.push(toPathPoint[j]);\n                        }\n                    }\n                    cProps[k].push(cPathPoint);\n                }\n            }\n            else if (k === 'matrix') {\n                /*\n                 对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n                 TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n                 */\n                var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n                var currentMatrix = matrixFn(ratio);\n                cProps[k] = currentMatrix;\n            }\n            else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n                cProps[k] = toAttrs[k];\n            }\n            else if (!isFunction(toAttrs[k])) {\n                // 非函数类型的值才能做插值\n                interf = interpolate(fromAttrs[k], toAttrs[k]);\n                cProps[k] = interf(ratio);\n            }\n        }\n    }\n    shape.attr(cProps);\n}\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\nfunction update(shape, animation, elapsed) {\n    var startTime = animation.startTime, delay = animation.delay;\n    // 如果还没有开始执行或暂停，先不更新\n    if (elapsed < startTime + delay || animation._paused) {\n        return false;\n    }\n    var ratio;\n    var duration = animation.duration;\n    var easing = animation.easing;\n    // 已执行时间\n    elapsed = elapsed - startTime - animation.delay;\n    if (animation.repeat) {\n        // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n        ratio = (elapsed % duration) / duration;\n        ratio = d3Ease[easing](ratio);\n    }\n    else {\n        ratio = elapsed / duration;\n        if (ratio < 1) {\n            // 动画未执行完\n            ratio = d3Ease[easing](ratio);\n        }\n        else {\n            // 动画已执行完\n            if (animation.onFrame) {\n                shape.attr(animation.onFrame(1));\n            }\n            else {\n                shape.attr(animation.toAttrs);\n            }\n            return true;\n        }\n    }\n    if (animation.onFrame) {\n        var attrs = animation.onFrame(ratio);\n        shape.attr(attrs);\n    }\n    else {\n        _update(shape, animation, ratio);\n    }\n    return false;\n}\nvar Timeline = /** @class */ (function () {\n    /**\n     * 时间轴构造函数，依赖于画布\n     * @param {}\n     */\n    function Timeline(canvas) {\n        /**\n         * 执行动画的元素列表\n         * @type {IElement[]}\n         */\n        this.animators = [];\n        /**\n         * 当前时间\n         * @type {number}\n         */\n        this.current = 0;\n        /**\n         * 定时器\n         * @type {d3Timer.Timer}\n         */\n        this.timer = null;\n        this.canvas = canvas;\n    }\n    /**\n     * 初始化定时器\n     */\n    Timeline.prototype.initTimer = function () {\n        var _this = this;\n        var isFinished = false;\n        var shape;\n        var animations;\n        var animation;\n        this.timer = d3Timer.timer(function (elapsed) {\n            _this.current = elapsed;\n            if (_this.animators.length > 0) {\n                for (var i = _this.animators.length - 1; i >= 0; i--) {\n                    shape = _this.animators[i];\n                    if (shape.destroyed) {\n                        // 如果已经被销毁，直接移出队列\n                        _this.removeAnimator(i);\n                        continue;\n                    }\n                    if (!shape.isAnimatePaused()) {\n                        animations = shape.get('animations');\n                        for (var j = animations.length - 1; j >= 0; j--) {\n                            animation = animations[j];\n                            isFinished = update(shape, animation, elapsed);\n                            if (isFinished) {\n                                animations.splice(j, 1);\n                                isFinished = false;\n                                if (animation.callback) {\n                                    animation.callback();\n                                }\n                            }\n                        }\n                    }\n                    if (animations.length === 0) {\n                        _this.removeAnimator(i);\n                    }\n                }\n                var autoDraw = _this.canvas.get('autoDraw');\n                // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n                if (!autoDraw) {\n                    _this.canvas.draw();\n                }\n            }\n        });\n    };\n    /**\n     * 增加动画元素\n     */\n    Timeline.prototype.addAnimator = function (shape) {\n        this.animators.push(shape);\n    };\n    /**\n     * 移除动画元素\n     */\n    Timeline.prototype.removeAnimator = function (index) {\n        this.animators.splice(index, 1);\n    };\n    /**\n     * 是否有动画在执行\n     */\n    Timeline.prototype.isAnimating = function () {\n        return !!this.animators.length;\n    };\n    /**\n     * 停止定时器\n     */\n    Timeline.prototype.stop = function () {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    };\n    /**\n     * 停止时间轴上所有元素的动画，并置空动画元素列表\n     * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n     */\n    Timeline.prototype.stopAllAnimations = function (toEnd) {\n        if (toEnd === void 0) { toEnd = true; }\n        this.animators.forEach(function (animator) {\n            animator.stopAnimate(toEnd);\n        });\n        this.animators = [];\n        this.canvas.draw();\n    };\n    /**\n     * 获取当前时间\n     */\n    Timeline.prototype.getTime = function () {\n        return this.current;\n    };\n    return Timeline;\n}());\nexport default Timeline;\n//# sourceMappingURL=timeline.js.map"]},"metadata":{},"sourceType":"module"}