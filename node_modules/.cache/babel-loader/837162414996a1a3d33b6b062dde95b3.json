{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { get, deepMix, isArray } from '@antv/util';\nimport GeometryLabel from './base';\n/**\n * 柱状图 label\n */\n\nvar IntervalLabel =\n/** @class */\nfunction (_super) {\n  __extends(IntervalLabel, _super);\n\n  function IntervalLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n\n\n  IntervalLabel.prototype.getLabelValueDir = function (mappingData) {\n    // points 中的 x/y 和 transpose 无关\n    var dim = 'y';\n    var points = mappingData.points;\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  };\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n\n\n  IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {\n    var _a;\n\n    var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);\n\n    var transposed = this.getCoordinate().isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var dir = this.getLabelValueDir(labelCfg.mappingData);\n    return __assign(__assign({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));\n  };\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n\n\n  IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var theme = geometry.theme; // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? {\n      offset: 0\n    } : {}, labelCfg);\n  };\n\n  IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var shapePoints = mappingData.points;\n    var point0 = coordinate.convert(shapePoints[0]);\n    var point2 = coordinate.convert(shapePoints[2]);\n    var dir = this.getLabelValueDir(mappingData);\n    var top;\n    var right;\n    var bottom;\n    var left;\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n\n      if (nextPoints) {\n        // 非漏斗图底部\n        var p0 = coordinate.convert(points[0]);\n        var p1 = coordinate.convert(points[1]);\n        var nextP0 = coordinate.convert(nextPoints[0]);\n        var nextP1 = coordinate.convert(nextPoints[1]); // TODO: 使用包围盒的计算方法\n\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  return IntervalLabel;\n}(GeometryLabel);\n\nexport default IntervalLabel;","map":{"version":3,"sources":["../../../src/geometry/label/interval.ts"],"names":[],"mappings":"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","sourcesContent":["import { get, deepMix, isArray } from '@antv/util';\nimport { Writeable } from '../../util/types';\nimport { MappingDatum, Point } from '../../interface';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelPointCfg } from './interface';\n\n/**\n * 柱状图 label\n */\nexport default class IntervalLabel extends GeometryLabel {\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n  private getLabelValueDir(mappingData: MappingDatum) {\n    // points 中的 x/y 和 transpose 无关\n    const dim = 'y';\n    const { points } = mappingData;\n\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  }\n\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number) {\n    const point = super.getLabelOffsetPoint(labelCfg, index, total);\n    const transposed = this.getCoordinate().isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const dir = this.getLabelValueDir(labelCfg.mappingData);\n\n    return {\n      ...point,\n      [dim]: point[dim] * dir,\n    };\n  }\n\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { theme } = geometry;\n\n    // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? { offset: 0 } : {}, labelCfg);\n  }\n\n  protected setLabelPosition(\n    labelPointCfg: Writeable<LabelPointCfg>,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const shapePoints = mappingData.points as Point[];\n    const point0 = coordinate.convert(shapePoints[0]);\n    const point2 = coordinate.convert(shapePoints[2]);\n    const dir = this.getLabelValueDir(mappingData);\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const p0 = coordinate.convert(points[0] as Point);\n        const p1 = coordinate.convert(points[1] as Point);\n        const nextP0 = coordinate.convert(nextPoints[0] as Point);\n        const nextP1 = coordinate.convert(nextPoints[1] as Point);\n\n        // TODO: 使用包围盒的计算方法\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      default:\n        break;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}