{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { AbstractCanvas } from '@antv/g-base';\nimport { getShape } from './util/hit';\nimport * as Shape from './shape';\nimport Group from './group';\nimport { each, getPixelRatio, requestAnimationFrame, clearAnimationFrame } from './util/util';\nimport { applyAttrsToContext, drawChildren, getMergedRegion, mergeView, checkRefresh, clearChanged } from './util/draw';\n\nvar Canvas =\n/** @class */\nfunction (_super) {\n  __extends(Canvas, _super);\n\n  function Canvas() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Canvas.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this); // 设置渲染引擎为 canvas，只读属性\n\n\n    cfg['renderer'] = 'canvas'; // 是否自动绘制，不需要用户调用 draw 方法\n\n    cfg['autoDraw'] = true; // 是否允许局部刷新图表\n\n    cfg['localRefresh'] = true;\n    cfg['refreshElements'] = []; // 是否在视图内自动裁剪\n\n    cfg['clipView'] = true; // 是否使用快速拾取的方案，默认为 false，上层可以打开\n\n    cfg['quickHit'] = false;\n    return cfg;\n  };\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n\n\n  Canvas.prototype.onCanvasChange = function (changeType) {\n    /**\n     * 触发画布更新的三种 changeType\n     * 1. attr: 修改画布的绘图属性\n     * 2. sort: 画布排序，图形的层次会发生变化\n     * 3. changeSize: 改变画布大小\n     */\n    if (changeType === 'attr' || changeType === 'sort' || changeType === 'changeSize') {\n      this.set('refreshElements', [this]);\n      this.draw();\n    }\n  };\n\n  Canvas.prototype.getShapeBase = function () {\n    return Shape;\n  };\n\n  Canvas.prototype.getGroupBase = function () {\n    return Group;\n  };\n  /**\n   * 获取屏幕像素比\n   */\n\n\n  Canvas.prototype.getPixelRatio = function () {\n    var pixelRatio = this.get('pixelRatio') || getPixelRatio(); // 不足 1 的取 1，超出 1 的取整\n\n    return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;\n  };\n\n  Canvas.prototype.getViewRange = function () {\n    return {\n      minX: 0,\n      minY: 0,\n      maxX: this.cfg.width,\n      maxY: this.cfg.height\n    };\n  }; // 复写基类的方法生成标签\n\n\n  Canvas.prototype.createDom = function () {\n    var element = document.createElement('canvas');\n    var context = element.getContext('2d'); // 缓存 context 对象\n\n    this.set('context', context);\n    return element;\n  };\n\n  Canvas.prototype.setDOMSize = function (width, height) {\n    _super.prototype.setDOMSize.call(this, width, height);\n\n    var context = this.get('context');\n    var el = this.get('el');\n    var pixelRatio = this.getPixelRatio();\n    el.width = pixelRatio * width;\n    el.height = pixelRatio * height; // 设置 canvas 元素的宽度和高度，会重置缩放，因此 context.scale 需要在每次设置宽、高后调用\n\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n  }; // 复写基类方法\n\n\n  Canvas.prototype.clear = function () {\n    _super.prototype.clear.call(this);\n\n    this._clearFrame(); // 需要清理掉延迟绘制的帧\n\n\n    var context = this.get('context');\n    var element = this.get('el');\n    context.clearRect(0, 0, element.width, element.height);\n  };\n\n  Canvas.prototype.getShape = function (x, y) {\n    var shape;\n\n    if (this.get('quickHit')) {\n      shape = getShape(this, x, y);\n    } else {\n      shape = _super.prototype.getShape.call(this, x, y, null);\n    }\n\n    return shape;\n  }; // 对绘制区域边缘取整，避免浮点数问题\n\n\n  Canvas.prototype._getRefreshRegion = function () {\n    var elements = this.get('refreshElements');\n    var viewRegion = this.getViewRange();\n    var region; // 如果是当前画布整体发生了变化，则直接重绘整个画布\n\n    if (elements.length && elements[0] === this) {\n      region = viewRegion;\n    } else {\n      region = getMergedRegion(elements);\n\n      if (region) {\n        region.minX = Math.floor(region.minX);\n        region.minY = Math.floor(region.minY);\n        region.maxX = Math.ceil(region.maxX);\n        region.maxY = Math.ceil(region.maxY);\n        region.maxY += 1; // 在很多环境下字体的高低会不一致，附加一像素，避免残影\n\n        var clipView = this.get('clipView'); // 自动裁剪不在 view 内的区域\n\n        if (clipView) {\n          region = mergeView(region, viewRegion);\n        }\n      }\n    }\n\n    return region;\n  };\n  /**\n   * 刷新图形元素，这里仅仅是放入队列，下次绘制时进行绘制\n   * @param {IElement} element 图形元素\n   */\n\n\n  Canvas.prototype.refreshElement = function (element) {\n    var refreshElements = this.get('refreshElements');\n    refreshElements.push(element); // if (this.get('autoDraw')) {\n    //   this._startDraw();\n    // }\n  }; // 清理还在进行的绘制\n\n\n  Canvas.prototype._clearFrame = function () {\n    var drawFrame = this.get('drawFrame');\n\n    if (drawFrame) {\n      // 如果全部渲染时，存在局部渲染，则抛弃掉局部渲染\n      clearAnimationFrame(drawFrame);\n      this.set('drawFrame', null);\n      this.set('refreshElements', []);\n    }\n  }; // 手工调用绘制接口\n\n\n  Canvas.prototype.draw = function () {\n    var drawFrame = this.get('drawFrame');\n\n    if (this.get('autoDraw') && drawFrame) {\n      return;\n    }\n\n    this._startDraw();\n  }; // 绘制所有图形\n\n\n  Canvas.prototype._drawAll = function () {\n    var context = this.get('context');\n    var element = this.get('el');\n    var children = this.getChildren();\n    context.clearRect(0, 0, element.width, element.height);\n    applyAttrsToContext(context, this);\n    drawChildren(context, children); // 对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也会记录更新的元素队列，因此全局渲染完后也需要置空\n\n    this.set('refreshElements', []);\n  }; // 绘制局部\n\n\n  Canvas.prototype._drawRegion = function () {\n    var context = this.get('context');\n    var refreshElements = this.get('refreshElements');\n    var children = this.getChildren();\n\n    var region = this._getRefreshRegion(); // 需要注意可能没有 region 的场景\n    // 一般发生在设置了 localRefresh ,在没有图形发生变化的情况下，用户调用了 draw\n\n\n    if (region) {\n      // 清理指定区域\n      context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY); // 保存上下文，设置 clip\n\n      context.save();\n      context.beginPath();\n      context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\n      context.clip();\n      applyAttrsToContext(context, this); // 确认更新的元素，这个优化可以提升 10 倍左右的性能，10W 个带有 group 的节点，局部渲染会从 90ms 下降到 5-6 ms\n\n      checkRefresh(this, children, region); // 绘制子元素\n\n      drawChildren(context, children, region);\n      context.restore();\n    } else if (refreshElements.length) {\n      // 防止发生改变的 elements 没有 region 的场景，这会发生在多个情况下\n      // 1. 空的 group\n      // 2. 所有 elements 没有在绘图区域\n      // 3. group 下面的 elements 隐藏掉\n      // 如果不进行清理 hasChanged 的状态会不正确\n      clearChanged(refreshElements);\n    }\n\n    each(refreshElements, function (element) {\n      if (element.get('hasChanged')) {\n        // 在视窗外的 Group 元素会加入到更新队列里，但实际却没有执行 draw() 逻辑，也就没有清除 hasChanged 标记\n        // 即已经重绘完、但 hasChanged 标记没有清除的元素，需要统一清除掉。主要是 Group 存在问题，具体原因待排查\n        element.set('hasChanged', false);\n      }\n    });\n    this.set('refreshElements', []);\n  }; // 触发绘制\n\n\n  Canvas.prototype._startDraw = function () {\n    var _this = this;\n\n    var drawFrame = this.get('drawFrame');\n\n    if (!drawFrame) {\n      drawFrame = requestAnimationFrame(function () {\n        if (_this.get('localRefresh')) {\n          _this._drawRegion();\n        } else {\n          _this._drawAll();\n        }\n\n        _this.set('drawFrame', null);\n      });\n      this.set('drawFrame', drawFrame);\n    }\n  };\n\n  Canvas.prototype.skipDraw = function () {};\n\n  Canvas.prototype.removeDom = function () {\n    var el = this.get('el'); // 需要清理 canvas 画布内容，否则ios下 创建的canvas垃圾未回收，导致Total canvas memory use exceeds问题\n    // 相关问题列表\n    // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12\n    // https://github.com/openlayers/openlayers/issues/9291\n\n    el.width = 0;\n    el.height = 0;\n    el.parentNode.removeChild(el);\n  };\n\n  return Canvas;\n}(AbstractCanvas);\n\nexport default Canvas;","map":{"version":3,"sources":["../src/canvas.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { AbstractCanvas } from '@antv/g-base';\nimport { getShape } from './util/hit';\nimport * as Shape from './shape';\nimport Group from './group';\nimport { each, getPixelRatio, requestAnimationFrame, clearAnimationFrame } from './util/util';\nimport { applyAttrsToContext, drawChildren, getMergedRegion, mergeView, checkRefresh, clearChanged } from './util/draw';\nvar Canvas = /** @class */ (function (_super) {\n    __extends(Canvas, _super);\n    function Canvas() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Canvas.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        // 设置渲染引擎为 canvas，只读属性\n        cfg['renderer'] = 'canvas';\n        // 是否自动绘制，不需要用户调用 draw 方法\n        cfg['autoDraw'] = true;\n        // 是否允许局部刷新图表\n        cfg['localRefresh'] = true;\n        cfg['refreshElements'] = [];\n        // 是否在视图内自动裁剪\n        cfg['clipView'] = true;\n        // 是否使用快速拾取的方案，默认为 false，上层可以打开\n        cfg['quickHit'] = false;\n        return cfg;\n    };\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    Canvas.prototype.onCanvasChange = function (changeType) {\n        /**\n         * 触发画布更新的三种 changeType\n         * 1. attr: 修改画布的绘图属性\n         * 2. sort: 画布排序，图形的层次会发生变化\n         * 3. changeSize: 改变画布大小\n         */\n        if (changeType === 'attr' || changeType === 'sort' || changeType === 'changeSize') {\n            this.set('refreshElements', [this]);\n            this.draw();\n        }\n    };\n    Canvas.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    Canvas.prototype.getGroupBase = function () {\n        return Group;\n    };\n    /**\n     * 获取屏幕像素比\n     */\n    Canvas.prototype.getPixelRatio = function () {\n        var pixelRatio = this.get('pixelRatio') || getPixelRatio();\n        // 不足 1 的取 1，超出 1 的取整\n        return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;\n    };\n    Canvas.prototype.getViewRange = function () {\n        return {\n            minX: 0,\n            minY: 0,\n            maxX: this.cfg.width,\n            maxY: this.cfg.height,\n        };\n    };\n    // 复写基类的方法生成标签\n    Canvas.prototype.createDom = function () {\n        var element = document.createElement('canvas');\n        var context = element.getContext('2d');\n        // 缓存 context 对象\n        this.set('context', context);\n        return element;\n    };\n    Canvas.prototype.setDOMSize = function (width, height) {\n        _super.prototype.setDOMSize.call(this, width, height);\n        var context = this.get('context');\n        var el = this.get('el');\n        var pixelRatio = this.getPixelRatio();\n        el.width = pixelRatio * width;\n        el.height = pixelRatio * height;\n        // 设置 canvas 元素的宽度和高度，会重置缩放，因此 context.scale 需要在每次设置宽、高后调用\n        if (pixelRatio > 1) {\n            context.scale(pixelRatio, pixelRatio);\n        }\n    };\n    // 复写基类方法\n    Canvas.prototype.clear = function () {\n        _super.prototype.clear.call(this);\n        this._clearFrame(); // 需要清理掉延迟绘制的帧\n        var context = this.get('context');\n        var element = this.get('el');\n        context.clearRect(0, 0, element.width, element.height);\n    };\n    Canvas.prototype.getShape = function (x, y) {\n        var shape;\n        if (this.get('quickHit')) {\n            shape = getShape(this, x, y);\n        }\n        else {\n            shape = _super.prototype.getShape.call(this, x, y, null);\n        }\n        return shape;\n    };\n    // 对绘制区域边缘取整，避免浮点数问题\n    Canvas.prototype._getRefreshRegion = function () {\n        var elements = this.get('refreshElements');\n        var viewRegion = this.getViewRange();\n        var region;\n        // 如果是当前画布整体发生了变化，则直接重绘整个画布\n        if (elements.length && elements[0] === this) {\n            region = viewRegion;\n        }\n        else {\n            region = getMergedRegion(elements);\n            if (region) {\n                region.minX = Math.floor(region.minX);\n                region.minY = Math.floor(region.minY);\n                region.maxX = Math.ceil(region.maxX);\n                region.maxY = Math.ceil(region.maxY);\n                region.maxY += 1; // 在很多环境下字体的高低会不一致，附加一像素，避免残影\n                var clipView = this.get('clipView');\n                // 自动裁剪不在 view 内的区域\n                if (clipView) {\n                    region = mergeView(region, viewRegion);\n                }\n            }\n        }\n        return region;\n    };\n    /**\n     * 刷新图形元素，这里仅仅是放入队列，下次绘制时进行绘制\n     * @param {IElement} element 图形元素\n     */\n    Canvas.prototype.refreshElement = function (element) {\n        var refreshElements = this.get('refreshElements');\n        refreshElements.push(element);\n        // if (this.get('autoDraw')) {\n        //   this._startDraw();\n        // }\n    };\n    // 清理还在进行的绘制\n    Canvas.prototype._clearFrame = function () {\n        var drawFrame = this.get('drawFrame');\n        if (drawFrame) {\n            // 如果全部渲染时，存在局部渲染，则抛弃掉局部渲染\n            clearAnimationFrame(drawFrame);\n            this.set('drawFrame', null);\n            this.set('refreshElements', []);\n        }\n    };\n    // 手工调用绘制接口\n    Canvas.prototype.draw = function () {\n        var drawFrame = this.get('drawFrame');\n        if (this.get('autoDraw') && drawFrame) {\n            return;\n        }\n        this._startDraw();\n    };\n    // 绘制所有图形\n    Canvas.prototype._drawAll = function () {\n        var context = this.get('context');\n        var element = this.get('el');\n        var children = this.getChildren();\n        context.clearRect(0, 0, element.width, element.height);\n        applyAttrsToContext(context, this);\n        drawChildren(context, children);\n        // 对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也会记录更新的元素队列，因此全局渲染完后也需要置空\n        this.set('refreshElements', []);\n    };\n    // 绘制局部\n    Canvas.prototype._drawRegion = function () {\n        var context = this.get('context');\n        var refreshElements = this.get('refreshElements');\n        var children = this.getChildren();\n        var region = this._getRefreshRegion();\n        // 需要注意可能没有 region 的场景\n        // 一般发生在设置了 localRefresh ,在没有图形发生变化的情况下，用户调用了 draw\n        if (region) {\n            // 清理指定区域\n            context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\n            // 保存上下文，设置 clip\n            context.save();\n            context.beginPath();\n            context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\n            context.clip();\n            applyAttrsToContext(context, this);\n            // 确认更新的元素，这个优化可以提升 10 倍左右的性能，10W 个带有 group 的节点，局部渲染会从 90ms 下降到 5-6 ms\n            checkRefresh(this, children, region);\n            // 绘制子元素\n            drawChildren(context, children, region);\n            context.restore();\n        }\n        else if (refreshElements.length) {\n            // 防止发生改变的 elements 没有 region 的场景，这会发生在多个情况下\n            // 1. 空的 group\n            // 2. 所有 elements 没有在绘图区域\n            // 3. group 下面的 elements 隐藏掉\n            // 如果不进行清理 hasChanged 的状态会不正确\n            clearChanged(refreshElements);\n        }\n        each(refreshElements, function (element) {\n            if (element.get('hasChanged')) {\n                // 在视窗外的 Group 元素会加入到更新队列里，但实际却没有执行 draw() 逻辑，也就没有清除 hasChanged 标记\n                // 即已经重绘完、但 hasChanged 标记没有清除的元素，需要统一清除掉。主要是 Group 存在问题，具体原因待排查\n                element.set('hasChanged', false);\n            }\n        });\n        this.set('refreshElements', []);\n    };\n    // 触发绘制\n    Canvas.prototype._startDraw = function () {\n        var _this = this;\n        var drawFrame = this.get('drawFrame');\n        if (!drawFrame) {\n            drawFrame = requestAnimationFrame(function () {\n                if (_this.get('localRefresh')) {\n                    _this._drawRegion();\n                }\n                else {\n                    _this._drawAll();\n                }\n                _this.set('drawFrame', null);\n            });\n            this.set('drawFrame', drawFrame);\n        }\n    };\n    Canvas.prototype.skipDraw = function () { };\n    Canvas.prototype.removeDom = function () {\n        var el = this.get('el');\n        // 需要清理 canvas 画布内容，否则ios下 创建的canvas垃圾未回收，导致Total canvas memory use exceeds问题\n        // 相关问题列表\n        // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12\n        // https://github.com/openlayers/openlayers/issues/9291\n        el.width = 0;\n        el.height = 0;\n        el.parentNode.removeChild(el);\n    };\n    return Canvas;\n}(AbstractCanvas));\nexport default Canvas;\n//# sourceMappingURL=canvas.js.map"]},"metadata":{},"sourceType":"module"}