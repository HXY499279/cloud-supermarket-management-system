{"ast":null,"code":"import { isObject, each, get, groupBy, isNil, filter } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { antiCollision } from './util';\n/** label text和line距离 4px */\n\nvar MARGIN = 4;\n/**\n * 配置 labelline\n * @param item PolarLabelItem\n */\n\nfunction drawLabelline(item\n/** PolarLabelItem */\n, coordinate) {\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n\n  var radius = coordinate.getRadius();\n\n  if (item && item.labelLine) {\n    var angle = item.angle,\n        labelOffset = item.offset; // 贴近圆周\n\n    var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n    var itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);\n    var itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);\n    var endPoint = {\n      x: itemX - Math.cos(angle) * MARGIN,\n      y: itemY - Math.sin(angle) * MARGIN\n    };\n    var smoothConnector = item.labelLine.smooth;\n    var path = [];\n    var dx = endPoint.x - center.x;\n    var dy = endPoint.y - center.y;\n    var endAngle = Math.atan(dy / dx); // 第三象限 & 第四象限\n\n    if (dx < 0) {\n      endAngle += Math.PI;\n    } // 默认 smooth, undefined 也为 smooth\n\n\n    if (smoothConnector === false) {\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      } // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针\n\n\n      var sweepFlag = 0; // 第一象限\n\n      if (angle < 0 && angle > -Math.PI / 2 || angle > Math.PI * 1.5) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      } // 第二象限\n\n\n      if (angle >= 0 && angle < Math.PI / 2) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      } // 第三象限\n\n\n      if (angle >= Math.PI / 2 && angle < Math.PI) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      } // 第四象限\n\n\n      if (angle < -Math.PI / 2 || angle >= Math.PI && angle < Math.PI * 1.5) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      var distance = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);\n      var breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle); // 圆弧的结束点\n\n      var breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);\n      /**\n       * @example\n       * M 100 100 L100 90 A 50 50 0 0 0 150 50\n       * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);\n       * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角\n       * 第 5 个参数: 是否顺时针绘制\n       */\n      // 默认小弧\n\n      var largeArcFlag = 0; // step1: 移动至起点\n\n      path.push(\"M \" + startPoint.x + \" \" + startPoint.y); // step2: 连接拐点\n\n      path.push(\"L \" + breakPoint.x + \" \" + breakPoint.y); // step3: 绘制圆弧 至 结束点\n\n      path.push(\"A \" + center.x + \" \" + center.y + \" 0 \" + largeArcFlag + \" \" + sweepFlag + \" \" + breakPoint3.x + \" \" + breakPoint3.y); // step4: 连接结束点\n\n      path.push(\"L \" + endPoint.x + \" \" + endPoint.y);\n    } else {\n      var breakPoint = polarToCartesian(center.x, center.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle); // G2 旧的拉线\n      // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);\n\n      var xSign = startPoint.x < center.x ? 1 : -1; // step1: 连接结束点\n\n      path.push(\"M \" + endPoint.x + \" \" + endPoint.y);\n      var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);\n      var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);\n\n      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {\n        // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)\n        path.push.apply(path, ['C', endPoint.x + xSign * 4, endPoint.y, 2 * breakPoint.x - startPoint.x, 2 * breakPoint.y - startPoint.y, startPoint.x, startPoint.y]);\n      } // step3: 连接至起点\n\n\n      path.push(\"L \" + startPoint.x + \" \" + startPoint.y);\n    }\n\n    item.labelLine.path = path.join(' ');\n  }\n}\n/**\n * 饼图 outer-label 布局, 适用于 type = pie 且 label offset > 0 的标签\n */\n\n\nexport function pieOuterLabelLayout(originalItems, labels, shapes, region) {\n  var items = filter(originalItems, function (item) {\n    return !isNil(item);\n  });\n  /** 坐标系 */\n\n  var coordinate = labels[0] && labels[0].get('coordinate');\n\n  if (!coordinate) {\n    return;\n  }\n  /** 坐标圆心 */\n\n\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n\n  var radius = coordinate.getRadius();\n  /** label shapes */\n\n  var labelsMap = {};\n\n  for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {\n    var labelShape = labels_1[_i];\n    labelsMap[labelShape.get('id')] = labelShape;\n  } // note labelHeight 可以控制 label 的行高\n\n\n  var labelHeight = get(items[0], 'labelHeight', 14);\n  var labelOffset = get(items[0], 'offset', 0);\n\n  if (labelOffset <= 0) {\n    return;\n  }\n\n  var LEFT_HALF_KEY = 'left';\n  var RIGHT_HALF_KEY = 'right'; // step 1: separate labels\n\n  var separateLabels = groupBy(items, function (item) {\n    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;\n  });\n  var start = coordinate.start,\n      end = coordinate.end; // step2: calculate totalHeight\n\n  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());\n  var totalR = totalHeight / 2;\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n\n  var labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalR,\n    maxY: center.y + totalR\n  }; // step 3: antiCollision\n\n  each(separateLabels, function (half, key) {\n    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);\n\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort(function (a, b) {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n      each(half, function (labelItem, idx) {\n        if (idx + 1 > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n  each(separateLabels, function (half, key) {\n    each(half, function (item) {\n      var isRight = key === RIGHT_HALF_KEY;\n      var labelShape = labelsMap[item.id]; // because group could not effect content-shape, should set content-shape position manually\n\n      var content = labelShape.getChildByIndex(0); // textShape 发生过调整\n\n      if (content) {\n        var r = radius + labelOffset; // (x - cx)^2 + (y - cy)^2 = totalR^2\n\n        var dy = item.y - center.y;\n        var rPow2 = Math.pow(r, 2);\n        var dyPow2 = Math.pow(dy, 2);\n        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;\n        var dx = Math.sqrt(dxPow2);\n        var dx_offset = Math.abs(Math.cos(item.angle) * r);\n\n        if (!isRight) {\n          // left\n          item.x = center.x - Math.max(dx, dx_offset);\n        } else {\n          // right\n          item.x = center.x + Math.max(dx, dx_offset);\n        }\n      } // adjust labelShape\n\n\n      if (content) {\n        content.attr('y', item.y);\n        content.attr('x', item.x);\n      }\n\n      drawLabelline(item, coordinate);\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/geometry/label/layout/pie/outer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { BBox, IGroup, IShape, IElement } from '@antv/g-base';\nimport { isObject, each, get, groupBy, isNil, filter } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\n\n/** label text和line距离 4px */\nconst MARGIN = 4;\n\n/**\n * 配置 labelline\n * @param item PolarLabelItem\n */\nfunction drawLabelline(item: any /** PolarLabelItem */, coordinate: Coordinate) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n\n  if (item && item.labelLine) {\n    const { angle, offset: labelOffset } = item;\n    // 贴近圆周\n    const startPoint = polarToCartesian(center.x, center.y, radius, angle);\n    const itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);\n    const itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);\n\n    const endPoint = {\n      x: itemX - Math.cos(angle) * MARGIN,\n      y: itemY - Math.sin(angle) * MARGIN,\n    };\n\n    const smoothConnector = item.labelLine.smooth;\n    const path = [];\n    const dx = endPoint.x - center.x;\n    const dy = endPoint.y - center.y;\n    let endAngle = Math.atan(dy / dx);\n    // 第三象限 & 第四象限\n    if (dx < 0) {\n      endAngle += Math.PI;\n    }\n\n    // 默认 smooth, undefined 也为 smooth\n    if (smoothConnector === false) {\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      }\n\n      // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针\n      let sweepFlag = 0;\n\n      // 第一象限\n      if ((angle < 0 && angle > -Math.PI / 2) || angle > Math.PI * 1.5) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第二象限\n      if (angle >= 0 && angle < Math.PI / 2) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第三象限\n      if (angle >= Math.PI / 2 && angle < Math.PI) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第四象限\n      if (angle < -Math.PI / 2 || (angle >= Math.PI && angle < Math.PI * 1.5)) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      const distance = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);\n      const breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle);\n      // 圆弧的结束点\n      const breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);\n\n      /**\n       * @example\n       * M 100 100 L100 90 A 50 50 0 0 0 150 50\n       * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);\n       * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角\n       * 第 5 个参数: 是否顺时针绘制\n       */\n      // 默认小弧\n      const largeArcFlag = 0;\n      // step1: 移动至起点\n      path.push(`M ${startPoint.x} ${startPoint.y}`);\n      // step2: 连接拐点\n      path.push(`L ${breakPoint.x} ${breakPoint.y}`);\n      // step3: 绘制圆弧 至 结束点\n      path.push(`A ${center.x} ${center.y} 0 ${largeArcFlag} ${sweepFlag} ${breakPoint3.x} ${breakPoint3.y}`);\n      // step4: 连接结束点\n      path.push(`L ${endPoint.x} ${endPoint.y}`);\n    } else {\n      const breakPoint = polarToCartesian(\n        center.x,\n        center.y,\n        radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)),\n        angle\n      );\n      // G2 旧的拉线\n      // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);\n      const xSign = startPoint.x < center.x ? 1 : -1;\n      // step1: 连接结束点\n      path.push(`M ${endPoint.x} ${endPoint.y}`);\n      const slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);\n      const slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);\n      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {\n        // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)\n        path.push(\n          ...[\n            'C',\n            endPoint.x + xSign * 4,\n            endPoint.y,\n            2 * breakPoint.x - startPoint.x,\n            2 * breakPoint.y - startPoint.y,\n            startPoint.x,\n            startPoint.y,\n          ]\n        );\n      }\n      // step3: 连接至起点\n      path.push(`L ${startPoint.x} ${startPoint.y}`);\n    }\n    item.labelLine.path = path.join(' ');\n  }\n}\n\n/**\n * 饼图 outer-label 布局, 适用于 type = pie 且 label offset > 0 的标签\n */\nexport function pieOuterLabelLayout(\n  originalItems: PolarLabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox\n) {\n  const items = filter(originalItems, (item) => !isNil(item));\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  // note labelHeight 可以控制 label 的行高\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = get(items[0], 'offset', 0);\n\n  if (labelOffset <= 0) {\n    return;\n  }\n\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const separateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  const { start, end } = coordinate;\n  // step2: calculate totalHeight\n  const totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());\n  const totalR = totalHeight / 2;\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalR,\n    maxY: center.y + totalR,\n  };\n\n  // step 3: antiCollision\n  each(separateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx + 1 > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  each(separateLabels, (half: PolarLabelItem[], key: string) => {\n    each(half, (item: PolarLabelItem) => {\n      const isRight = key === RIGHT_HALF_KEY;\n      const labelShape = labelsMap[item.id];\n\n      // because group could not effect content-shape, should set content-shape position manually\n      const content = labelShape.getChildByIndex(0) as IElement;\n\n      // textShape 发生过调整\n      if (content) {\n        const r = radius + labelOffset;\n        // (x - cx)^2 + (y - cy)^2 = totalR^2\n        const dy = item.y - center.y;\n\n        const rPow2 = Math.pow(r, 2);\n        const dyPow2 = Math.pow(dy, 2);\n        const dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;\n        const dx = Math.sqrt(dxPow2);\n\n        const dx_offset = Math.abs(Math.cos(item.angle) * r);\n        if (!isRight) {\n          // left\n          item.x = center.x - Math.max(dx, dx_offset);\n        } else {\n          // right\n          item.x = center.x + Math.max(dx, dx_offset);\n        }\n      }\n\n      // adjust labelShape\n      if (content) {\n        content.attr('y', item.y);\n        content.attr('x', item.x);\n      }\n\n      drawLabelline(item, coordinate);\n    });\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}