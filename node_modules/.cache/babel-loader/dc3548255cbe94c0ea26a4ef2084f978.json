{"ast":null,"code":"/**\n * @file utils of label\n */\nimport { isNil, isNumber, some } from '@antv/util';\nimport { rotate } from '../../../util/transform';\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\n\nexport function findLabelTextShape(label) {\n  return label.find(function (el) {\n    return el.get('type') === 'text';\n  });\n}\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\n\nexport function getlLabelBackgroundInfo(labelGroup, labelItem, padding) {\n  if (padding === void 0) {\n    padding = [0, 0, 0, 0];\n  }\n\n  var content = labelGroup.getChildren()[0];\n\n  if (content) {\n    var labelShape = content.clone(); // revert rotate\n\n    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {\n      rotate(labelShape, -labelItem.rotate);\n    } // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n\n\n    var _a = labelShape.getCanvasBBox(),\n        x = _a.x,\n        y = _a.y,\n        width = _a.width,\n        height = _a.height;\n\n    labelShape.destroy();\n    var boxPadding = padding;\n\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0\n    };\n  }\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\n\nexport function getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/** 检测是否和已布局的堆叠 */\n\nexport function checkShapeOverlap(cur, dones) {\n  var box = cur.getBBox();\n  return some(dones, function (done) {\n    var target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}","map":{"version":3,"sources":["../../../../src/geometry/label/util/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @file utils of label\n */\n\nimport { isNil, isNumber, some } from '@antv/util';\nimport { IElement, IGroup, BBox } from '../../../dependents';\nimport { rotate } from '../../../util/transform';\nimport { LabelItem } from '../interface';\n\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label: IGroup): IElement {\n  return label.find((el) => el.get('type') === 'text');\n}\n\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getlLabelBackgroundInfo(\n  labelGroup: IGroup,\n  labelItem: LabelItem,\n  padding: number | number[] = [0, 0, 0, 0]\n): { x: number; y: number; width: number; height: number; rotation: number } {\n  const content = labelGroup.getChildren()[0];\n  if (content) {\n    const labelShape = content.clone();\n\n    // revert rotate\n    if (labelItem?.rotate) {\n      rotate(labelShape as IGroup, -labelItem.rotate);\n    }\n\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    const { x, y, width, height } = labelShape.getCanvasBBox();\n\n    labelShape.destroy();\n\n    let boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: labelItem?.rotate || 0,\n    };\n  }\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur: IElement, dones: IElement[]) {\n  const box = cur.getBBox();\n  return some(dones, (done) => {\n    const target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}