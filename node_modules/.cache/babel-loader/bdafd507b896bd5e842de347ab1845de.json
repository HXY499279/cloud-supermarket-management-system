{"ast":null,"code":"import { Quad as QuadUtil, Cubic as CubicUtil, Arc as EllipseArcUtil } from '@antv/g-math';\nimport { path2Segments } from '@antv/path-util';\nimport { isNumberEqual, max, min } from '@antv/util';\nimport { mergeArrowBBox } from './util';\n\nfunction getPathBox(segments, lineWidth) {\n  var xArr = [];\n  var yArr = [];\n  var segmentsWithAngle = [];\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var currentPoint = segment.currentPoint,\n        params = segment.params,\n        prePoint = segment.prePoint;\n    var box = void 0;\n\n    switch (segment.command) {\n      case 'Q':\n        box = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);\n        break;\n\n      case 'C':\n        box = CubicUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);\n        break;\n\n      case 'A':\n        var arcParams = segment.arcParams;\n        box = EllipseArcUtil.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);\n        break;\n\n      default:\n        xArr.push(currentPoint[0]);\n        yArr.push(currentPoint[1]);\n        break;\n    }\n\n    if (box) {\n      segment.box = box;\n      xArr.push(box.x, box.x + box.width);\n      yArr.push(box.y, box.y + box.height);\n    }\n\n    if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {\n      segmentsWithAngle.push(segment);\n    }\n  } // bbox calculation should ignore NaN for path attribute\n  // ref: https://github.com/antvis/g/issues/210\n\n\n  xArr = xArr.filter(function (item) {\n    return !Number.isNaN(item);\n  });\n  yArr = yArr.filter(function (item) {\n    return !Number.isNaN(item);\n  });\n  var minX = min(xArr);\n  var minY = min(yArr);\n  var maxX = max(xArr);\n  var maxY = max(yArr);\n\n  if (segmentsWithAngle.length === 0) {\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n\n  for (var i = 0; i < segmentsWithAngle.length; i++) {\n    var segment = segmentsWithAngle[i];\n    var currentPoint = segment.currentPoint;\n    var extra = void 0;\n\n    if (currentPoint[0] === minX) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      minX = minX - extra.xExtra;\n    } else if (currentPoint[0] === maxX) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      maxX = maxX + extra.xExtra;\n    }\n\n    if (currentPoint[1] === minY) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      minY = minY - extra.yExtra;\n    } else if (currentPoint[1] === maxY) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      maxY = maxY + extra.yExtra;\n    }\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n\nfunction getExtraFromSegmentWithAngle(segment, lineWidth) {\n  var prePoint = segment.prePoint,\n      currentPoint = segment.currentPoint,\n      nextPoint = segment.nextPoint;\n  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);\n  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);\n  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2); // 以 currentPoint 为顶点的夹角\n\n  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext))); // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度\n  // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等\n\n  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {\n    return {\n      xExtra: 0,\n      yExtra: 0\n    };\n  }\n\n  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));\n  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1])); // 将夹角转为锐角\n\n  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;\n  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle; // 这里不考虑在水平和垂直方向的投影，直接使用最大差值\n  // 由于上层统一加减了二分之一线宽，这里需要进行弥补\n\n  var extra = {\n    // 水平方向投影\n    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\n    // 垂直方向投影\n    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0\n  };\n  return extra;\n}\n\nexport default function (shape) {\n  var attrs = shape.attr();\n  var path = attrs.path,\n      stroke = attrs.stroke;\n  var lineWidth = stroke ? attrs.lineWidth : 0; // 只有有 stroke 时，lineWidth 才生效\n\n  var segments = shape.get('segments') || path2Segments(path);\n\n  var _a = getPathBox(segments, lineWidth),\n      x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height;\n\n  var bbox = {\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height\n  };\n  bbox = mergeArrowBBox(shape, bbox);\n  return {\n    x: bbox.minX,\n    y: bbox.minY,\n    width: bbox.maxX - bbox.minX,\n    height: bbox.maxY - bbox.minY\n  };\n}","map":{"version":3,"sources":["../../src/bbox/path.ts"],"names":[],"mappings":"AAAA,SAAS,IAAI,IAAI,QAAjB,EAA2B,KAAK,IAAI,SAApC,EAA+C,GAAG,IAAI,cAAtD,QAA4E,cAA5E;AACA,SAAS,aAAT,QAA8B,iBAA9B;AACA,SAAS,aAAT,EAAwB,GAAxB,EAA6B,GAA7B,QAAwC,YAAxC;AAGA,SAAS,cAAT,QAA+B,QAA/B;;AAEA,SAAS,UAAT,CAAoB,QAApB,EAA8B,SAA9B,EAAuC;AACrC,MAAI,IAAI,GAAG,EAAX;AACA,MAAI,IAAI,GAAG,EAAX;AACA,MAAM,iBAAiB,GAAG,EAA1B;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACxC,QAAM,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAxB;AACQ,QAAA,YAAY,GAAuB,OAAO,CAA9B,YAAZ;AAAA,QAAc,MAAM,GAAe,OAAO,CAAtB,MAApB;AAAA,QAAsB,QAAQ,GAAK,OAAO,CAAZ,QAA9B;AACR,QAAI,GAAG,GAAA,KAAA,CAAP;;AACA,YAAQ,OAAO,CAAC,OAAhB;AACE,WAAK,GAAL;AACE,QAAA,GAAG,GAAG,QAAQ,CAAC,GAAT,CAAa,QAAQ,CAAC,CAAD,CAArB,EAA0B,QAAQ,CAAC,CAAD,CAAlC,EAAuC,MAAM,CAAC,CAAD,CAA7C,EAAkD,MAAM,CAAC,CAAD,CAAxD,EAA6D,MAAM,CAAC,CAAD,CAAnE,EAAwE,MAAM,CAAC,CAAD,CAA9E,CAAN;AACA;;AACF,WAAK,GAAL;AACE,QAAA,GAAG,GAAG,SAAS,CAAC,GAAV,CAAc,QAAQ,CAAC,CAAD,CAAtB,EAA2B,QAAQ,CAAC,CAAD,CAAnC,EAAwC,MAAM,CAAC,CAAD,CAA9C,EAAmD,MAAM,CAAC,CAAD,CAAzD,EAA8D,MAAM,CAAC,CAAD,CAApE,EAAyE,MAAM,CAAC,CAAD,CAA/E,EAAoF,MAAM,CAAC,CAAD,CAA1F,EAA+F,MAAM,CAAC,CAAD,CAArG,CAAN;AACA;;AACF,WAAK,GAAL;AACE,YAAM,SAAS,GAAG,OAAO,CAAC,SAA1B;AACA,QAAA,GAAG,GAAG,cAAc,CAAC,GAAf,CACJ,SAAS,CAAC,EADN,EAEJ,SAAS,CAAC,EAFN,EAGJ,SAAS,CAAC,EAHN,EAIJ,SAAS,CAAC,EAJN,EAKJ,SAAS,CAAC,SALN,EAMJ,SAAS,CAAC,UANN,EAOJ,SAAS,CAAC,QAPN,CAAN;AASA;;AACF;AACE,QAAA,IAAI,CAAC,IAAL,CAAU,YAAY,CAAC,CAAD,CAAtB;AACA,QAAA,IAAI,CAAC,IAAL,CAAU,YAAY,CAAC,CAAD,CAAtB;AACA;AAtBJ;;AAwBA,QAAI,GAAJ,EAAS;AACP,MAAA,OAAO,CAAC,GAAR,GAAc,GAAd;AACA,MAAA,IAAI,CAAC,IAAL,CAAU,GAAG,CAAC,CAAd,EAAiB,GAAG,CAAC,CAAJ,GAAQ,GAAG,CAAC,KAA7B;AACA,MAAA,IAAI,CAAC,IAAL,CAAU,GAAG,CAAC,CAAd,EAAiB,GAAG,CAAC,CAAJ,GAAQ,GAAG,CAAC,MAA7B;AACD;;AACD,QAAI,SAAS,KAAK,OAAO,CAAC,OAAR,KAAoB,GAApB,IAA2B,OAAO,CAAC,OAAR,KAAoB,GAApD,CAAT,IAAqE,OAAO,CAAC,QAA7E,IAAyF,OAAO,CAAC,SAArG,EAAgH;AAC9G,MAAA,iBAAiB,CAAC,IAAlB,CAAuB,OAAvB;AACD;AACF,GAxCoC,CAyCrC;AACA;;;AACA,EAAA,IAAI,GAAG,IAAI,CAAC,MAAL,CAAY,UAAC,IAAD,EAAK;AAAK,WAAA,CAAC,MAAM,CAAC,KAAP,CAAD,IAAC,CAAD;AAAmB,GAAzC,CAAP;AACA,EAAA,IAAI,GAAG,IAAI,CAAC,MAAL,CAAY,UAAC,IAAD,EAAK;AAAK,WAAA,CAAC,MAAM,CAAC,KAAP,CAAD,IAAC,CAAD;AAAmB,GAAzC,CAAP;AACA,MAAI,IAAI,GAAG,GAAG,CAAC,IAAD,CAAd;AACA,MAAI,IAAI,GAAG,GAAG,CAAC,IAAD,CAAd;AACA,MAAI,IAAI,GAAG,GAAG,CAAC,IAAD,CAAd;AACA,MAAI,IAAI,GAAG,GAAG,CAAC,IAAD,CAAd;;AACA,MAAI,iBAAiB,CAAC,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,WAAO;AACL,MAAA,CAAC,EAAE,IADE;AAEL,MAAA,CAAC,EAAE,IAFE;AAGL,MAAA,KAAK,EAAE,IAAI,GAAG,IAHT;AAIL,MAAA,MAAM,EAAE,IAAI,GAAG;AAJV,KAAP;AAMD;;AACD,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,iBAAiB,CAAC,MAAtC,EAA8C,CAAC,EAA/C,EAAmD;AACjD,QAAM,OAAO,GAAG,iBAAiB,CAAC,CAAD,CAAjC;AACQ,QAAA,YAAY,GAAK,OAAO,CAAZ,YAAZ;AACR,QAAI,KAAK,GAAA,KAAA,CAAT;;AACA,QAAI,YAAY,CAAC,CAAD,CAAZ,KAAoB,IAAxB,EAA8B;AAC5B,MAAA,KAAK,GAAG,4BAA4B,CAAC,OAAD,EAAU,SAAV,CAApC;AACA,MAAA,IAAI,GAAG,IAAI,GAAG,KAAK,CAAC,MAApB;AACD,KAHD,MAGO,IAAI,YAAY,CAAC,CAAD,CAAZ,KAAoB,IAAxB,EAA8B;AACnC,MAAA,KAAK,GAAG,4BAA4B,CAAC,OAAD,EAAU,SAAV,CAApC;AACA,MAAA,IAAI,GAAG,IAAI,GAAG,KAAK,CAAC,MAApB;AACD;;AACD,QAAI,YAAY,CAAC,CAAD,CAAZ,KAAoB,IAAxB,EAA8B;AAC5B,MAAA,KAAK,GAAG,4BAA4B,CAAC,OAAD,EAAU,SAAV,CAApC;AACA,MAAA,IAAI,GAAG,IAAI,GAAG,KAAK,CAAC,MAApB;AACD,KAHD,MAGO,IAAI,YAAY,CAAC,CAAD,CAAZ,KAAoB,IAAxB,EAA8B;AACnC,MAAA,KAAK,GAAG,4BAA4B,CAAC,OAAD,EAAU,SAAV,CAApC;AACA,MAAA,IAAI,GAAG,IAAI,GAAG,KAAK,CAAC,MAApB;AACD;AACF;;AACD,SAAO;AACL,IAAA,CAAC,EAAE,IADE;AAEL,IAAA,CAAC,EAAE,IAFE;AAGL,IAAA,KAAK,EAAE,IAAI,GAAG,IAHT;AAIL,IAAA,MAAM,EAAE,IAAI,GAAG;AAJV,GAAP;AAMD;;AAED,SAAS,4BAAT,CAAsC,OAAtC,EAA+C,SAA/C,EAAwD;AAC9C,MAAA,QAAQ,GAA8B,OAAO,CAArC,QAAR;AAAA,MAAU,YAAY,GAAgB,OAAO,CAAvB,YAAtB;AAAA,MAAwB,SAAS,GAAK,OAAO,CAAZ,SAAjC;AACR,MAAM,aAAa,GAAG,IAAI,CAAC,GAAL,CAAS,YAAY,CAAC,CAAD,CAAZ,GAAkB,QAAQ,CAAC,CAAD,CAAnC,EAAwC,CAAxC,IAA6C,IAAI,CAAC,GAAL,CAAS,YAAY,CAAC,CAAD,CAAZ,GAAkB,QAAQ,CAAC,CAAD,CAAnC,EAAwC,CAAxC,CAAnE;AACA,MAAM,cAAc,GAAG,IAAI,CAAC,GAAL,CAAS,YAAY,CAAC,CAAD,CAAZ,GAAkB,SAAS,CAAC,CAAD,CAApC,EAAyC,CAAzC,IAA8C,IAAI,CAAC,GAAL,CAAS,YAAY,CAAC,CAAD,CAAZ,GAAkB,SAAS,CAAC,CAAD,CAApC,EAAyC,CAAzC,CAArE;AACA,MAAM,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,QAAQ,CAAC,CAAD,CAAR,GAAc,SAAS,CAAC,CAAD,CAAhC,EAAqC,CAArC,IAA0C,IAAI,CAAC,GAAL,CAAS,QAAQ,CAAC,CAAD,CAAR,GAAc,SAAS,CAAC,CAAD,CAAhC,EAAqC,CAArC,CAA7D,CAJsD,CAKtD;;AACA,MAAM,YAAY,GAAG,IAAI,CAAC,IAAL,CACnB,CAAC,aAAa,GAAG,cAAhB,GAAiC,UAAlC,KAAiD,IAAI,IAAI,CAAC,IAAL,CAAU,aAAV,CAAJ,GAA+B,IAAI,CAAC,IAAL,CAAU,cAAV,CAAhF,CADmB,CAArB,CANsD,CAStD;AACA;;AACA,MAAI,CAAC,YAAD,IAAiB,IAAI,CAAC,GAAL,CAAS,YAAT,MAA2B,CAA5C,IAAiD,aAAa,CAAC,YAAD,EAAe,CAAf,CAAlE,EAAqF;AACnF,WAAO;AACL,MAAA,MAAM,EAAE,CADH;AAEL,MAAA,MAAM,EAAE;AAFH,KAAP;AAID;;AACD,MAAI,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,KAAL,CAAW,SAAS,CAAC,CAAD,CAAT,GAAe,YAAY,CAAC,CAAD,CAAtC,EAA2C,SAAS,CAAC,CAAD,CAAT,GAAe,YAAY,CAAC,CAAD,CAAtE,CAAT,CAAb;AACA,MAAI,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,KAAL,CAAW,SAAS,CAAC,CAAD,CAAT,GAAe,YAAY,CAAC,CAAD,CAAtC,EAA2C,SAAS,CAAC,CAAD,CAAT,GAAe,YAAY,CAAC,CAAD,CAAtE,CAAT,CAAb,CAlBsD,CAmBtD;;AACA,EAAA,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,EAAL,GAAU,CAAnB,GAAuB,IAAI,CAAC,EAAL,GAAU,MAAjC,GAA0C,MAAnD;AACA,EAAA,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,EAAL,GAAU,CAAnB,GAAuB,IAAI,CAAC,EAAL,GAAU,MAAjC,GAA0C,MAAnD,CArBsD,CAsBtD;AACA;;AACA,MAAM,KAAK,GAAG;AACZ;AACA,IAAA,MAAM,EACJ,IAAI,CAAC,GAAL,CAAS,YAAY,GAAG,CAAf,GAAmB,MAA5B,KAAwC,SAAS,GAAG,CAAb,IAAmB,IAAI,IAAI,CAAC,GAAL,CAAS,YAAY,GAAG,CAAxB,CAAvB,CAAvC,IAA6F,SAAS,GAAG,CAAzG,IAA8G,CAHpG;AAIZ;AACA,IAAA,MAAM,EACJ,IAAI,CAAC,GAAL,CAAS,MAAM,GAAG,YAAY,GAAG,CAAjC,KAAwC,SAAS,GAAG,CAAb,IAAmB,IAAI,IAAI,CAAC,GAAL,CAAS,YAAY,GAAG,CAAxB,CAAvB,CAAvC,IAA6F,SAAS,GAAG,CAAzG,IAA8G;AANpG,GAAd;AAQA,SAAO,KAAP;AACD;;AAED,eAAc,UAAW,KAAX,EAAwB;AACpC,MAAM,KAAK,GAAG,KAAK,CAAC,IAAN,EAAd;AACQ,MAAA,IAAI,GAAa,KAAK,CAAlB,IAAJ;AAAA,MAAM,MAAM,GAAK,KAAK,CAAV,MAAZ;AACR,MAAM,SAAS,GAAG,MAAM,GAAG,KAAK,CAAC,SAAT,GAAqB,CAA7C,CAHoC,CAGY;;AAChD,MAAM,QAAQ,GAAG,KAAK,CAAC,GAAN,CAAU,UAAV,KAAyB,aAAa,CAAC,IAAD,CAAvD;;AACM,MAAA,EAAA,GAA0B,UAAU,CAAC,QAAD,EAAW,SAAX,CAApC;AAAA,MAAE,CAAC,GAAA,EAAA,CAAA,CAAH;AAAA,MAAK,CAAC,GAAA,EAAA,CAAA,CAAN;AAAA,MAAQ,KAAK,GAAA,EAAA,CAAA,KAAb;AAAA,MAAe,MAAM,GAAA,EAAA,CAAA,MAArB;;AACN,MAAI,IAAI,GAAG;AACT,IAAA,IAAI,EAAE,CADG;AAET,IAAA,IAAI,EAAE,CAFG;AAGT,IAAA,IAAI,EAAE,CAAC,GAAG,KAHD;AAIT,IAAA,IAAI,EAAE,CAAC,GAAG;AAJD,GAAX;AAMA,EAAA,IAAI,GAAG,cAAc,CAAC,KAAD,EAAQ,IAAR,CAArB;AACA,SAAO;AACL,IAAA,CAAC,EAAE,IAAI,CAAC,IADH;AAEL,IAAA,CAAC,EAAE,IAAI,CAAC,IAFH;AAGL,IAAA,KAAK,EAAE,IAAI,CAAC,IAAL,GAAY,IAAI,CAAC,IAHnB;AAIL,IAAA,MAAM,EAAE,IAAI,CAAC,IAAL,GAAY,IAAI,CAAC;AAJpB,GAAP;AAMD","sourceRoot":"","sourcesContent":["import { Quad as QuadUtil, Cubic as CubicUtil, Arc as EllipseArcUtil } from '@antv/g-math';\nimport { path2Segments } from '@antv/path-util';\nimport { isNumberEqual, max, min } from '@antv/util';\nimport { mergeArrowBBox } from './util';\nfunction getPathBox(segments, lineWidth) {\n    var xArr = [];\n    var yArr = [];\n    var segmentsWithAngle = [];\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;\n        var box = void 0;\n        switch (segment.command) {\n            case 'Q':\n                box = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);\n                break;\n            case 'C':\n                box = CubicUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);\n                break;\n            case 'A':\n                var arcParams = segment.arcParams;\n                box = EllipseArcUtil.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);\n                break;\n            default:\n                xArr.push(currentPoint[0]);\n                yArr.push(currentPoint[1]);\n                break;\n        }\n        if (box) {\n            segment.box = box;\n            xArr.push(box.x, box.x + box.width);\n            yArr.push(box.y, box.y + box.height);\n        }\n        if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {\n            segmentsWithAngle.push(segment);\n        }\n    }\n    // bbox calculation should ignore NaN for path attribute\n    // ref: https://github.com/antvis/g/issues/210\n    xArr = xArr.filter(function (item) { return !Number.isNaN(item); });\n    yArr = yArr.filter(function (item) { return !Number.isNaN(item); });\n    var minX = min(xArr);\n    var minY = min(yArr);\n    var maxX = max(xArr);\n    var maxY = max(yArr);\n    if (segmentsWithAngle.length === 0) {\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    }\n    for (var i = 0; i < segmentsWithAngle.length; i++) {\n        var segment = segmentsWithAngle[i];\n        var currentPoint = segment.currentPoint;\n        var extra = void 0;\n        if (currentPoint[0] === minX) {\n            extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n            minX = minX - extra.xExtra;\n        }\n        else if (currentPoint[0] === maxX) {\n            extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n            maxX = maxX + extra.xExtra;\n        }\n        if (currentPoint[1] === minY) {\n            extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n            minY = minY - extra.yExtra;\n        }\n        else if (currentPoint[1] === maxY) {\n            extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n            maxY = maxY + extra.yExtra;\n        }\n    }\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY,\n    };\n}\nfunction getExtraFromSegmentWithAngle(segment, lineWidth) {\n    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;\n    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);\n    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);\n    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);\n    // 以 currentPoint 为顶点的夹角\n    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));\n    // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度\n    // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等\n    if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {\n        return {\n            xExtra: 0,\n            yExtra: 0,\n        };\n    }\n    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));\n    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));\n    // 将夹角转为锐角\n    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;\n    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;\n    // 这里不考虑在水平和垂直方向的投影，直接使用最大差值\n    // 由于上层统一加减了二分之一线宽，这里需要进行弥补\n    var extra = {\n        // 水平方向投影\n        xExtra: Math.cos(currentAngle / 2 - xAngle) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\n        // 垂直方向投影\n        yExtra: Math.cos(yAngle - currentAngle / 2) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\n    };\n    return extra;\n}\nexport default function (shape) {\n    var attrs = shape.attr();\n    var path = attrs.path, stroke = attrs.stroke;\n    var lineWidth = stroke ? attrs.lineWidth : 0; // 只有有 stroke 时，lineWidth 才生效\n    var segments = shape.get('segments') || path2Segments(path);\n    var _a = getPathBox(segments, lineWidth), x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n    var bbox = {\n        minX: x,\n        minY: y,\n        maxX: x + width,\n        maxY: y + height,\n    };\n    bbox = mergeArrowBBox(shape, bbox);\n    return {\n        x: bbox.minX,\n        y: bbox.minY,\n        width: bbox.maxX - bbox.minX,\n        height: bbox.maxY - bbox.minY,\n    };\n}\n//# sourceMappingURL=path.js.map"]},"metadata":{},"sourceType":"module"}