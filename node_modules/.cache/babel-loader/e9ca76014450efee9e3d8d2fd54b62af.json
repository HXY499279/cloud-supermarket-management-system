{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { each, isArray, isFunction, isString, debounce, throttle } from '@antv/util';\nimport { createAction, createCallbackAction } from './action/register';\nimport InteractionContext from './context';\nimport Interaction from './interaction'; // 将字符串转换成 action\n\nexport function parseAction(actionStr, context, arg) {\n  var arr = actionStr.split(':');\n  var actionName = arr[0]; // 如果已经初始化过 action ，则直接引用之前的 action\n\n  var action = context.getAction(actionName) || createAction(actionName, context);\n\n  if (!action) {\n    throw new Error(\"There is no action named \" + actionName);\n  }\n\n  var methodName = arr[1];\n  return {\n    action: action,\n    methodName: methodName,\n    arg: arg\n  };\n} // 执行 Action\n\nfunction executeAction(actionObject) {\n  var action = actionObject.action,\n      methodName = actionObject.methodName,\n      arg = actionObject.arg;\n\n  if (action[methodName]) {\n    action[methodName](arg);\n  } else {\n    throw new Error(\"Action(\" + action.name + \") doesn't have a method called \" + methodName);\n  }\n}\n\nvar STEP_NAMES = {\n  START: 'start',\n  SHOW_ENABLE: 'showEnable',\n  END: 'end',\n  ROLLBACK: 'rollback',\n  PROCESSING: 'processing'\n};\n/**\n * 支持语法的交互类\n */\n\nvar GrammarInteraction =\n/** @class */\nfunction (_super) {\n  __extends(GrammarInteraction, _super);\n\n  function GrammarInteraction(view, steps) {\n    var _this = _super.call(this, view, steps) || this;\n\n    _this.callbackCaches = {}; // 某个触发和反馈在本环节是否执行或\n\n    _this.emitCaches = {};\n    _this.steps = steps;\n    return _this;\n  }\n  /**\n   * 初始化\n   */\n\n\n  GrammarInteraction.prototype.init = function () {\n    this.initContext();\n\n    _super.prototype.init.call(this);\n  };\n  /**\n   * 清理资源\n   */\n\n\n  GrammarInteraction.prototype.destroy = function () {\n    _super.prototype.destroy.call(this); // 先清理事件\n\n\n    this.steps = null;\n\n    if (this.context) {\n      this.context.destroy();\n      this.context = null;\n    }\n\n    this.callbackCaches = null;\n    this.view = null;\n  };\n  /**\n   * 绑定事件\n   */\n\n\n  GrammarInteraction.prototype.initEvents = function () {\n    var _this = this;\n\n    each(this.steps, function (stepArr, stepName) {\n      each(stepArr, function (step) {\n        var callback = _this.getActionCallback(stepName, step);\n\n        if (callback) {\n          // 如果存在 callback，才绑定，有时候会出现无 callback 的情况\n          _this.bindEvent(step.trigger, callback);\n        }\n      });\n    });\n  };\n  /**\n   * 清理绑定的事件\n   */\n\n\n  GrammarInteraction.prototype.clearEvents = function () {\n    var _this = this;\n\n    each(this.steps, function (stepArr, stepName) {\n      each(stepArr, function (step) {\n        var callback = _this.getActionCallback(stepName, step);\n\n        if (callback) {\n          _this.offEvent(step.trigger, callback);\n        }\n      });\n    });\n  }; // 初始化上下文，并初始化 action\n\n\n  GrammarInteraction.prototype.initContext = function () {\n    var view = this.view;\n    var context = new InteractionContext(view);\n    this.context = context;\n    var steps = this.steps; // 生成具体的 Action\n\n    each(steps, function (subSteps) {\n      each(subSteps, function (step) {\n        if (isFunction(step.action)) {\n          // 如果传入回调函数，则直接生成 CallbackAction\n          step.actionObject = {\n            action: createCallbackAction(step.action, context),\n            methodName: 'execute'\n          };\n        } else if (isString(step.action)) {\n          // 如果是字符串\n          step.actionObject = parseAction(step.action, context, step.arg);\n        } else if (isArray(step.action)) {\n          // 如果是数组\n          var actionArr = step.action;\n          var argArr_1 = isArray(step.arg) ? step.arg : [step.arg];\n          step.actionObject = [];\n          each(actionArr, function (actionStr, idx) {\n            step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));\n          });\n        } // 如果 action 既不是字符串，也不是函数，则不会生成 actionObject\n\n      });\n    });\n  }; // 是否允许指定阶段名称执行\n\n\n  GrammarInteraction.prototype.isAllowStep = function (stepName) {\n    var currentStepName = this.currentStepName;\n    var steps = this.steps; // 相同的阶段允许同时执行\n\n    if (currentStepName === stepName) {\n      return true;\n    }\n\n    if (stepName === STEP_NAMES.SHOW_ENABLE) {\n      // 示能在整个过程中都可用\n      return true;\n    }\n\n    if (stepName === STEP_NAMES.PROCESSING) {\n      // 只有当前是 start 时，才允许 processing\n      return currentStepName === STEP_NAMES.START;\n    }\n\n    if (stepName === STEP_NAMES.START) {\n      // 如果当前是 processing，则无法 start，必须等待 end 后才能执行\n      return currentStepName !== STEP_NAMES.PROCESSING;\n    }\n\n    if (stepName === STEP_NAMES.END) {\n      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;\n    }\n\n    if (stepName === STEP_NAMES.ROLLBACK) {\n      if (steps[STEP_NAMES.END]) {\n        // 如果定义了 end, 只有 end 时才允许回滚\n        return currentStepName === STEP_NAMES.END;\n      } else if (currentStepName === STEP_NAMES.START) {\n        // 如果未定义 end, 则判断是否是开始\n        return true;\n      }\n    }\n\n    return false;\n  }; // 具体的指定阶段是否允许执行\n\n\n  GrammarInteraction.prototype.isAllowExecute = function (stepName, step) {\n    if (this.isAllowStep(stepName)) {\n      var key = this.getKey(stepName, step); // 如果是在本环节内仅允许触发一次，同时已经触发过，则不允许再触发\n\n      if (step.once && this.emitCaches[key]) {\n        return false;\n      } // 如果是允许的阶段，则验证 isEnable 方法\n\n\n      if (step.isEnable) {\n        return step.isEnable(this.context);\n      }\n\n      return true; // 如果没有 isEnable 则允许执行\n    }\n\n    return false;\n  };\n\n  GrammarInteraction.prototype.enterStep = function (stepName) {\n    this.currentStepName = stepName;\n    this.emitCaches = {}; // 清除所有本环节触发的缓存\n  }; // 执行完某个触发和反馈（子环节）\n\n\n  GrammarInteraction.prototype.afterExecute = function (stepName, step) {\n    // show enable 不计入正常的流程，其他情况则设置当前的 step\n    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {\n      this.enterStep(stepName);\n    }\n\n    var key = this.getKey(stepName, step); // 一旦执行，则缓存标记为，一直保持到跳出改环节\n\n    this.emitCaches[key] = true;\n  }; // 获取某个环节的唯一的键值\n\n\n  GrammarInteraction.prototype.getKey = function (stepName, step) {\n    return stepName + step.trigger + step.action;\n  }; // 获取 step 的回调函数，如果已经生成，则直接返回，如果未生成，则创建\n\n\n  GrammarInteraction.prototype.getActionCallback = function (stepName, step) {\n    var _this = this;\n\n    var context = this.context;\n    var callbackCaches = this.callbackCaches;\n    var actionObject = step.actionObject;\n\n    if (step.action && actionObject) {\n      var key = this.getKey(stepName, step);\n\n      if (!callbackCaches[key]) {\n        // 动态生成执行的方法，执行对应 action 的名称\n        var actionCallback = function (event) {\n          context.event = event; // 保证检测时的 event\n\n          if (_this.isAllowExecute(stepName, step)) {\n            // 如果是数组时，则依次执行\n            if (isArray(actionObject)) {\n              each(actionObject, function (obj) {\n                context.event = event; // 可能触发新的事件，保证执行前的 context.event 是正确的\n\n                executeAction(obj);\n              });\n            } else {\n              context.event = event; // 保证执行前的 context.event 是正确的\n\n              executeAction(actionObject);\n            }\n\n            _this.afterExecute(stepName, step);\n\n            if (step.callback) {\n              context.event = event; // 保证执行前的 context.event 是正确的\n\n              step.callback(context);\n            }\n          } else {\n            // 如果未通过验证，则事件不要绑定在上面\n            context.event = null;\n          }\n        }; // 如果设置了 debounce\n\n\n        if (step.debounce) {\n          callbackCaches[key] = debounce(actionCallback, step.debounce.wait, step.debounce.immediate);\n        } else if (step.throttle) {\n          // 设置 throttle\n          callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {\n            leading: step.throttle.leading,\n            trailing: step.throttle.trailing\n          });\n        } else {\n          // 直接设置\n          callbackCaches[key] = actionCallback;\n        }\n      }\n\n      return callbackCaches[key];\n    }\n\n    return null;\n  };\n\n  GrammarInteraction.prototype.bindEvent = function (eventName, callback) {\n    var nameArr = eventName.split(':');\n\n    if (nameArr[0] === 'window') {\n      window.addEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.addEventListener(nameArr[1], callback);\n    } else {\n      this.view.on(eventName, callback);\n    }\n  };\n\n  GrammarInteraction.prototype.offEvent = function (eventName, callback) {\n    var nameArr = eventName.split(':');\n\n    if (nameArr[0] === 'window') {\n      window.removeEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.removeEventListener(nameArr[1], callback);\n    } else {\n      this.view.off(eventName, callback);\n    }\n  };\n\n  return GrammarInteraction;\n}(Interaction);\n\nexport default GrammarInteraction;","map":{"version":3,"sources":["../../src/interaction/grammar-interaction.ts"],"names":[],"mappings":"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","sourcesContent":["import { each, isArray, isFunction, isString, debounce, throttle } from '@antv/util';\nimport { View } from '../chart';\nimport { ActionCallback, IAction, IInteractionContext, LooseObject } from '../interface';\nimport { createAction, createCallbackAction } from './action/register';\nimport InteractionContext from './context';\nimport Interaction from './interaction';\n\n// 将字符串转换成 action\nexport function parseAction(actionStr: string, context: IInteractionContext, arg?: any): ActionObject {\n  const arr = actionStr.split(':');\n  const actionName = arr[0];\n  // 如果已经初始化过 action ，则直接引用之前的 action\n  const action = context.getAction(actionName) || createAction(actionName, context);\n  if (!action) {\n    throw new Error(`There is no action named ${actionName}`);\n  }\n  const methodName = arr[1];\n  return {\n    action,\n    methodName,\n    arg,\n  };\n}\n\n// 执行 Action\nfunction executeAction(actionObject: ActionObject) {\n  const { action, methodName, arg } = actionObject;\n  if (action[methodName]) {\n    action[methodName](arg);\n  } else {\n    throw new Error(`Action(${action.name}) doesn't have a method called ${methodName}`);\n  }\n}\n\nconst STEP_NAMES = {\n  START: 'start',\n  SHOW_ENABLE: 'showEnable',\n  END: 'end',\n  ROLLBACK: 'rollback',\n  PROCESSING: 'processing',\n};\n\n/** 交互环节的定义 */\nexport interface InteractionStep {\n  /**\n   * 触发事件，支持 view，chart 的各种事件，也支持 document、window 的事件\n   */\n  trigger: string;\n  /**\n   * 是否可以触发 action\n   * @param context - 交互的上下文\n   */\n  isEnable?: (context: IInteractionContext) => boolean;\n  /**\n   * 反馈，支持三种方式：\n   * - action:method : action 的名字和方法的组合\n   * - [’action1:method1‘, ’action2:method‘]\n   * - ActionCallback: 回调函数\n   */\n  action: string | string[] | ActionCallback;\n  /**\n   * 反馈，具体 action method 的参数：\n   * - 当传递多个 action 时，args 必须是一个数组\n   */\n  arg?: any | any[];\n  /**\n   * 回调函数，action 执行后执行\n   */\n  callback?: (context: IInteractionContext) => void;\n  /**\n   * @private\n   * 不需要用户传入，通过上面的属性计算出来的属性\n   */\n  actionObject?: ActionObject | ActionObject[];\n  /**\n   * 在一个环节内是否只允许执行一次\n   */\n  once?: boolean;\n  /**\n   * 是否增加节流\n   */\n  throttle?: ThrottleOption;\n  /**\n   * 是否延迟\n   */\n  debounce?: DebounceOption;\n}\n\n// action 执行时支持 debounce 和 throttle，可以参考：https://css-tricks.com/debouncing-throttling-explained-examples/\n/**\n * debounce 的配置\n */\nexport interface DebounceOption {\n  /**\n   * 等待时间\n   */\n  wait: number;\n  /**\n   * 是否马上执行\n   */\n  immediate?: boolean;\n}\n\n/**\n * throttle 的配置\n */\nexport interface ThrottleOption {\n  /**\n   * 等待时间\n   */\n  wait: number;\n  /**\n   * 马上就执行\n   */\n  leading?: boolean;\n  /**\n   * 执行完毕后再执行一次\n   */\n  trailing?: boolean;\n}\n\n/** 缓存 action 对象，仅用于当前文件 */\ninterface ActionObject {\n  /**\n   * 缓存的 action\n   */\n  action: IAction;\n  /**\n   * action 的方法\n   */\n  methodName: string;\n  /**\n   * 用户传递的 action 方法的参数\n   */\n  arg?: any;\n}\n\n/** 交互的所有环节 */\nexport interface InteractionSteps {\n  /**\n   * 显示交互可以进行\n   */\n  showEnable?: InteractionStep[];\n  /**\n   * 交互开始\n   */\n  start?: InteractionStep[];\n  /**\n   * 交互持续\n   */\n  processing?: InteractionStep[];\n  /**\n   * 交互结束\n   */\n  end?: InteractionStep[];\n  /**\n   * 交互回滚\n   */\n  rollback?: InteractionStep[];\n}\n\n/**\n * 支持语法的交互类\n */\nexport default class GrammarInteraction extends Interaction {\n  // 存储的交互环节\n  private steps: InteractionSteps;\n  /** 当前执行到的阶段 */\n  public currentStepName: string;\n  /**\n   * 当前交互的上下文\n   */\n  public context: IInteractionContext;\n\n  private callbackCaches: LooseObject = {};\n  // 某个触发和反馈在本环节是否执行或\n  private emitCaches: LooseObject = {};\n\n  constructor(view: View, steps: InteractionSteps) {\n    super(view, steps);\n    this.steps = steps;\n  }\n\n  /**\n   * 初始化\n   */\n  public init() {\n    this.initContext();\n    super.init();\n  }\n\n  /**\n   * 清理资源\n   */\n  public destroy() {\n    super.destroy(); // 先清理事件\n    this.steps = null;\n    if (this.context) {\n      this.context.destroy();\n      this.context = null;\n    }\n\n    this.callbackCaches = null;\n    this.view = null;\n  }\n\n  /**\n   * 绑定事件\n   */\n  protected initEvents() {\n    each(this.steps, (stepArr, stepName) => {\n      each(stepArr, (step) => {\n        const callback = this.getActionCallback(stepName, step);\n        if (callback) {\n          // 如果存在 callback，才绑定，有时候会出现无 callback 的情况\n          this.bindEvent(step.trigger, callback);\n        }\n      });\n    });\n  }\n\n  /**\n   * 清理绑定的事件\n   */\n  protected clearEvents() {\n    each(this.steps, (stepArr, stepName) => {\n      each(stepArr, (step) => {\n        const callback = this.getActionCallback(stepName, step);\n        if (callback) {\n          this.offEvent(step.trigger, callback);\n        }\n      });\n    });\n  }\n\n  // 初始化上下文，并初始化 action\n  private initContext() {\n    const view = this.view;\n    const context = new InteractionContext(view);\n    this.context = context;\n    const steps = this.steps;\n    // 生成具体的 Action\n    each(steps, (subSteps: InteractionStep[]) => {\n      each(subSteps, (step: InteractionStep) => {\n        if (isFunction(step.action)) {\n          // 如果传入回调函数，则直接生成 CallbackAction\n          step.actionObject = {\n            action: createCallbackAction(step.action, context),\n            methodName: 'execute',\n          };\n        } else if (isString(step.action)) {\n          // 如果是字符串\n          step.actionObject = parseAction(step.action, context, step.arg);\n        } else if (isArray(step.action)) {\n          // 如果是数组\n          const actionArr = step.action;\n          const argArr = isArray(step.arg) ? step.arg : [step.arg];\n          step.actionObject = [];\n          each(actionArr, (actionStr, idx) => {\n            (step.actionObject as ActionObject[]).push(parseAction(actionStr, context, argArr[idx]));\n          });\n        }\n        // 如果 action 既不是字符串，也不是函数，则不会生成 actionObject\n      });\n    });\n  }\n\n  // 是否允许指定阶段名称执行\n  private isAllowStep(stepName: string): boolean {\n    const currentStepName = this.currentStepName;\n    const steps = this.steps;\n    // 相同的阶段允许同时执行\n    if (currentStepName === stepName) {\n      return true;\n    }\n\n    if (stepName === STEP_NAMES.SHOW_ENABLE) {\n      // 示能在整个过程中都可用\n      return true;\n    }\n\n    if (stepName === STEP_NAMES.PROCESSING) {\n      // 只有当前是 start 时，才允许 processing\n      return currentStepName === STEP_NAMES.START;\n    }\n\n    if (stepName === STEP_NAMES.START) {\n      // 如果当前是 processing，则无法 start，必须等待 end 后才能执行\n      return currentStepName !== STEP_NAMES.PROCESSING;\n    }\n\n    if (stepName === STEP_NAMES.END) {\n      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;\n    }\n\n    if (stepName === STEP_NAMES.ROLLBACK) {\n      if (steps[STEP_NAMES.END]) {\n        // 如果定义了 end, 只有 end 时才允许回滚\n        return currentStepName === STEP_NAMES.END;\n      } else if (currentStepName === STEP_NAMES.START) {\n        // 如果未定义 end, 则判断是否是开始\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // 具体的指定阶段是否允许执行\n  private isAllowExecute(stepName: string, step: InteractionStep): boolean {\n    if (this.isAllowStep(stepName)) {\n      const key = this.getKey(stepName, step);\n      // 如果是在本环节内仅允许触发一次，同时已经触发过，则不允许再触发\n      if (step.once && this.emitCaches[key]) {\n        return false;\n      }\n      // 如果是允许的阶段，则验证 isEnable 方法\n      if (step.isEnable) {\n        return step.isEnable(this.context);\n      }\n      return true; // 如果没有 isEnable 则允许执行\n    }\n    return false;\n  }\n\n  private enterStep(stepName: string) {\n    this.currentStepName = stepName;\n    this.emitCaches = {}; // 清除所有本环节触发的缓存\n  }\n\n  // 执行完某个触发和反馈（子环节）\n  private afterExecute(stepName: string, step) {\n    // show enable 不计入正常的流程，其他情况则设置当前的 step\n    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {\n      this.enterStep(stepName);\n    }\n    const key = this.getKey(stepName, step);\n    // 一旦执行，则缓存标记为，一直保持到跳出改环节\n    this.emitCaches[key] = true;\n  }\n  // 获取某个环节的唯一的键值\n  private getKey(stepName, step) {\n    return stepName + step.trigger + step.action;\n  }\n\n  // 获取 step 的回调函数，如果已经生成，则直接返回，如果未生成，则创建\n  private getActionCallback(stepName: string, step: InteractionStep): (e: object) => void {\n    const context = this.context;\n    const callbackCaches = this.callbackCaches;\n    const actionObject = step.actionObject;\n    if (step.action && actionObject) {\n      const key = this.getKey(stepName, step);\n      if (!callbackCaches[key]) {\n        // 动态生成执行的方法，执行对应 action 的名称\n        const actionCallback = (event) => {\n          context.event = event; // 保证检测时的 event\n          if (this.isAllowExecute(stepName, step)) {\n            // 如果是数组时，则依次执行\n            if (isArray(actionObject)) {\n              each(actionObject, (obj: ActionObject) => {\n                context.event = event; // 可能触发新的事件，保证执行前的 context.event 是正确的\n                executeAction(obj);\n              });\n            } else {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              executeAction(actionObject);\n            }\n            this.afterExecute(stepName, step);\n            if (step.callback) {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              step.callback(context);\n            }\n          } else {\n            // 如果未通过验证，则事件不要绑定在上面\n            context.event = null;\n          }\n        };\n        // 如果设置了 debounce\n        if (step.debounce) {\n          callbackCaches[key] = debounce(actionCallback, step.debounce.wait, step.debounce.immediate);\n        } else if (step.throttle) {\n          // 设置 throttle\n          callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {\n            leading: step.throttle.leading,\n            trailing: step.throttle.trailing,\n          });\n        } else {\n          // 直接设置\n          callbackCaches[key] = actionCallback;\n        }\n      }\n      return callbackCaches[key];\n    }\n    return null;\n  }\n\n  private bindEvent(eventName, callback) {\n    const nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.addEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.addEventListener(nameArr[1], callback);\n    } else {\n      this.view.on(eventName, callback);\n    }\n  }\n\n  private offEvent(eventName, callback) {\n    const nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.removeEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.removeEventListener(nameArr[1], callback);\n    } else {\n      this.view.off(eventName, callback);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}