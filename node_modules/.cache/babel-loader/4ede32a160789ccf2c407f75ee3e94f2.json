{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { each, isNil } from '@antv/util';\nimport ShapeBase from './base';\nimport { path2Absolute, path2Segments } from '@antv/path-util';\nimport { drawPath } from '../util/draw';\nimport isPointInPath from '../util/in-path/point-in-path';\nimport isInPolygon from '../util/in-path/polygon';\nimport PathUtil from '../util/path';\nimport * as ArrowUtil from '../util/arrow'; // 是否在多个多边形内部\n\nfunction isInPolygons(polygons, x, y) {\n  var isHit = false;\n\n  for (var i = 0; i < polygons.length; i++) {\n    var points = polygons[i];\n    isHit = isInPolygon(points, x, y);\n\n    if (isHit) {\n      break;\n    }\n  }\n\n  return isHit;\n}\n\nvar Path =\n/** @class */\nfunction (_super) {\n  __extends(Path, _super);\n\n  function Path() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Path.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n\n    return __assign(__assign({}, attrs), {\n      startArrow: false,\n      endArrow: false\n    });\n  };\n\n  Path.prototype.initAttrs = function (attrs) {\n    this._setPathArr(attrs.path);\n\n    this.setArrow();\n  }; // 更新属性时，检测是否更改了 path\n\n\n  Path.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n\n    if (name === 'path') {\n      this._setPathArr(value);\n    } // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n\n\n    this.setArrow();\n  }; // 将 path 转换成绝对路径\n\n\n  Path.prototype._setPathArr = function (path) {\n    // 转换 path 的格式\n    this.attrs.path = path2Absolute(path);\n    var hasArc = PathUtil.hasArc(path); // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n    // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n\n    this.set('hasArc', hasArc);\n    this.set('paramsCache', {}); // 清理缓存\n\n    this.set('segments', null); // 延迟生成 path，在动画场景下可能不会有拾取\n\n    this.set('curve', null);\n    this.set('tCache', null);\n    this.set('totalLength', null);\n  };\n\n  Path.prototype.getSegments = function () {\n    var segments = this.get('segements');\n\n    if (!segments) {\n      segments = path2Segments(this.attr('path'));\n      this.set('segments', segments);\n    }\n\n    return segments;\n  };\n\n  Path.prototype.setArrow = function () {\n    var attrs = this.attr();\n    var startArrow = attrs.startArrow,\n        endArrow = attrs.endArrow;\n\n    if (startArrow) {\n      var tangent = this.getStartTangent();\n      ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n    }\n\n    if (endArrow) {\n      var tangent = this.getEndTangent();\n      ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n    }\n  };\n\n  Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n    var segments = this.getSegments();\n    var hasArc = this.get('hasArc');\n    var isHit = false;\n\n    if (isStroke) {\n      var length_1 = this.getTotalLength();\n      isHit = PathUtil.isPointInStroke(segments, lineWidth, x, y, length_1);\n    }\n\n    if (!isHit && isFill) {\n      if (hasArc) {\n        // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n        isHit = isPointInPath(this, x, y);\n      } else {\n        var path = this.attr('path');\n        var extractResutl = PathUtil.extractPolygons(path); // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n\n        isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);\n      }\n    }\n\n    return isHit;\n  };\n\n  Path.prototype.createPath = function (context) {\n    var attrs = this.attr();\n    var paramsCache = this.get('paramsCache'); // 由于计算圆弧的参数成本很大，所以要缓存\n\n    drawPath(this, context, attrs, paramsCache);\n  };\n\n  Path.prototype.afterDrawPath = function (context) {\n    var startArrowShape = this.get('startArrowShape');\n    var endArrowShape = this.get('endArrowShape');\n\n    if (startArrowShape) {\n      startArrowShape.draw(context);\n    }\n\n    if (endArrowShape) {\n      endArrowShape.draw(context);\n    }\n  };\n  /**\n   * Get total length of path\n   * @return {number} length\n   */\n\n\n  Path.prototype.getTotalLength = function () {\n    var totalLength = this.get('totalLength');\n\n    if (!isNil(totalLength)) {\n      return totalLength;\n    }\n\n    this._calculateCurve();\n\n    this._setTcache();\n\n    return this.get('totalLength');\n  };\n  /**\n   * Get point according to ratio\n   * @param {number} ratio\n   * @return {Point} point\n   */\n\n\n  Path.prototype.getPoint = function (ratio) {\n    var tCache = this.get('tCache');\n\n    if (!tCache) {\n      this._calculateCurve();\n\n      this._setTcache();\n\n      tCache = this.get('tCache');\n    }\n\n    var subt;\n    var index;\n    var curve = this.get('curve');\n\n    if (!tCache || tCache.length === 0) {\n      if (curve) {\n        return {\n          x: curve[0][1],\n          y: curve[0][2]\n        };\n      }\n\n      return null;\n    }\n\n    each(tCache, function (v, i) {\n      if (ratio >= v[0] && ratio <= v[1]) {\n        subt = (ratio - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n    var seg = curve[index];\n\n    if (isNil(seg) || isNil(index)) {\n      return null;\n    }\n\n    var l = seg.length;\n    var nextSeg = curve[index + 1];\n    return CubicUtil.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);\n  };\n\n  Path.prototype._calculateCurve = function () {\n    var path = this.attr().path;\n    this.set('curve', PathUtil.pathToCurve(path));\n  };\n\n  Path.prototype._setTcache = function () {\n    var totalLength = 0;\n    var tempLength = 0; // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n\n    var tCache = [];\n    var segmentT;\n    var segmentL;\n    var segmentN;\n    var l;\n    var curve = this.get('curve');\n\n    if (!curve) {\n      return;\n    }\n\n    each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n\n      if (segmentN) {\n        totalLength += CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\n      }\n    });\n    this.set('totalLength', totalLength);\n\n    if (totalLength === 0) {\n      this.set('tCache', []);\n      return;\n    }\n\n    each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n\n      if (segmentN) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]); // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n\n        tempLength += segmentL || 0;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this.set('tCache', tCache);\n  };\n  /**\n   * Get start tangent vector\n   * @return {Array}\n   */\n\n\n  Path.prototype.getStartTangent = function () {\n    var segments = this.getSegments();\n    var result;\n\n    if (segments.length > 1) {\n      var startPoint = segments[0].currentPoint;\n      var endPoint = segments[1].currentPoint;\n      var tangent = segments[1].startTangent;\n      result = [];\n\n      if (tangent) {\n        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);\n        result.push([startPoint[0], startPoint[1]]);\n      } else {\n        result.push([endPoint[0], endPoint[1]]);\n        result.push([startPoint[0], startPoint[1]]);\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Get end tangent vector\n   * @return {Array}\n   */\n\n\n  Path.prototype.getEndTangent = function () {\n    var segments = this.getSegments();\n    var length = segments.length;\n    var result;\n\n    if (length > 1) {\n      var startPoint = segments[length - 2].currentPoint;\n      var endPoint = segments[length - 1].currentPoint;\n      var tangent = segments[length - 1].endTangent;\n      result = [];\n\n      if (tangent) {\n        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);\n        result.push([endPoint[0], endPoint[1]]);\n      } else {\n        result.push([startPoint[0], startPoint[1]]);\n        result.push([endPoint[0], endPoint[1]]);\n      }\n    }\n\n    return result;\n  };\n\n  return Path;\n}(ShapeBase);\n\nexport default Path;","map":{"version":3,"sources":["../../src/shape/path.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { each, isNil } from '@antv/util';\nimport ShapeBase from './base';\nimport { path2Absolute, path2Segments } from '@antv/path-util';\nimport { drawPath } from '../util/draw';\nimport isPointInPath from '../util/in-path/point-in-path';\nimport isInPolygon from '../util/in-path/polygon';\nimport PathUtil from '../util/path';\nimport * as ArrowUtil from '../util/arrow';\n// 是否在多个多边形内部\nfunction isInPolygons(polygons, x, y) {\n    var isHit = false;\n    for (var i = 0; i < polygons.length; i++) {\n        var points = polygons[i];\n        isHit = isInPolygon(points, x, y);\n        if (isHit) {\n            break;\n        }\n    }\n    return isHit;\n}\nvar Path = /** @class */ (function (_super) {\n    __extends(Path, _super);\n    function Path() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Path.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });\n    };\n    Path.prototype.initAttrs = function (attrs) {\n        this._setPathArr(attrs.path);\n        this.setArrow();\n    };\n    // 更新属性时，检测是否更改了 path\n    Path.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (name === 'path') {\n            this._setPathArr(value);\n        }\n        // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n        this.setArrow();\n    };\n    // 将 path 转换成绝对路径\n    Path.prototype._setPathArr = function (path) {\n        // 转换 path 的格式\n        this.attrs.path = path2Absolute(path);\n        var hasArc = PathUtil.hasArc(path);\n        // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n        // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n        this.set('hasArc', hasArc);\n        this.set('paramsCache', {}); // 清理缓存\n        this.set('segments', null); // 延迟生成 path，在动画场景下可能不会有拾取\n        this.set('curve', null);\n        this.set('tCache', null);\n        this.set('totalLength', null);\n    };\n    Path.prototype.getSegments = function () {\n        var segments = this.get('segements');\n        if (!segments) {\n            segments = path2Segments(this.attr('path'));\n            this.set('segments', segments);\n        }\n        return segments;\n    };\n    Path.prototype.setArrow = function () {\n        var attrs = this.attr();\n        var startArrow = attrs.startArrow, endArrow = attrs.endArrow;\n        if (startArrow) {\n            var tangent = this.getStartTangent();\n            ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n        }\n        if (endArrow) {\n            var tangent = this.getEndTangent();\n            ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n        }\n    };\n    Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var segments = this.getSegments();\n        var hasArc = this.get('hasArc');\n        var isHit = false;\n        if (isStroke) {\n            var length_1 = this.getTotalLength();\n            isHit = PathUtil.isPointInStroke(segments, lineWidth, x, y, length_1);\n        }\n        if (!isHit && isFill) {\n            if (hasArc) {\n                // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n                isHit = isPointInPath(this, x, y);\n            }\n            else {\n                var path = this.attr('path');\n                var extractResutl = PathUtil.extractPolygons(path);\n                // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n                isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);\n            }\n        }\n        return isHit;\n    };\n    Path.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var paramsCache = this.get('paramsCache'); // 由于计算圆弧的参数成本很大，所以要缓存\n        drawPath(this, context, attrs, paramsCache);\n    };\n    Path.prototype.afterDrawPath = function (context) {\n        var startArrowShape = this.get('startArrowShape');\n        var endArrowShape = this.get('endArrowShape');\n        if (startArrowShape) {\n            startArrowShape.draw(context);\n        }\n        if (endArrowShape) {\n            endArrowShape.draw(context);\n        }\n    };\n    /**\n     * Get total length of path\n     * @return {number} length\n     */\n    Path.prototype.getTotalLength = function () {\n        var totalLength = this.get('totalLength');\n        if (!isNil(totalLength)) {\n            return totalLength;\n        }\n        this._calculateCurve();\n        this._setTcache();\n        return this.get('totalLength');\n    };\n    /**\n     * Get point according to ratio\n     * @param {number} ratio\n     * @return {Point} point\n     */\n    Path.prototype.getPoint = function (ratio) {\n        var tCache = this.get('tCache');\n        if (!tCache) {\n            this._calculateCurve();\n            this._setTcache();\n            tCache = this.get('tCache');\n        }\n        var subt;\n        var index;\n        var curve = this.get('curve');\n        if (!tCache || tCache.length === 0) {\n            if (curve) {\n                return {\n                    x: curve[0][1],\n                    y: curve[0][2],\n                };\n            }\n            return null;\n        }\n        each(tCache, function (v, i) {\n            if (ratio >= v[0] && ratio <= v[1]) {\n                subt = (ratio - v[0]) / (v[1] - v[0]);\n                index = i;\n            }\n        });\n        var seg = curve[index];\n        if (isNil(seg) || isNil(index)) {\n            return null;\n        }\n        var l = seg.length;\n        var nextSeg = curve[index + 1];\n        return CubicUtil.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);\n    };\n    Path.prototype._calculateCurve = function () {\n        var path = this.attr().path;\n        this.set('curve', PathUtil.pathToCurve(path));\n    };\n    Path.prototype._setTcache = function () {\n        var totalLength = 0;\n        var tempLength = 0;\n        // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n        var tCache = [];\n        var segmentT;\n        var segmentL;\n        var segmentN;\n        var l;\n        var curve = this.get('curve');\n        if (!curve) {\n            return;\n        }\n        each(curve, function (segment, i) {\n            segmentN = curve[i + 1];\n            l = segment.length;\n            if (segmentN) {\n                totalLength +=\n                    CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\n            }\n        });\n        this.set('totalLength', totalLength);\n        if (totalLength === 0) {\n            this.set('tCache', []);\n            return;\n        }\n        each(curve, function (segment, i) {\n            segmentN = curve[i + 1];\n            l = segment.length;\n            if (segmentN) {\n                segmentT = [];\n                segmentT[0] = tempLength / totalLength;\n                segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n                // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n                tempLength += segmentL || 0;\n                segmentT[1] = tempLength / totalLength;\n                tCache.push(segmentT);\n            }\n        });\n        this.set('tCache', tCache);\n    };\n    /**\n     * Get start tangent vector\n     * @return {Array}\n     */\n    Path.prototype.getStartTangent = function () {\n        var segments = this.getSegments();\n        var result;\n        if (segments.length > 1) {\n            var startPoint = segments[0].currentPoint;\n            var endPoint = segments[1].currentPoint;\n            var tangent = segments[1].startTangent;\n            result = [];\n            if (tangent) {\n                result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);\n                result.push([startPoint[0], startPoint[1]]);\n            }\n            else {\n                result.push([endPoint[0], endPoint[1]]);\n                result.push([startPoint[0], startPoint[1]]);\n            }\n        }\n        return result;\n    };\n    /**\n     * Get end tangent vector\n     * @return {Array}\n     */\n    Path.prototype.getEndTangent = function () {\n        var segments = this.getSegments();\n        var length = segments.length;\n        var result;\n        if (length > 1) {\n            var startPoint = segments[length - 2].currentPoint;\n            var endPoint = segments[length - 1].currentPoint;\n            var tangent = segments[length - 1].endTangent;\n            result = [];\n            if (tangent) {\n                result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);\n                result.push([endPoint[0], endPoint[1]]);\n            }\n            else {\n                result.push([startPoint[0], startPoint[1]]);\n                result.push([endPoint[0], endPoint[1]]);\n            }\n        }\n        return result;\n    };\n    return Path;\n}(ShapeBase));\nexport default Path;\n//# sourceMappingURL=path.js.map"]},"metadata":{},"sourceType":"module"}