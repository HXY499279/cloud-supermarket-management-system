{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { AbstractCanvas } from '@antv/g-base';\nimport { SHAPE_TO_TAGS } from './constant';\nimport { drawChildren } from './util/draw';\nimport { setTransform, setClip } from './util/svg';\nimport { sortDom, createSVGElement } from './util/dom';\nimport * as Shape from './shape';\nimport Group from './group';\nimport Defs from './defs';\n\nvar Canvas =\n/** @class */\nfunction (_super) {\n  __extends(Canvas, _super);\n\n  function Canvas(cfg) {\n    return _super.call(this, __assign(__assign({}, cfg), {\n      autoDraw: true,\n      // 设置渲染引擎为 canvas，只读属性\n      renderer: 'svg'\n    })) || this;\n  }\n\n  Canvas.prototype.getShapeBase = function () {\n    return Shape;\n  };\n\n  Canvas.prototype.getGroupBase = function () {\n    return Group;\n  }; // 覆盖 Container 中通过遍历的方式获取 shape 对象的逻辑，直接走 SVG 的 dom 拾取即可\n\n\n  Canvas.prototype.getShape = function (x, y, ev) {\n    var target = ev.target || ev.srcElement;\n\n    if (!SHAPE_TO_TAGS[target.tagName]) {\n      var parent_1 = target.parentNode;\n\n      while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {\n        parent_1 = parent_1.parentNode;\n      }\n\n      target = parent_1;\n    }\n\n    return this.find(function (child) {\n      return child.get('el') === target;\n    });\n  }; // 复写基类的方法生成标签\n\n\n  Canvas.prototype.createDom = function () {\n    var element = createSVGElement('svg');\n    var context = new Defs(element);\n    element.setAttribute('width', \"\" + this.get('width'));\n    element.setAttribute('height', \"\" + this.get('height')); // 缓存 context 对象\n\n    this.set('context', context);\n    return element;\n  };\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n\n\n  Canvas.prototype.onCanvasChange = function (changeType) {\n    var context = this.get('context');\n    var el = this.get('el');\n\n    if (changeType === 'sort') {\n      var children_1 = this.get('children');\n\n      if (children_1 && children_1.length) {\n        sortDom(this, function (a, b) {\n          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;\n        });\n      }\n    } else if (changeType === 'clear') {\n      // el maybe null for canvas\n      if (el) {\n        // 清空 SVG 元素\n        el.innerHTML = '';\n        var defsEl = context.el; // 清空 defs 元素\n\n        defsEl.innerHTML = ''; // 将清空后的 defs 元素挂载到 el 下\n\n        el.appendChild(defsEl);\n      }\n    } else if (changeType === 'matrix') {\n      setTransform(this);\n    } else if (changeType === 'clip') {\n      setClip(this, context);\n    } else if (changeType === 'changeSize') {\n      el.setAttribute('width', \"\" + this.get('width'));\n      el.setAttribute('height', \"\" + this.get('height'));\n    }\n  }; // 复写基类的 draw 方法\n\n\n  Canvas.prototype.draw = function () {\n    var context = this.get('context');\n    var children = this.getChildren();\n    setClip(this, context);\n\n    if (children.length) {\n      drawChildren(context, children);\n    }\n  };\n\n  return Canvas;\n}(AbstractCanvas);\n\nexport default Canvas;","map":{"version":3,"sources":["../src/canvas.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { AbstractCanvas } from '@antv/g-base';\nimport { SHAPE_TO_TAGS } from './constant';\nimport { drawChildren } from './util/draw';\nimport { setTransform, setClip } from './util/svg';\nimport { sortDom, createSVGElement } from './util/dom';\nimport * as Shape from './shape';\nimport Group from './group';\nimport Defs from './defs';\nvar Canvas = /** @class */ (function (_super) {\n    __extends(Canvas, _super);\n    function Canvas(cfg) {\n        return _super.call(this, __assign(__assign({}, cfg), { autoDraw: true, \n            // 设置渲染引擎为 canvas，只读属性\n            renderer: 'svg' })) || this;\n    }\n    Canvas.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    Canvas.prototype.getGroupBase = function () {\n        return Group;\n    };\n    // 覆盖 Container 中通过遍历的方式获取 shape 对象的逻辑，直接走 SVG 的 dom 拾取即可\n    Canvas.prototype.getShape = function (x, y, ev) {\n        var target = ev.target || ev.srcElement;\n        if (!SHAPE_TO_TAGS[target.tagName]) {\n            var parent_1 = target.parentNode;\n            while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {\n                parent_1 = parent_1.parentNode;\n            }\n            target = parent_1;\n        }\n        return this.find(function (child) { return child.get('el') === target; });\n    };\n    // 复写基类的方法生成标签\n    Canvas.prototype.createDom = function () {\n        var element = createSVGElement('svg');\n        var context = new Defs(element);\n        element.setAttribute('width', \"\" + this.get('width'));\n        element.setAttribute('height', \"\" + this.get('height'));\n        // 缓存 context 对象\n        this.set('context', context);\n        return element;\n    };\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    Canvas.prototype.onCanvasChange = function (changeType) {\n        var context = this.get('context');\n        var el = this.get('el');\n        if (changeType === 'sort') {\n            var children_1 = this.get('children');\n            if (children_1 && children_1.length) {\n                sortDom(this, function (a, b) {\n                    return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;\n                });\n            }\n        }\n        else if (changeType === 'clear') {\n            // el maybe null for canvas\n            if (el) {\n                // 清空 SVG 元素\n                el.innerHTML = '';\n                var defsEl = context.el;\n                // 清空 defs 元素\n                defsEl.innerHTML = '';\n                // 将清空后的 defs 元素挂载到 el 下\n                el.appendChild(defsEl);\n            }\n        }\n        else if (changeType === 'matrix') {\n            setTransform(this);\n        }\n        else if (changeType === 'clip') {\n            setClip(this, context);\n        }\n        else if (changeType === 'changeSize') {\n            el.setAttribute('width', \"\" + this.get('width'));\n            el.setAttribute('height', \"\" + this.get('height'));\n        }\n    };\n    // 复写基类的 draw 方法\n    Canvas.prototype.draw = function () {\n        var context = this.get('context');\n        var children = this.getChildren();\n        setClip(this, context);\n        if (children.length) {\n            drawChildren(context, children);\n        }\n    };\n    return Canvas;\n}(AbstractCanvas));\nexport default Canvas;\n//# sourceMappingURL=canvas.js.map"]},"metadata":{},"sourceType":"module"}