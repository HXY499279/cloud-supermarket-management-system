{"ast":null,"code":"import path2Absolute from './path-2-absolute';\n\nvar a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  // for more information of where this math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  if (rx === ry) {\n    rx += 1;\n  }\n\n  var _120 = Math.PI * 120 / 180;\n\n  var rad = Math.PI / 180 * (+angle || 0);\n  var res = [];\n  var xy;\n  var f1;\n  var f2;\n  var cx;\n  var cy;\n\n  var rotate = function (x, y, rad) {\n    var X = x * Math.cos(rad) - y * Math.sin(rad);\n    var Y = x * Math.sin(rad) + y * Math.cos(rad);\n    return {\n      x: X,\n      y: Y\n    };\n  };\n\n  if (!recursive) {\n    xy = rotate(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotate(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    if (x1 === x2 && y1 === y2) {\n      // 若弧的起始点和终点重叠则错开一点\n      x2 += 1;\n      y2 += 1;\n    } // const cos = Math.cos(Math.PI / 180 * angle);\n    // const sin = Math.sin(Math.PI / 180 * angle);\n\n\n    var x = (x1 - x2) / 2;\n    var y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    cx = k * rx * y / ry + (x1 + x2) / 2;\n    cy = k * -ry * x / rx + (y1 + y2) / 2;\n    f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n    f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > _120) {\n    var f2old = f2;\n    var x2old = x2;\n    var y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1);\n  var s1 = Math.sin(f1);\n  var c2 = Math.cos(f2);\n  var s2 = Math.sin(f2);\n  var t = Math.tan(df / 4);\n  var hx = 4 / 3 * rx * t;\n  var hy = 4 / 3 * ry * t;\n  var m1 = [x1, y1];\n  var m2 = [x1 + hx * s1, y1 - hy * c1];\n  var m3 = [x2 + hx * s2, y2 - hy * c2];\n  var m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n\n  if (recursive) {\n    return [m2, m3, m4].concat(res);\n  }\n\n  res = [m2, m3, m4].concat(res).join().split(',');\n  var newres = [];\n\n  for (var i = 0, ii = res.length; i < ii; i++) {\n    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n  }\n\n  return newres;\n};\n\nvar l2c = function (x1, y1, x2, y2) {\n  return [x1, y1, x2, y2, x2, y2];\n};\n\nvar q2c = function (x1, y1, ax, ay, x2, y2) {\n  var _13 = 1 / 3;\n\n  var _23 = 2 / 3;\n\n  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n};\n\nexport default function pathTocurve(path, path2) {\n  var p = path2Absolute(path);\n  var p2 = path2 && path2Absolute(path2);\n  var attrs = {\n    x: 0,\n    y: 0,\n    bx: 0,\n    by: 0,\n    X: 0,\n    Y: 0,\n    qx: null,\n    qy: null\n  };\n  var attrs2 = {\n    x: 0,\n    y: 0,\n    bx: 0,\n    by: 0,\n    X: 0,\n    Y: 0,\n    qx: null,\n    qy: null\n  };\n  var pcoms1 = []; // path commands of original path p\n\n  var pcoms2 = []; // path commands of original path p2\n\n  var pfirst = ''; // temporary holder for original path command\n\n  var pcom = ''; // holder for previous path command of original path\n\n  var ii;\n\n  var processPath = function (path, d, pcom) {\n    var nx, ny;\n\n    if (!path) {\n      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n    }\n\n    !(path[0] in {\n      T: 1,\n      Q: 1\n    }) && (d.qx = d.qy = null);\n\n    switch (path[0]) {\n      case 'M':\n        d.X = path[1];\n        d.Y = path[2];\n        break;\n\n      case 'A':\n        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n        break;\n\n      case 'S':\n        if (pcom === 'C' || pcom === 'S') {\n          // In \"S\" case we have to take into account, if the previous command is C/S.\n          nx = d.x * 2 - d.bx; // And reflect the previous\n\n          ny = d.y * 2 - d.by; // command's control point relative to the current point.\n        } else {\n          // or some else or nothing\n          nx = d.x;\n          ny = d.y;\n        }\n\n        path = ['C', nx, ny].concat(path.slice(1));\n        break;\n\n      case 'T':\n        if (pcom === 'Q' || pcom === 'T') {\n          // In \"T\" case we have to take into account, if the previous command is Q/T.\n          d.qx = d.x * 2 - d.qx; // And make a reflection similar\n\n          d.qy = d.y * 2 - d.qy; // to case \"S\".\n        } else {\n          // or something else or nothing\n          d.qx = d.x;\n          d.qy = d.y;\n        }\n\n        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n        break;\n\n      case 'Q':\n        d.qx = path[1];\n        d.qy = path[2];\n        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n        break;\n\n      case 'L':\n        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));\n        break;\n\n      case 'H':\n        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));\n        break;\n\n      case 'V':\n        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));\n        break;\n\n      case 'Z':\n        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));\n        break;\n\n      default:\n        break;\n    }\n\n    return path;\n  };\n\n  var fixArc = function (pp, i) {\n    if (pp[i].length > 7) {\n      pp[i].shift();\n      var pi = pp[i];\n\n      while (pi.length) {\n        pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved\n\n        p2 && (pcoms2[i] = 'A'); // the same as above\n\n        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n      }\n\n      pp.splice(i, 1);\n      ii = Math.max(p.length, p2 && p2.length || 0);\n    }\n  };\n\n  var fixM = function (path1, path2, a1, a2, i) {\n    if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {\n      path2.splice(i, 0, ['M', a2.x, a2.y]);\n      a1.bx = 0;\n      a1.by = 0;\n      a1.x = path1[i][1];\n      a1.y = path1[i][2];\n      ii = Math.max(p.length, p2 && p2.length || 0);\n    }\n  };\n\n  ii = Math.max(p.length, p2 && p2.length || 0);\n\n  for (var i = 0; i < ii; i++) {\n    p[i] && (pfirst = p[i][0]); // save current path command\n\n    if (pfirst !== 'C') {\n      // C is not saved yet, because it may be result of conversion\n      pcoms1[i] = pfirst; // Save current path command\n\n      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n    }\n\n    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n    if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command\n    // which may produce multiple C:s\n    // so we have to make sure that C is also C in original path\n\n    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n    if (p2) {\n      // the same procedures is done to p2\n      p2[i] && (pfirst = p2[i][0]);\n\n      if (pfirst !== 'C') {\n        pcoms2[i] = pfirst;\n        i && (pcom = pcoms2[i - 1]);\n      }\n\n      p2[i] = processPath(p2[i], attrs2, pcom);\n\n      if (pcoms2[i] !== 'A' && pfirst === 'C') {\n        pcoms2[i] = 'C';\n      }\n\n      fixArc(p2, i);\n    }\n\n    fixM(p, p2, attrs, attrs2, i);\n    fixM(p2, p, attrs2, attrs, i);\n    var seg = p[i];\n    var seg2 = p2 && p2[i];\n    var seglen = seg.length;\n    var seg2len = p2 && seg2.length;\n    attrs.x = seg[seglen - 2];\n    attrs.y = seg[seglen - 1];\n    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);\n    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);\n    attrs2.x = p2 && seg2[seg2len - 2];\n    attrs2.y = p2 && seg2[seg2len - 1];\n  }\n\n  return p2 ? [p, p2] : p;\n}","map":{"version":3,"sources":["../src/path-2-curve.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import path2Absolute from './path-2-absolute';\nvar a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n    // for more information of where this math came from visit:\n    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n    if (rx === ry) {\n        rx += 1;\n    }\n    var _120 = (Math.PI * 120) / 180;\n    var rad = (Math.PI / 180) * (+angle || 0);\n    var res = [];\n    var xy;\n    var f1;\n    var f2;\n    var cx;\n    var cy;\n    var rotate = function (x, y, rad) {\n        var X = x * Math.cos(rad) - y * Math.sin(rad);\n        var Y = x * Math.sin(rad) + y * Math.cos(rad);\n        return {\n            x: X,\n            y: Y,\n        };\n    };\n    if (!recursive) {\n        xy = rotate(x1, y1, -rad);\n        x1 = xy.x;\n        y1 = xy.y;\n        xy = rotate(x2, y2, -rad);\n        x2 = xy.x;\n        y2 = xy.y;\n        if (x1 === x2 && y1 === y2) {\n            // 若弧的起始点和终点重叠则错开一点\n            x2 += 1;\n            y2 += 1;\n        }\n        // const cos = Math.cos(Math.PI / 180 * angle);\n        // const sin = Math.sin(Math.PI / 180 * angle);\n        var x = (x1 - x2) / 2;\n        var y = (y1 - y2) / 2;\n        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            rx = h * rx;\n            ry = h * ry;\n        }\n        var rx2 = rx * rx;\n        var ry2 = ry * ry;\n        var k = (large_arc_flag === sweep_flag ? -1 : 1) *\n            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n        cx = (k * rx * y) / ry + (x1 + x2) / 2;\n        cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n        f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n        f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n        f1 = x1 < cx ? Math.PI - f1 : f1;\n        f2 = x2 < cx ? Math.PI - f2 : f2;\n        f1 < 0 && (f1 = Math.PI * 2 + f1);\n        f2 < 0 && (f2 = Math.PI * 2 + f2);\n        if (sweep_flag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweep_flag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    }\n    else {\n        f1 = recursive[0];\n        f2 = recursive[1];\n        cx = recursive[2];\n        cy = recursive[3];\n    }\n    var df = f2 - f1;\n    if (Math.abs(df) > _120) {\n        var f2old = f2;\n        var x2old = x2;\n        var y2old = y2;\n        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n        x2 = cx + rx * Math.cos(f2);\n        y2 = cy + ry * Math.sin(f2);\n        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    var c1 = Math.cos(f1);\n    var s1 = Math.sin(f1);\n    var c2 = Math.cos(f2);\n    var s2 = Math.sin(f2);\n    var t = Math.tan(df / 4);\n    var hx = (4 / 3) * rx * t;\n    var hy = (4 / 3) * ry * t;\n    var m1 = [x1, y1];\n    var m2 = [x1 + hx * s1, y1 - hy * c1];\n    var m3 = [x2 + hx * s2, y2 - hy * c2];\n    var m4 = [x2, y2];\n    m2[0] = 2 * m1[0] - m2[0];\n    m2[1] = 2 * m1[1] - m2[1];\n    if (recursive) {\n        return [m2, m3, m4].concat(res);\n    }\n    res = [m2, m3, m4]\n        .concat(res)\n        .join()\n        .split(',');\n    var newres = [];\n    for (var i = 0, ii = res.length; i < ii; i++) {\n        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n    }\n    return newres;\n};\nvar l2c = function (x1, y1, x2, y2) {\n    return [x1, y1, x2, y2, x2, y2];\n};\nvar q2c = function (x1, y1, ax, ay, x2, y2) {\n    var _13 = 1 / 3;\n    var _23 = 2 / 3;\n    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n};\nexport default function pathTocurve(path, path2) {\n    var p = path2Absolute(path);\n    var p2 = path2 && path2Absolute(path2);\n    var attrs = {\n        x: 0,\n        y: 0,\n        bx: 0,\n        by: 0,\n        X: 0,\n        Y: 0,\n        qx: null,\n        qy: null,\n    };\n    var attrs2 = {\n        x: 0,\n        y: 0,\n        bx: 0,\n        by: 0,\n        X: 0,\n        Y: 0,\n        qx: null,\n        qy: null,\n    };\n    var pcoms1 = []; // path commands of original path p\n    var pcoms2 = []; // path commands of original path p2\n    var pfirst = ''; // temporary holder for original path command\n    var pcom = ''; // holder for previous path command of original path\n    var ii;\n    var processPath = function (path, d, pcom) {\n        var nx, ny;\n        if (!path) {\n            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n        }\n        !(path[0] in\n            {\n                T: 1,\n                Q: 1,\n            }) && (d.qx = d.qy = null);\n        switch (path[0]) {\n            case 'M':\n                d.X = path[1];\n                d.Y = path[2];\n                break;\n            case 'A':\n                path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                break;\n            case 'S':\n                if (pcom === 'C' || pcom === 'S') {\n                    // In \"S\" case we have to take into account, if the previous command is C/S.\n                    nx = d.x * 2 - d.bx; // And reflect the previous\n                    ny = d.y * 2 - d.by; // command's control point relative to the current point.\n                }\n                else {\n                    // or some else or nothing\n                    nx = d.x;\n                    ny = d.y;\n                }\n                path = ['C', nx, ny].concat(path.slice(1));\n                break;\n            case 'T':\n                if (pcom === 'Q' || pcom === 'T') {\n                    // In \"T\" case we have to take into account, if the previous command is Q/T.\n                    d.qx = d.x * 2 - d.qx; // And make a reflection similar\n                    d.qy = d.y * 2 - d.qy; // to case \"S\".\n                }\n                else {\n                    // or something else or nothing\n                    d.qx = d.x;\n                    d.qy = d.y;\n                }\n                path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                break;\n            case 'Q':\n                d.qx = path[1];\n                d.qy = path[2];\n                path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                break;\n            case 'L':\n                path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));\n                break;\n            case 'H':\n                path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));\n                break;\n            case 'V':\n                path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));\n                break;\n            case 'Z':\n                path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));\n                break;\n            default:\n                break;\n        }\n        return path;\n    };\n    var fixArc = function (pp, i) {\n        if (pp[i].length > 7) {\n            pp[i].shift();\n            var pi = pp[i];\n            while (pi.length) {\n                pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved\n                p2 && (pcoms2[i] = 'A'); // the same as above\n                pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n            }\n            pp.splice(i, 1);\n            ii = Math.max(p.length, (p2 && p2.length) || 0);\n        }\n    };\n    var fixM = function (path1, path2, a1, a2, i) {\n        if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {\n            path2.splice(i, 0, ['M', a2.x, a2.y]);\n            a1.bx = 0;\n            a1.by = 0;\n            a1.x = path1[i][1];\n            a1.y = path1[i][2];\n            ii = Math.max(p.length, (p2 && p2.length) || 0);\n        }\n    };\n    ii = Math.max(p.length, (p2 && p2.length) || 0);\n    for (var i = 0; i < ii; i++) {\n        p[i] && (pfirst = p[i][0]); // save current path command\n        if (pfirst !== 'C') {\n            // C is not saved yet, because it may be result of conversion\n            pcoms1[i] = pfirst; // Save current path command\n            i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\n        }\n        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n        if (pcoms1[i] !== 'A' && pfirst === 'C')\n            pcoms1[i] = 'C'; // A is the only command\n        // which may produce multiple C:s\n        // so we have to make sure that C is also C in original path\n        fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n        if (p2) {\n            // the same procedures is done to p2\n            p2[i] && (pfirst = p2[i][0]);\n            if (pfirst !== 'C') {\n                pcoms2[i] = pfirst;\n                i && (pcom = pcoms2[i - 1]);\n            }\n            p2[i] = processPath(p2[i], attrs2, pcom);\n            if (pcoms2[i] !== 'A' && pfirst === 'C') {\n                pcoms2[i] = 'C';\n            }\n            fixArc(p2, i);\n        }\n        fixM(p, p2, attrs, attrs2, i);\n        fixM(p2, p, attrs2, attrs, i);\n        var seg = p[i];\n        var seg2 = p2 && p2[i];\n        var seglen = seg.length;\n        var seg2len = p2 && seg2.length;\n        attrs.x = seg[seglen - 2];\n        attrs.y = seg[seglen - 1];\n        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n        attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);\n        attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);\n        attrs2.x = p2 && seg2[seg2len - 2];\n        attrs2.y = p2 && seg2[seg2len - 1];\n    }\n    return p2 ? [p, p2] : p;\n}\n//# sourceMappingURL=path-2-curve.js.map"]},"metadata":{},"sourceType":"module"}