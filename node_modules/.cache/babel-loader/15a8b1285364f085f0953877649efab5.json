{"ast":null,"code":"import { distance, getBBoxByArray } from './util';\nimport * as vec2 from 'gl-matrix/vec2';\nexport default {\n  /**\n   * 计算线段的包围盒\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {object} 包围盒对象\n   */\n  box: function (x1, y1, x2, y2) {\n    return getBBoxByArray([x1, x2], [y1, y2]);\n  },\n\n  /**\n   * 线段的长度\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {number} 距离\n   */\n  length: function (x1, y1, x2, y2) {\n    return distance(x1, y1, x2, y2);\n  },\n\n  /**\n   * 根据比例获取点\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} t 指定比例\n   * @return {object} 包含 x, y 的点\n   */\n  pointAt: function (x1, y1, x2, y2, t) {\n    return {\n      x: (1 - t) * x1 + t * x2,\n      y: (1 - t) * y1 + t * y2\n    };\n  },\n\n  /**\n   * 点到线段的距离\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} x  测试点 x\n   * @param {number} y  测试点 y\n   * @return {number} 距离\n   */\n  pointDistance: function (x1, y1, x2, y2, x, y) {\n    // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n    // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\n    if (cross < 0) {\n      return distance(x1, y1, x, y);\n    }\n\n    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\n    if (cross > lengthSquare) {\n      return distance(x2, y2, x, y);\n    }\n\n    return this.pointToLine(x1, y1, x2, y2, x, y);\n  },\n\n  /**\n   * 点到直线的距离，而不是点到线段的距离\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} x  测试点 x\n   * @param {number} y  测试点 y\n   * @return {number} 距离\n   */\n  pointToLine: function (x1, y1, x2, y2, x, y) {\n    var d = [x2 - x1, y2 - y1]; // 如果端点相等，则判定点到点的距离\n\n    if (vec2.exactEquals(d, [0, 0])) {\n      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n    }\n\n    var u = [-d[1], d[0]];\n    vec2.normalize(u, u);\n    var a = [x - x1, y - y1];\n    return Math.abs(vec2.dot(a, u));\n  },\n\n  /**\n   * 线段的角度\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {number} 导数\n   */\n  tangentAngle: function (x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1);\n  }\n};","map":{"version":3,"sources":["../src/line.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { distance, getBBoxByArray } from './util';\nimport * as vec2 from 'gl-matrix/vec2';\nexport default {\n    /**\n     * 计算线段的包围盒\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @return {object} 包围盒对象\n     */\n    box: function (x1, y1, x2, y2) {\n        return getBBoxByArray([x1, x2], [y1, y2]);\n    },\n    /**\n     * 线段的长度\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @return {number} 距离\n     */\n    length: function (x1, y1, x2, y2) {\n        return distance(x1, y1, x2, y2);\n    },\n    /**\n     * 根据比例获取点\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @param {number} t 指定比例\n     * @return {object} 包含 x, y 的点\n     */\n    pointAt: function (x1, y1, x2, y2, t) {\n        return {\n            x: (1 - t) * x1 + t * x2,\n            y: (1 - t) * y1 + t * y2,\n        };\n    },\n    /**\n     * 点到线段的距离\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @param {number} x  测试点 x\n     * @param {number} y  测试点 y\n     * @return {number} 距离\n     */\n    pointDistance: function (x1, y1, x2, y2, x, y) {\n        // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n        // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n        var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n        if (cross < 0) {\n            return distance(x1, y1, x, y);\n        }\n        var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n        if (cross > lengthSquare) {\n            return distance(x2, y2, x, y);\n        }\n        return this.pointToLine(x1, y1, x2, y2, x, y);\n    },\n    /**\n     * 点到直线的距离，而不是点到线段的距离\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @param {number} x  测试点 x\n     * @param {number} y  测试点 y\n     * @return {number} 距离\n     */\n    pointToLine: function (x1, y1, x2, y2, x, y) {\n        var d = [x2 - x1, y2 - y1];\n        // 如果端点相等，则判定点到点的距离\n        if (vec2.exactEquals(d, [0, 0])) {\n            return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n        }\n        var u = [-d[1], d[0]];\n        vec2.normalize(u, u);\n        var a = [x - x1, y - y1];\n        return Math.abs(vec2.dot(a, u));\n    },\n    /**\n     * 线段的角度\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @return {number} 导数\n     */\n    tangentAngle: function (x1, y1, x2, y2) {\n        return Math.atan2(y2 - y1, x2 - x1);\n    },\n};\n//# sourceMappingURL=line.js.map"]},"metadata":{},"sourceType":"module"}