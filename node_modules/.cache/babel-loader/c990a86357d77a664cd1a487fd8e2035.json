{"ast":null,"code":"import { each, isArray } from '@antv/util';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\n\nfunction getShapeAttrs(cfg, smooth, constraint) {\n  var isStack = cfg.isStack,\n      connectNulls = cfg.connectNulls,\n      isInCircle = cfg.isInCircle,\n      showSinglePoint = cfg.showSinglePoint;\n  var shapeAttrs = getStyle(cfg, true, false, 'lineWidth');\n  var points = getPathPoints(cfg.points, connectNulls, showSinglePoint); // 根据 connectNulls 值处理 points\n\n  var path = [];\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var eachLinePoints = points[i];\n    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));\n  }\n\n  shapeAttrs.path = path;\n  return shapeAttrs;\n} // 单条 path\n\n\nfunction getSinglePath(points, isInCircle, smooth, constraint, style) {\n  if (points.length === 1) {\n    // 只有一个点时\n    return [['M', points[0].x, points[0].y - style.lineWidth / 2], ['L', points[0].x, points[0].y], ['L', points[0].x, points[0].y + style.lineWidth / 2]];\n  }\n\n  var path;\n\n  if (!smooth) {\n    path = getLinePath(points, false);\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  } else {\n    // 直角坐标系下绘制曲线时限制最大值、最小值\n    if (isInCircle && points.length) {\n      points.push({\n        x: points[0].x,\n        y: points[0].y\n      });\n    }\n\n    path = getSplinePath(points, false, constraint);\n  }\n\n  return path;\n}\n\nfunction getRangePath(points, isInCircle, isStack, smooth, constraint, style) {\n  var topPoints = [];\n  var bottomPoints = [];\n  each(points, function (point) {\n    var result = splitPoints(point);\n    topPoints.push(result[1]); // 上边\n\n    bottomPoints.push(result[0]); // 底边\n  });\n  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);\n  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);\n\n  if (isStack) {\n    return topPath;\n  }\n\n  return topPath.concat(bottomPath);\n}\n\nfunction getPath(points, isInCircle, isStack, smooth, constraint, style) {\n  if (points.length) {\n    var first = points[0];\n    return isArray(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);\n  }\n\n  return [];\n}\n\nvar LineShapeFactory = registerShapeFactory('line', {\n  defaultShapeType: 'line'\n}); // 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\n\neach(['line', 'dot', 'dash', 'smooth'], function (shapeType) {\n  registerShape('line', shapeType, {\n    draw: function (cfg, container) {\n      var smooth = shapeType === 'smooth';\n      var constraint;\n\n      if (smooth) {\n        var _a = this.coordinate,\n            start = _a.start,\n            end = _a.end;\n        constraint = [[start.x, end.y], [end.x, start.y]];\n      }\n\n      var attrs = getShapeAttrs(cfg, smooth, constraint);\n      var shape = container.addShape({\n        type: 'path',\n        attrs: attrs,\n        name: 'line',\n        capture: !smooth\n      });\n      return shape;\n    },\n    getMarker: function (markerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    }\n  });\n});\nexport default LineShapeFactory;","map":{"version":3,"sources":["../../../../src/geometry/shape/line/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { each, isArray } from '@antv/util';\nimport { IGroup, ShapeAttrs } from '../../../dependents';\nimport { Point, Position, RangePoint, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\n\nfunction getShapeAttrs(cfg: ShapeInfo, smooth?: boolean, constraint?: Position[]) {\n  const { isStack, connectNulls, isInCircle, showSinglePoint } = cfg;\n  const shapeAttrs = getStyle(cfg, true, false, 'lineWidth');\n\n  const points = getPathPoints(cfg.points, connectNulls, showSinglePoint); // 根据 connectNulls 值处理 points\n  let path = [];\n  for (let i = 0, len = points.length; i < len; i++) {\n    const eachLinePoints = points[i];\n    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));\n  }\n  shapeAttrs.path = path;\n\n  return shapeAttrs;\n}\n\n// 单条 path\nfunction getSinglePath(\n  points: Point[],\n  isInCircle: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  if (points.length === 1) {\n    // 只有一个点时\n    return [\n      ['M', points[0].x, points[0].y - style.lineWidth / 2],\n      ['L', points[0].x, points[0].y],\n      ['L', points[0].x, points[0].y + style.lineWidth / 2],\n    ];\n  }\n\n  let path;\n  if (!smooth) {\n    path = getLinePath(points, false);\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  } else {\n    // 直角坐标系下绘制曲线时限制最大值、最小值\n    if (isInCircle && points.length) {\n      points.push({ x: points[0].x, y: points[0].y });\n    }\n    path = getSplinePath(points, false, constraint);\n  }\n\n  return path;\n}\n\nfunction getRangePath(\n  points: RangePoint[],\n  isInCircle: boolean,\n  isStack?: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  const topPoints = [];\n  const bottomPoints = [];\n  each(points, (point: RangePoint) => {\n    const result = splitPoints(point);\n    topPoints.push(result[1]); // 上边\n    bottomPoints.push(result[0]); // 底边\n  });\n\n  const topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);\n  const bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);\n  if (isStack) {\n    return topPath;\n  }\n  return topPath.concat(bottomPath);\n}\n\nfunction getPath(\n  points: Point[] | RangePoint[],\n  isInCircle: boolean,\n  isStack?: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  if (points.length) {\n    const first = points[0];\n\n    return isArray(first.y)\n      ? getRangePath(points as RangePoint[], isInCircle, isStack, smooth, constraint, style)\n      : getSinglePath(points as Point[], isInCircle, smooth, constraint, style);\n  }\n  return [];\n}\n\nconst LineShapeFactory = registerShapeFactory('line', {\n  defaultShapeType: 'line',\n});\n\n// 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\neach(['line', 'dot', 'dash', 'smooth'], (shapeType) => {\n  registerShape('line', shapeType, {\n    draw(cfg: ShapeInfo, container: IGroup) {\n      const smooth = shapeType === 'smooth';\n      let constraint;\n      if (smooth) {\n        const { start, end } = this.coordinate;\n        constraint = [\n          [start.x, end.y],\n          [end.x, start.y],\n        ];\n      }\n\n      const attrs = getShapeAttrs(cfg, smooth, constraint);\n      const shape = container.addShape({\n        type: 'path',\n        attrs,\n        name: 'line',\n        capture: !smooth,\n      });\n\n      return shape;\n    },\n    getMarker(markerCfg: ShapeMarkerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    },\n  });\n});\n\nexport default LineShapeFactory;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}