{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nvar dot = vec2.dot;\n/**\n * @private\n * 1. 获取投影轴\n */\n\nfunction getAxes(points\n/** 多边形的关键点 */\n) {\n  // 目前先处理 平行矩形 的场景, 其他多边形不处理\n  if (points.length > 4) {\n    return [];\n  } // 获取向量\n\n\n  var vector = function (start, end) {\n    return [end.x - start.x, end.y - start.y];\n  }; // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n\n\n  var AB = vector(points[0], points[1]);\n  var BC = vector(points[1], points[2]);\n  return [AB, BC];\n}\n/**\n * @private\n * 绕指定点顺时针旋转后的点坐标\n * 默认绕原点旋转\n */\n\n\nfunction rotateAtPoint(point, deg, origin) {\n  if (deg === void 0) {\n    deg = 0;\n  }\n\n  if (origin === void 0) {\n    origin = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var x = point.x,\n      y = point.y;\n  return {\n    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y\n  };\n}\n/**\n * @private\n * 转化为顶点坐标数组\n *\n * @param {Object} box\n */\n\n\nfunction getRectPoints(box) {\n  var points = [{\n    x: box.x,\n    y: box.y\n  }, {\n    x: box.x + box.width,\n    y: box.y\n  }, {\n    x: box.x + box.width,\n    y: box.y + box.height\n  }, {\n    x: box.x,\n    y: box.y + box.height\n  }];\n  var rotation = box.rotation;\n\n  if (rotation) {\n    return [rotateAtPoint(points[0], rotation, points[0]), rotateAtPoint(points[1], rotation, points[0]), rotateAtPoint(points[2], rotation, points[0]), rotateAtPoint(points[3], rotation, points[0])];\n  }\n\n  return points;\n}\n/**\n * @private\n * 2. 获取多边形在投影轴上的投影\n *\n * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n */\n\n\nfunction getProjection(points\n/** 多边形的关键点 */\n, axis) {\n  // 目前先处理矩形的场景\n  if (points.length > 4) {\n    return {\n      min: 0,\n      max: 0\n    };\n  }\n\n  var scalars = [];\n  points.forEach(function (point) {\n    scalars.push(dot([point.x, point.y], axis));\n  });\n  return {\n    min: Math.min.apply(Math, scalars),\n    max: Math.max.apply(Math, scalars)\n  };\n}\n\nfunction isProjectionOverlap(projection1, projection2) {\n  return projection1.max > projection2.min && projection1.min < projection2.max;\n}\n/**\n * 快速判断两个无旋转矩形是否遮挡\n */\n\n\nexport function isIntersectRect(box1, box2, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);\n}\n/**\n * detect whether two shape is intersected, useful when shape is been rotated\n * 判断两个矩形是否重叠（相交和包含, 是否旋转）\n *\n * - 原理: 分离轴定律\n */\n\nexport function isIntersect(box1, box2) {\n  // 如果两个矩形没有旋转，使用快速判断\n  if (!box1.rotation && !box2.rotation) {\n    return isIntersectRect(box1, box2);\n  } // 分别获取 4 个关键点\n\n\n  var rect1Points = getRectPoints(box1);\n  var rect2Points = getRectPoints(box2); // 获取所有投影轴\n\n  var axes = __spreadArrays(getAxes(rect1Points), getAxes(rect2Points));\n\n  for (var i = 0; i < axes.length; i++) {\n    var axis = axes[i];\n    var projection1 = getProjection(rect1Points, axis);\n    var projection2 = getProjection(rect2Points, axis); // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n\n    if (!isProjectionOverlap(projection1, projection2)) return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["../../src/util/collision-detect.ts"],"names":[],"mappings":"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","sourcesContent":["import { vec2 } from '@antv/matrix-util'; \nimport { BBox, Point } from '../dependents';\n\nconst { dot } = vec2;\ntype Vec2 = [number, number];\n\n\ntype Box = Pick<BBox, 'x' | 'y' | 'width' | 'height'> & { rotation?: number };\n\n/**\n * 定义投影对象\n */\ntype Projection = { min: number; max: number };\n\n/**\n * @private\n * 1. 获取投影轴\n */\nfunction getAxes(points: Point[] /** 多边形的关键点 */): Vec2[] {\n  // 目前先处理 平行矩形 的场景, 其他多边形不处理\n  if (points.length > 4) {\n    return [];\n  }\n  // 获取向量\n  const vector = (start: Point, end: Point): Vec2 => {\n    return [end.x - start.x, end.y - start.y];\n  };\n\n  // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n  const AB = vector(points[0], points[1]);\n  const BC = vector(points[1], points[2]);\n\n  return [AB, BC];\n}\n\n/**\n * @private\n * 绕指定点顺时针旋转后的点坐标\n * 默认绕原点旋转\n */\nfunction rotateAtPoint(point: Point, deg = 0, origin = { x: 0, y: 0 }): Point {\n  const { x, y } = point;\n  return {\n    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n  };\n}\n\n/**\n * @private\n * 转化为顶点坐标数组\n *\n * @param {Object} box\n */\nfunction getRectPoints(box: Box): Point[] {\n  const points = [\n    { x: box.x, y: box.y },\n    { x: box.x + box.width, y: box.y },\n    { x: box.x + box.width, y: box.y + box.height },\n    { x: box.x, y: box.y + box.height },\n  ];\n\n  const rotation = box.rotation;\n  if (rotation) {\n    return [\n      rotateAtPoint(points[0], rotation, points[0]),\n      rotateAtPoint(points[1], rotation, points[0]),\n      rotateAtPoint(points[2], rotation, points[0]),\n      rotateAtPoint(points[3], rotation, points[0]),\n    ];\n  }\n\n  return points;\n}\n\n/**\n * @private\n * 2. 获取多边形在投影轴上的投影\n *\n * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n */\nfunction getProjection(points: Point[] /** 多边形的关键点 */, axis: Vec2): Projection {\n  // 目前先处理矩形的场景\n  if (points.length > 4) {\n    return { min: 0, max: 0 };\n  }\n\n  const scalars = [];\n  points.forEach((point) => {\n    scalars.push(dot([point.x, point.y], axis));\n  });\n\n  return { min: Math.min(...scalars), max: Math.max(...scalars) };\n}\n\nfunction isProjectionOverlap(projection1: Projection, projection2: Projection): boolean {\n  return projection1.max > projection2.min && projection1.min < projection2.max;\n}\n\n/**\n * 快速判断两个无旋转矩形是否遮挡\n */\nexport function isIntersectRect(box1: Box, box2: Box, margin: number = 0): boolean {\n  return !(\n    box2.x > box1.x + box1.width + margin ||\n    box2.x + box2.width < box1.x - margin ||\n    box2.y > box1.y + box1.height + margin ||\n    box2.y + box2.height < box1.y - margin\n  );\n}\n\n/**\n * detect whether two shape is intersected, useful when shape is been rotated\n * 判断两个矩形是否重叠（相交和包含, 是否旋转）\n *\n * - 原理: 分离轴定律\n */\nexport function isIntersect(box1: Box, box2: Box) {\n\n  // 如果两个矩形没有旋转，使用快速判断\n  if (!box1.rotation && !box2.rotation) {\n    return isIntersectRect(box1, box2);\n  }\n\n  // 分别获取 4 个关键点\n  const rect1Points = getRectPoints(box1);\n  const rect2Points = getRectPoints(box2);\n\n  // 获取所有投影轴\n  const axes = [...getAxes(rect1Points), ...getAxes(rect2Points)];\n\n  for (let i = 0; i < axes.length; i++) {\n    const axis = axes[i];\n    const projection1 = getProjection(rect1Points, axis);\n    const projection2 = getProjection(rect2Points, axis);\n\n    // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n    if (!isProjectionOverlap(projection1, projection2)) return false;\n  }\n\n  return true;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}