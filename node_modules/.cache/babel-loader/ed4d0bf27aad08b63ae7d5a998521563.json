{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { ext, vec2 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\n/**\n * 螺旋坐标系\n */\n\nvar Helix =\n/** @class */\nfunction (_super) {\n  __extends(Helix, _super);\n\n  function Helix(cfg) {\n    var _this = _super.call(this, cfg) || this;\n\n    _this.isHelix = true;\n    _this.type = 'helix';\n    var _a = cfg.startAngle,\n        startAngle = _a === void 0 ? 1.25 * Math.PI : _a,\n        _b = cfg.endAngle,\n        endAngle = _b === void 0 ? 7.25 * Math.PI : _b,\n        _c = cfg.innerRadius,\n        innerRadius = _c === void 0 ? 0 : _c,\n        radius = cfg.radius;\n    _this.startAngle = startAngle;\n    _this.endAngle = endAngle;\n    _this.innerRadius = innerRadius;\n    _this.radius = radius;\n\n    _this.initial();\n\n    return _this;\n  }\n\n  Helix.prototype.initial = function () {\n    _super.prototype.initial.call(this);\n\n    var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // 螺线圈数\n\n    var maxRadius = Math.min(this.width, this.height) / 2;\n\n    if (this.radius && this.radius >= 0 && this.radius <= 1) {\n      maxRadius = maxRadius * this.radius;\n    }\n\n    this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);\n    this.a = this.d / (Math.PI * 2); // 螺线系数\n\n    this.x = {\n      start: this.startAngle,\n      end: this.endAngle\n    };\n    this.y = {\n      start: this.innerRadius * maxRadius,\n      end: this.innerRadius * maxRadius + this.d * 0.99\n    };\n  };\n  /**\n   * 将百分比数据变成屏幕坐标\n   * @param point 归一化的点坐标\n   * @return      返回对应的屏幕坐标\n   */\n\n\n  Helix.prototype.convertPoint = function (point) {\n    var _a;\n\n    var x = point.x,\n        y = point.y;\n\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n\n    var thi = this.convertDim(x, 'x');\n    var r = this.a * thi;\n    var newY = this.convertDim(y, 'y');\n    return {\n      x: this.center.x + Math.cos(thi) * (r + newY),\n      y: this.center.y + Math.sin(thi) * (r + newY)\n    };\n  };\n  /**\n   * 将屏幕坐标点还原成百分比数据\n   * @param point 屏幕坐标\n   * @return      返回对应的归一化后的数据\n   */\n\n\n  Helix.prototype.invertPoint = function (point) {\n    var _a;\n\n    var d = this.d + this.y.start;\n    var v = vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);\n    var thi = ext.angleTo(v, [1, 0], true);\n    var rMin = thi * this.a; // 坐标与原点的连线在第一圈上的交点，最小r值\n\n    if (vec2.length(v) < rMin) {\n      // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况\n      rMin = vec2.length(v);\n    }\n\n    var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈\n\n    thi = 2 * index * Math.PI + thi;\n    var r = this.a * thi;\n    var newY = vec2.length(v) - r;\n    newY = isNumberEqual(newY, 0) ? 0 : newY;\n    var x = this.invertDim(thi, 'x');\n    var y = this.invertDim(newY, 'y');\n    x = isNumberEqual(x, 0) ? 0 : x;\n    y = isNumberEqual(y, 0) ? 0 : y;\n\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  return Helix;\n}(Coordinate);\n\nexport default Helix;","map":{"version":3,"sources":["../../src/coord/helix.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { ext, vec2 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\n/**\n * 螺旋坐标系\n */\nvar Helix = /** @class */ (function (_super) {\n    __extends(Helix, _super);\n    function Helix(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.isHelix = true;\n        _this.type = 'helix';\n        var _a = cfg.startAngle, startAngle = _a === void 0 ? 1.25 * Math.PI : _a, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;\n        _this.startAngle = startAngle;\n        _this.endAngle = endAngle;\n        _this.innerRadius = innerRadius;\n        _this.radius = radius;\n        _this.initial();\n        return _this;\n    }\n    Helix.prototype.initial = function () {\n        _super.prototype.initial.call(this);\n        var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // 螺线圈数\n        var maxRadius = Math.min(this.width, this.height) / 2;\n        if (this.radius && this.radius >= 0 && this.radius <= 1) {\n            maxRadius = maxRadius * this.radius;\n        }\n        this.d = Math.floor((maxRadius * (1 - this.innerRadius)) / index);\n        this.a = this.d / (Math.PI * 2); // 螺线系数\n        this.x = {\n            start: this.startAngle,\n            end: this.endAngle,\n        };\n        this.y = {\n            start: this.innerRadius * maxRadius,\n            end: this.innerRadius * maxRadius + this.d * 0.99,\n        };\n    };\n    /**\n     * 将百分比数据变成屏幕坐标\n     * @param point 归一化的点坐标\n     * @return      返回对应的屏幕坐标\n     */\n    Helix.prototype.convertPoint = function (point) {\n        var _a;\n        var x = point.x, y = point.y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        var thi = this.convertDim(x, 'x');\n        var r = this.a * thi;\n        var newY = this.convertDim(y, 'y');\n        return {\n            x: this.center.x + Math.cos(thi) * (r + newY),\n            y: this.center.y + Math.sin(thi) * (r + newY),\n        };\n    };\n    /**\n     * 将屏幕坐标点还原成百分比数据\n     * @param point 屏幕坐标\n     * @return      返回对应的归一化后的数据\n     */\n    Helix.prototype.invertPoint = function (point) {\n        var _a;\n        var d = this.d + this.y.start;\n        var v = vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);\n        var thi = ext.angleTo(v, [1, 0], true);\n        var rMin = thi * this.a; // 坐标与原点的连线在第一圈上的交点，最小r值\n        if (vec2.length(v) < rMin) {\n            // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况\n            rMin = vec2.length(v);\n        }\n        var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈\n        thi = 2 * index * Math.PI + thi;\n        var r = this.a * thi;\n        var newY = vec2.length(v) - r;\n        newY = isNumberEqual(newY, 0) ? 0 : newY;\n        var x = this.invertDim(thi, 'x');\n        var y = this.invertDim(newY, 'y');\n        x = isNumberEqual(x, 0) ? 0 : x;\n        y = isNumberEqual(y, 0) ? 0 : y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        return { x: x, y: y };\n    };\n    return Helix;\n}(Coordinate));\nexport default Helix;\n//# sourceMappingURL=helix.js.map"]},"metadata":{},"sourceType":"module"}