{"ast":null,"code":"import { vec2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\nimport { getDistanceToCenter } from '../../../util/coordinate';\n\nfunction _points2path(points, isInCircle) {\n  var path = [];\n\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n\n    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {\n      var item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n\n  return path;\n}\n\nfunction _convertArr(arr, coord) {\n  var tmp = [arr[0]];\n\n  for (var i = 1, len = arr.length; i < len; i = i + 2) {\n    var point = coord.convert({\n      x: arr[i],\n      y: arr[i + 1]\n    });\n    tmp.push(point.x, point.y);\n  }\n\n  return tmp;\n}\n\nfunction _convertArcPath(path, coord) {\n  var isTransposed = coord.isTransposed;\n  var r = path[1];\n  var x = path[6];\n  var y = path[7];\n  var point = coord.convert({\n    x: x,\n    y: y\n  });\n  var direction = isTransposed ? 0 : 1;\n  return ['A', r, r, 0, 0, direction, point.x, point.y];\n}\n\nfunction _convertPolarPath(pre, cur, coord) {\n  var isTransposed = coord.isTransposed,\n      startAngle = coord.startAngle,\n      endAngle = coord.endAngle;\n  var prePoint = pre[0].toLowerCase() === 'a' ? {\n    x: pre[6],\n    y: pre[7]\n  } : {\n    x: pre[1],\n    y: pre[2]\n  };\n  var curPoint = {\n    x: cur[1],\n    y: cur[2]\n  };\n  var rst = [];\n  var xDim = isTransposed ? 'y' : 'x';\n  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n\n  var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n\n  var convertPoint = coord.convert(curPoint);\n  var r = getDistanceToCenter(coord, convertPoint);\n\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      var middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2\n      };\n      var middleConvertPoint = coord.convert(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n\n  return rst;\n} // 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\n\n\nfunction _filterFullCirleLine(path) {\n  each(path, function (subPath, index) {\n    var cur = subPath;\n\n    if (cur[0].toLowerCase() === 'a') {\n      var pre = path[index - 1];\n      var next = path[index + 1];\n\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\n\n\nexport var smoothBezier = function (points, smooth, isLoop, constraint) {\n  var cps = [];\n  var prevPoint;\n  var nextPoint;\n  var hasConstraint = !!constraint;\n  var min;\n  var max;\n\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n\n    min = vec2.min([0, 0], min, constraint[0]);\n    max = vec2.max([0, 0], max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(point);\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    var v = [0, 0];\n    v = vec2.sub(v, nextPoint, prevPoint);\n    v = vec2.scale(v, v, smooth);\n    var d0 = vec2.distance(point, prevPoint);\n    var d1 = vec2.distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    var v1 = vec2.scale([0, 0], v, -d0);\n    var v2 = vec2.scale([0, 0], v, d1);\n    var cp0 = vec2.add([0, 0], point, v1);\n    var cp1 = vec2.add([0, 0], point, v2);\n\n    if (hasConstraint) {\n      cp0 = vec2.max([0, 0], cp0, min);\n      cp0 = vec2.min([0, 0], cp0, max);\n      cp1 = vec2.max([0, 0], cp1, min);\n      cp1 = vec2.min([0, 0], cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n};\n/**\n * @ignore\n * 贝塞尔曲线\n */\n\nexport function catmullRom2bezier(crp, z, constraint) {\n  var isLoop = !!z;\n  var pointList = [];\n\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n\n  for (var i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  return d1;\n}\n/**\n * @ignore\n * 将点连接成路径 path\n */\n\nexport function getLinePath(points, isInCircle) {\n  return _points2path(points, isInCircle);\n}\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\n\nexport function getSplinePath(points, isInCircle, constaint) {\n  var data = [];\n  var first = points[0];\n  var prePoint = null;\n\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n\n  var constraint = constaint || [// 范围\n  [0, 0], [1, 1]];\n  var splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n/**\n * @ignore\n * 将归一化后的路径数据转换成坐标\n */\n\nexport function convertNormalPath(coord, path) {\n  var tmp = [];\n  each(path, function (subPath) {\n    var action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\n/**\n * @ignore\n * 将路径转换为极坐标下的真实路径\n */\n\nexport function convertPolarPath(coord, path) {\n  var tmp = [];\n  var pre;\n  var cur;\n  var transposed;\n  var equals;\n  each(path, function (subPath, index) {\n    var action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed; // 是否半径相同，转换成圆弧\n\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n\n        break;\n\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n\n\n  return tmp;\n}","map":{"version":3,"sources":["../../../../src/geometry/shape/util/path.ts"],"names":[],"mappings":"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","sourcesContent":["import { vec2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\nimport { Coordinate, PathCommand } from '../../../dependents';\nimport { Point, Position } from '../../../interface';\nimport { getDistanceToCenter } from '../../../util/coordinate';\n\nfunction _points2path(points: Point[], isInCircle: boolean): PathCommand[] {\n  const path = [];\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n    for (let i = 1, length = points.length; i < length; i += 1) {\n      const item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n\n  return path;\n}\n\nfunction _convertArr(arr: number[], coord: Coordinate): any[] {\n  const tmp = [arr[0]];\n  for (let i = 1, len = arr.length; i < len; i = i + 2) {\n    const point = coord.convert({\n      x: arr[i],\n      y: arr[i + 1],\n    });\n    tmp.push(point.x, point.y);\n  }\n  return tmp;\n}\nfunction _convertArcPath(path: PathCommand, coord: Coordinate): any[] {\n  const { isTransposed } = coord;\n  const r = path[1];\n  const x = path[6];\n  const y = path[7];\n  const point = coord.convert({ x, y });\n  const direction = isTransposed ? 0 : 1;\n  return ['A', r, r, 0, 0, direction, point.x, point.y];\n}\n\nfunction _convertPolarPath(pre: PathCommand, cur: PathCommand, coord: Coordinate): PathCommand[] {\n  const { isTransposed, startAngle, endAngle } = coord;\n  const prePoint =\n    pre[0].toLowerCase() === 'a'\n      ? {\n          x: pre[6],\n          y: pre[7],\n        }\n      : {\n          x: pre[1],\n          y: pre[2],\n        };\n  const curPoint = {\n    x: cur[1],\n    y: cur[2],\n  };\n  const rst = [];\n  const xDim = isTransposed ? 'y' : 'x';\n  const angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  const direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n  const flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n  const convertPoint = coord.convert(curPoint);\n  const r = getDistanceToCenter(coord, convertPoint);\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      const middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2,\n      };\n      const middleConvertPoint = coord.convert(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n  return rst;\n}\n\n// 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\nfunction _filterFullCirleLine(path: PathCommand[]) {\n  each(path, (subPath, index) => {\n    const cur = subPath;\n    if (cur[0].toLowerCase() === 'a') {\n      const pre = path[index - 1];\n      const next = path[index + 1];\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport const smoothBezier = (\n  points: Position[],\n  smooth: number,\n  isLoop: boolean,\n  constraint: Position[]\n): Position[] => {\n  const cps = [];\n\n  let prevPoint: Position;\n  let nextPoint: Position;\n  const hasConstraint = !!constraint;\n  let min: Position;\n  let max: Position;\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      min = vec2.min([0, 0], min, point) as [number, number];\n      max = vec2.max([0, 0], max, point) as [number, number];\n    }\n    min = vec2.min([0, 0], min, constraint[0]) as [number, number];\n    max = vec2.max([0, 0], max, constraint[1]) as [number, number];\n  }\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(point);\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n    let v: [number, number] = [0, 0];\n    v = vec2.sub(v, nextPoint, prevPoint) as [number, number];\n    v = vec2.scale(v, v, smooth) as [number, number];\n\n    let d0 = vec2.distance(point, prevPoint);\n    let d1 = vec2.distance(point, nextPoint);\n\n    const sum = d0 + d1;\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    const v1 = vec2.scale([0, 0], v, -d0);\n    const v2 = vec2.scale([0, 0], v, d1);\n\n    let cp0 = vec2.add([0, 0], point, v1);\n    let cp1 = vec2.add([0, 0], point, v2);\n\n    if (hasConstraint) {\n      cp0 = vec2.max([0, 0], cp0, min);\n      cp0 = vec2.min([0, 0], cp0, max);\n      cp1 = vec2.max([0, 0], cp1, min);\n      cp1 = vec2.min([0, 0], cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n  return cps;\n};\n\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp: number[], z: boolean, constraint: Position[]): PathCommand[] {\n  const isLoop = !!z;\n  const pointList = [];\n  for (let i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  const controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  const len = pointList.length;\n  const d1 = [];\n\n  let cp1: Position;\n  let cp2: Position;\n  let p: Position;\n\n  for (let i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n\n/**\n * @ignore\n * 将点连接成路径 path\n */\nexport function getLinePath(points: Point[], isInCircle?: boolean): PathCommand[] {\n  return _points2path(points, isInCircle);\n}\n\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points: Point[], isInCircle?: boolean, constaint?: Position[]): PathCommand[] {\n  const data = [];\n  const first = points[0];\n  let prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n  const constraint = constaint || [\n    // 范围\n    [0, 0],\n    [1, 1],\n  ];\n  const splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n\n/**\n * @ignore\n * 将归一化后的路径数据转换成坐标\n */\nexport function convertNormalPath(coord, path: PathCommand[]): PathCommand[] {\n  const tmp = [];\n  each(path, (subPath) => {\n    const action = subPath[0];\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\n\n/**\n * @ignore\n * 将路径转换为极坐标下的真实路径\n */\nexport function convertPolarPath(coord, path: PathCommand[]): PathCommand[] {\n  let tmp = [];\n  let pre: PathCommand;\n  let cur: PathCommand;\n  let transposed: boolean;\n  let equals: boolean;\n  each(path, (subPath, index) => {\n    const action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed;\n        // 是否半径相同，转换成圆弧\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n  return tmp;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}