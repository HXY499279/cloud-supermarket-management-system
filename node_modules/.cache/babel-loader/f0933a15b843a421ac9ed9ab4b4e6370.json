{"ast":null,"code":"import { toArray } from '@antv/util';\nimport { SHAPE_TO_TAGS } from '../constant';\n/**\n * 创建并返回图形的 svg 元素\n * @param type svg类型\n */\n\nexport function createSVGElement(type) {\n  return document.createElementNS('http://www.w3.org/2000/svg', type);\n}\n/**\n * 创建并返回图形的 dom 元素\n * @param  {IShape} shape 图形\n * @return {SVGElement}\n */\n\nexport function createDom(shape) {\n  var type = SHAPE_TO_TAGS[shape.type];\n  var parent = shape.getParent();\n\n  if (!type) {\n    throw new Error(\"the type \" + shape.type + \" is not supported by svg\");\n  }\n\n  var element = createSVGElement(type);\n\n  if (shape.get('id')) {\n    element.id = shape.get('id');\n  }\n\n  shape.set('el', element);\n  shape.set('attrs', {}); // 对于 defs 下的 dom 节点，parent 为空，通过 context 统一挂载到 defs 节点下\n\n  if (parent) {\n    var parentNode = parent.get('el');\n\n    if (parentNode) {\n      parentNode.appendChild(element);\n    } else {\n      // parentNode maybe null for group\n      parentNode = parent.createDom();\n      parent.set('el', parentNode);\n      parentNode.appendChild(element);\n    }\n  }\n\n  return element;\n}\n/**\n * 对 dom 元素进行排序\n * @param {IElement} element  元素\n * @param {sorter}   function 排序函数\n */\n\nexport function sortDom(element, sorter) {\n  var el = element.get('el');\n  var childList = toArray(el.children).sort(sorter); // create empty fragment\n\n  var fragment = document.createDocumentFragment();\n  childList.forEach(function (child) {\n    fragment.appendChild(child);\n  });\n  el.appendChild(fragment);\n}\n/**\n * 将 dom 元素移动到父元素下的指定位置\n * @param {SVGElement} element     dom 元素\n * @param {number}     targetIndex 目标位置(从 0 开始)\n */\n\nexport function moveTo(element, targetIndex) {\n  var parentNode = element.parentNode;\n  var siblings = Array.from(parentNode.childNodes).filter( // 要求为元素节点，且不能为 defs 节点\n  function (node) {\n    return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs';\n  }); // 获取目标节点\n\n  var target = siblings[targetIndex];\n  var currentIndex = siblings.indexOf(element); // 如果目标节点存在\n\n  if (target) {\n    // 当前索引 > 目标索引，直接插入到目标节点之前即可\n    if (currentIndex > targetIndex) {\n      parentNode.insertBefore(element, target);\n    } else if (currentIndex < targetIndex) {\n      // 当前索引 < 目标索引\n      // 获取目标节点的下一个节点\n      var targetNext = siblings[targetIndex + 1]; // 如果目标节点的下一个节点存在，插入到该节点之前\n\n      if (targetNext) {\n        parentNode.insertBefore(element, targetNext);\n      } else {\n        // 如果该节点不存在，则追加到末尾\n        parentNode.appendChild(element);\n      }\n    }\n  } else {\n    parentNode.appendChild(element);\n  }\n}","map":{"version":3,"sources":["../../src/util/dom.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { toArray } from '@antv/util';\nimport { SHAPE_TO_TAGS } from '../constant';\n/**\n * 创建并返回图形的 svg 元素\n * @param type svg类型\n */\nexport function createSVGElement(type) {\n    return document.createElementNS('http://www.w3.org/2000/svg', type);\n}\n/**\n * 创建并返回图形的 dom 元素\n * @param  {IShape} shape 图形\n * @return {SVGElement}\n */\nexport function createDom(shape) {\n    var type = SHAPE_TO_TAGS[shape.type];\n    var parent = shape.getParent();\n    if (!type) {\n        throw new Error(\"the type \" + shape.type + \" is not supported by svg\");\n    }\n    var element = createSVGElement(type);\n    if (shape.get('id')) {\n        element.id = shape.get('id');\n    }\n    shape.set('el', element);\n    shape.set('attrs', {});\n    // 对于 defs 下的 dom 节点，parent 为空，通过 context 统一挂载到 defs 节点下\n    if (parent) {\n        var parentNode = parent.get('el');\n        if (parentNode) {\n            parentNode.appendChild(element);\n        }\n        else {\n            // parentNode maybe null for group\n            parentNode = parent.createDom();\n            parent.set('el', parentNode);\n            parentNode.appendChild(element);\n        }\n    }\n    return element;\n}\n/**\n * 对 dom 元素进行排序\n * @param {IElement} element  元素\n * @param {sorter}   function 排序函数\n */\nexport function sortDom(element, sorter) {\n    var el = element.get('el');\n    var childList = toArray(el.children).sort(sorter);\n    // create empty fragment\n    var fragment = document.createDocumentFragment();\n    childList.forEach(function (child) {\n        fragment.appendChild(child);\n    });\n    el.appendChild(fragment);\n}\n/**\n * 将 dom 元素移动到父元素下的指定位置\n * @param {SVGElement} element     dom 元素\n * @param {number}     targetIndex 目标位置(从 0 开始)\n */\nexport function moveTo(element, targetIndex) {\n    var parentNode = element.parentNode;\n    var siblings = Array.from(parentNode.childNodes).filter(\n    // 要求为元素节点，且不能为 defs 节点\n    function (node) { return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs'; });\n    // 获取目标节点\n    var target = siblings[targetIndex];\n    var currentIndex = siblings.indexOf(element);\n    // 如果目标节点存在\n    if (target) {\n        // 当前索引 > 目标索引，直接插入到目标节点之前即可\n        if (currentIndex > targetIndex) {\n            parentNode.insertBefore(element, target);\n        }\n        else if (currentIndex < targetIndex) {\n            // 当前索引 < 目标索引\n            // 获取目标节点的下一个节点\n            var targetNext = siblings[targetIndex + 1];\n            // 如果目标节点的下一个节点存在，插入到该节点之前\n            if (targetNext) {\n                parentNode.insertBefore(element, targetNext);\n            }\n            else {\n                // 如果该节点不存在，则追加到末尾\n                parentNode.appendChild(element);\n            }\n        }\n    }\n    else {\n        parentNode.appendChild(element);\n    }\n}\n//# sourceMappingURL=dom.js.map"]},"metadata":{},"sourceType":"module"}