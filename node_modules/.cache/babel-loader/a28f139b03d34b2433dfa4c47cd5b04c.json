{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport { GAP } from '../constant';\nimport Adjust from './adjust';\n\nfunction randomNumber(min, max) {\n  return (max - min) * Math.random() + min;\n}\n\nvar Jitter =\n/** @class */\nfunction (_super) {\n  __extends(Jitter, _super);\n\n  function Jitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Jitter.prototype.process = function (groupDataArray) {\n    var groupedDataArray = _.clone(groupDataArray); // 之前分组之后的数据，然后有合并回去（和分组前可以理解成是一样的）\n\n\n    var mergeData = _.flatten(groupedDataArray); // 返回值\n\n\n    this.adjustData(groupedDataArray, mergeData);\n    return groupedDataArray;\n  };\n  /**\n   * 当前数据分组（index）中，按照维度 dim 进行 jitter 调整\n   * @param dim\n   * @param values\n   * @param dataArray\n   */\n\n\n  Jitter.prototype.adjustDim = function (dim, values, dataArray) {\n    var _this = this; // 在每一个分组中，将数据再按照 dim 分组，用于散列\n\n\n    var groupDataArray = this.groupData(dataArray, dim);\n    return _.each(groupDataArray, function (data, dimValue) {\n      return _this.adjustGroup(data, dim, parseFloat(dimValue), values);\n    });\n  }; // 随机出来的字段值\n\n\n  Jitter.prototype.getAdjustOffset = function (range) {\n    var pre = range.pre,\n        next = range.next; // 随机的范围\n\n    var margin = (next - pre) * GAP;\n    return randomNumber(pre + margin, next - margin);\n  }; // adjust group data\n\n\n  Jitter.prototype.adjustGroup = function (group, dim, dimValue, values) {\n    var _this = this; // 调整范围\n\n\n    var range = this.getAdjustRange(dim, dimValue, values);\n\n    _.each(group, function (data) {\n      data[dim] = _this.getAdjustOffset(range); // 获取调整的位置\n    });\n\n    return group;\n  };\n\n  return Jitter;\n}(Adjust);\n\nexport default Jitter;","map":{"version":3,"sources":["../../src/adjusts/jitter.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,CAAZ,MAAmB,YAAnB;AACA,SAAS,GAAT,QAAoB,aAApB;AAEA,OAAO,MAAP,MAAmB,UAAnB;;AAEA,SAAS,YAAT,CAAsB,GAAtB,EAAmC,GAAnC,EAA8C;AAC5C,SAAO,CAAC,GAAG,GAAG,GAAP,IAAc,IAAI,CAAC,MAAL,EAAd,GAA8B,GAArC;AACD;;AAED,IAAA,MAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAoC,EAAA,SAAA,CAAA,MAAA,EAAA,MAAA,CAAA;;AAApC,WAAA,MAAA,GAAA;;AA6CC;;AA5CQ,EAAA,MAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,cAAf,EAAuC;AACrC,QAAM,gBAAgB,GAAG,CAAC,CAAC,KAAF,CAAQ,cAAR,CAAzB,CADqC,CAGrC;;;AACA,QAAM,SAAS,GAAG,CAAC,CAAC,OAAF,CAAU,gBAAV,CAAlB,CAJqC,CAMrC;;;AACA,SAAK,UAAL,CAAgB,gBAAhB,EAAkC,SAAlC;AAEA,WAAO,gBAAP;AACD,GAVM;AAYP;;;;;AAKG;;;AACO,EAAA,MAAA,CAAA,SAAA,CAAA,SAAA,GAAV,UAAoB,GAApB,EAAiC,MAAjC,EAAmD,SAAnD,EAAoE;AAApE,QAAA,KAAA,GAAA,IAAA,CAAoE,CAClE;;;AACA,QAAM,cAAc,GAAG,KAAK,SAAL,CAAe,SAAf,EAA0B,GAA1B,CAAvB;AACA,WAAO,CAAC,CAAC,IAAF,CAAO,cAAP,EAAuB,UAAC,IAAD,EAAe,QAAf,EAA+B;AAC3D,aAAO,KAAI,CAAC,WAAL,CAAiB,IAAjB,EAAuB,GAAvB,EAA4B,UAAU,CAAC,QAAD,CAAtC,EAAkD,MAAlD,CAAP;AACD,KAFM,CAAP;AAGD,GANS,CAnBZ,CA2BE;;;AACQ,EAAA,MAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,KAAxB,EAAoC;AAC1B,QAAA,GAAG,GAAW,KAAK,CAAhB,GAAH;AAAA,QAAK,IAAI,GAAK,KAAK,CAAV,IAAT,CAD0B,CAElC;;AACA,QAAM,MAAM,GAAG,CAAC,IAAI,GAAG,GAAR,IAAe,GAA9B;AACA,WAAO,YAAY,CAAC,GAAG,GAAG,MAAP,EAAe,IAAI,GAAG,MAAtB,CAAnB;AACD,GALO,CA5BV,CAmCE;;;AACQ,EAAA,MAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,KAApB,EAAmC,GAAnC,EAAgD,QAAhD,EAAkE,MAAlE,EAAkF;AAAlF,QAAA,KAAA,GAAA,IAAA,CAAkF,CAChF;;;AACA,QAAM,KAAK,GAAG,KAAK,cAAL,CAAoB,GAApB,EAAyB,QAAzB,EAAmC,MAAnC,CAAd;;AAEA,IAAA,CAAC,CAAC,IAAF,CAAO,KAAP,EAAc,UAAC,IAAD,EAAW;AACvB,MAAA,IAAI,CAAC,GAAD,CAAJ,GAAY,KAAI,CAAC,eAAL,CAAqB,KAArB,CAAZ,CADuB,CACkB;AAC1C,KAFD;;AAGA,WAAO,KAAP;AACD,GARO;;AASV,SAAA,MAAA;AAAC,CA7CD,CAAoC,MAApC,CAAA","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport { GAP } from '../constant';\nimport Adjust from './adjust';\nfunction randomNumber(min, max) {\n    return (max - min) * Math.random() + min;\n}\nvar Jitter = /** @class */ (function (_super) {\n    __extends(Jitter, _super);\n    function Jitter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Jitter.prototype.process = function (groupDataArray) {\n        var groupedDataArray = _.clone(groupDataArray);\n        // 之前分组之后的数据，然后有合并回去（和分组前可以理解成是一样的）\n        var mergeData = _.flatten(groupedDataArray);\n        // 返回值\n        this.adjustData(groupedDataArray, mergeData);\n        return groupedDataArray;\n    };\n    /**\n     * 当前数据分组（index）中，按照维度 dim 进行 jitter 调整\n     * @param dim\n     * @param values\n     * @param dataArray\n     */\n    Jitter.prototype.adjustDim = function (dim, values, dataArray) {\n        var _this = this;\n        // 在每一个分组中，将数据再按照 dim 分组，用于散列\n        var groupDataArray = this.groupData(dataArray, dim);\n        return _.each(groupDataArray, function (data, dimValue) {\n            return _this.adjustGroup(data, dim, parseFloat(dimValue), values);\n        });\n    };\n    // 随机出来的字段值\n    Jitter.prototype.getAdjustOffset = function (range) {\n        var pre = range.pre, next = range.next;\n        // 随机的范围\n        var margin = (next - pre) * GAP;\n        return randomNumber(pre + margin, next - margin);\n    };\n    // adjust group data\n    Jitter.prototype.adjustGroup = function (group, dim, dimValue, values) {\n        var _this = this;\n        // 调整范围\n        var range = this.getAdjustRange(dim, dimValue, values);\n        _.each(group, function (data) {\n            data[dim] = _this.getAdjustOffset(range); // 获取调整的位置\n        });\n        return group;\n    };\n    return Jitter;\n}(Adjust));\nexport default Jitter;\n//# sourceMappingURL=jitter.js.map"]},"metadata":{},"sourceType":"module"}