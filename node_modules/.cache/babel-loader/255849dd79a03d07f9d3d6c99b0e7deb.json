{"ast":null,"code":"function decasteljau(points, t) {\n  var left = [];\n  var right = [];\n\n  function recurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      var middlePoints = [];\n\n      for (var i = 0; i < points.length - 1; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n\n        if (i === points.length - 2) {\n          right.push(points[i + 1]);\n        }\n\n        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n      }\n\n      recurse(middlePoints, t);\n    }\n  }\n\n  if (points.length) {\n    recurse(points, t);\n  }\n\n  return {\n    left: left,\n    right: right.reverse()\n  };\n}\n\nfunction splitCurve(start, end, count) {\n  var points = [[start[1], start[2]]];\n  count = count || 2;\n  var segments = [];\n\n  if (end[0] === 'A') {\n    points.push(end[6]);\n    points.push(end[7]);\n  } else if (end[0] === 'C') {\n    points.push([end[1], end[2]]);\n    points.push([end[3], end[4]]);\n    points.push([end[5], end[6]]);\n  } else if (end[0] === 'S' || end[0] === 'Q') {\n    points.push([end[1], end[2]]);\n    points.push([end[3], end[4]]);\n  } else {\n    points.push([end[1], end[2]]);\n  }\n\n  var leftSegments = points;\n  var t = 1 / count;\n\n  for (var i = 0; i < count - 1; i++) {\n    var rt = t / (1 - t * i);\n    var split = decasteljau(leftSegments, rt);\n    segments.push(split.left);\n    leftSegments = split.right;\n  }\n\n  segments.push(leftSegments);\n  var result = segments.map(function (segment) {\n    var cmd = [];\n\n    if (segment.length === 4) {\n      cmd.push('C');\n      cmd = cmd.concat(segment[2]);\n    }\n\n    if (segment.length >= 3) {\n      if (segment.length === 3) {\n        cmd.push('Q');\n      }\n\n      cmd = cmd.concat(segment[1]);\n    }\n\n    if (segment.length === 2) {\n      cmd.push('L');\n    }\n\n    cmd = cmd.concat(segment[segment.length - 1]);\n    return cmd;\n  });\n  return result;\n}\n\nfunction splitSegment(start, end, count) {\n  if (count === 1) {\n    return [[].concat(start)];\n  }\n\n  var segments = [];\n\n  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {\n    segments = segments.concat(splitCurve(start, end, count));\n  } else {\n    var temp = [].concat(start);\n\n    if (temp[0] === 'M') {\n      temp[0] = 'L';\n    }\n\n    for (var i = 0; i <= count - 1; i++) {\n      segments.push(temp);\n    }\n  }\n\n  return segments;\n}\n\nexport default function fillPath(source, target) {\n  if (source.length === 1) {\n    return source;\n  }\n\n  var sourceLen = source.length - 1;\n  var targetLen = target.length - 1;\n  var ratio = sourceLen / targetLen;\n  var segmentsToFill = [];\n\n  if (source.length === 1 && source[0][0] === 'M') {\n    for (var i = 0; i < targetLen - sourceLen; i++) {\n      source.push(source[0]);\n    }\n\n    return source;\n  }\n\n  for (var i = 0; i < targetLen; i++) {\n    var index = Math.floor(ratio * i);\n    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;\n  }\n\n  var filled = segmentsToFill.reduce(function (filled, count, i) {\n    if (i === sourceLen) {\n      return filled.concat(source[sourceLen]);\n    }\n\n    return filled.concat(splitSegment(source[i], source[i + 1], count));\n  }, []);\n  filled.unshift(source[0]);\n\n  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {\n    filled.push('Z');\n  }\n\n  return filled;\n}","map":{"version":3,"sources":["../src/fill-path.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["function decasteljau(points, t) {\n    var left = [];\n    var right = [];\n    function recurse(points, t) {\n        if (points.length === 1) {\n            left.push(points[0]);\n            right.push(points[0]);\n        }\n        else {\n            var middlePoints = [];\n            for (var i = 0; i < points.length - 1; i++) {\n                if (i === 0) {\n                    left.push(points[0]);\n                }\n                if (i === points.length - 2) {\n                    right.push(points[i + 1]);\n                }\n                middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n            }\n            recurse(middlePoints, t);\n        }\n    }\n    if (points.length) {\n        recurse(points, t);\n    }\n    return { left: left, right: right.reverse() };\n}\nfunction splitCurve(start, end, count) {\n    var points = [[start[1], start[2]]];\n    count = count || 2;\n    var segments = [];\n    if (end[0] === 'A') {\n        points.push(end[6]);\n        points.push(end[7]);\n    }\n    else if (end[0] === 'C') {\n        points.push([end[1], end[2]]);\n        points.push([end[3], end[4]]);\n        points.push([end[5], end[6]]);\n    }\n    else if (end[0] === 'S' || end[0] === 'Q') {\n        points.push([end[1], end[2]]);\n        points.push([end[3], end[4]]);\n    }\n    else {\n        points.push([end[1], end[2]]);\n    }\n    var leftSegments = points;\n    var t = 1 / count;\n    for (var i = 0; i < count - 1; i++) {\n        var rt = t / (1 - t * i);\n        var split = decasteljau(leftSegments, rt);\n        segments.push(split.left);\n        leftSegments = split.right;\n    }\n    segments.push(leftSegments);\n    var result = segments.map(function (segment) {\n        var cmd = [];\n        if (segment.length === 4) {\n            cmd.push('C');\n            cmd = cmd.concat(segment[2]);\n        }\n        if (segment.length >= 3) {\n            if (segment.length === 3) {\n                cmd.push('Q');\n            }\n            cmd = cmd.concat(segment[1]);\n        }\n        if (segment.length === 2) {\n            cmd.push('L');\n        }\n        cmd = cmd.concat(segment[segment.length - 1]);\n        return cmd;\n    });\n    return result;\n}\nfunction splitSegment(start, end, count) {\n    if (count === 1) {\n        return [[].concat(start)];\n    }\n    var segments = [];\n    if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {\n        segments = segments.concat(splitCurve(start, end, count));\n    }\n    else {\n        var temp = [].concat(start);\n        if (temp[0] === 'M') {\n            temp[0] = 'L';\n        }\n        for (var i = 0; i <= count - 1; i++) {\n            segments.push(temp);\n        }\n    }\n    return segments;\n}\nexport default function fillPath(source, target) {\n    if (source.length === 1) {\n        return source;\n    }\n    var sourceLen = source.length - 1;\n    var targetLen = target.length - 1;\n    var ratio = sourceLen / targetLen;\n    var segmentsToFill = [];\n    if (source.length === 1 && source[0][0] === 'M') {\n        for (var i = 0; i < targetLen - sourceLen; i++) {\n            source.push(source[0]);\n        }\n        return source;\n    }\n    for (var i = 0; i < targetLen; i++) {\n        var index = Math.floor(ratio * i);\n        segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;\n    }\n    var filled = segmentsToFill.reduce(function (filled, count, i) {\n        if (i === sourceLen) {\n            return filled.concat(source[sourceLen]);\n        }\n        return filled.concat(splitSegment(source[i], source[i + 1], count));\n    }, []);\n    filled.unshift(source[0]);\n    if (target[targetLen] === 'Z' || target[targetLen] === 'z') {\n        filled.push('Z');\n    }\n    return filled;\n}\n//# sourceMappingURL=fill-path.js.map"]},"metadata":{},"sourceType":"module"}