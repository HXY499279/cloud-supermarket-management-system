{"ast":null,"code":"import { isArray, isString } from '@antv/util';\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\n\nexport function isBetween(value, start, end) {\n  var min = Math.min(start, end);\n  var max = Math.max(start, end);\n  return value >= min && value <= max;\n}\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\n\nexport function padEnd(source, targetLength, padValue) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    var sourceLength = source.length;\n\n    if (sourceLength < targetLength) {\n      var diff = targetLength - sourceLength;\n\n      for (var i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n\n  return source;\n}\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\n\nexport function omit(obj, keys) {\n  keys.forEach(function (key) {\n    delete obj[key];\n  });\n  return obj;\n}\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\n\nexport function uniq(sourceArray, targetArray, map) {\n  if (targetArray === void 0) {\n    targetArray = [];\n  }\n\n  if (map === void 0) {\n    map = {};\n  }\n\n  for (var _i = 0, sourceArray_1 = sourceArray; _i < sourceArray_1.length; _i++) {\n    var source = sourceArray_1[_i];\n\n    if (!map[source]) {\n      targetArray.push(source);\n      map[source] = true;\n    }\n  }\n\n  return targetArray;\n}","map":{"version":3,"sources":["../../src/util/helper.ts"],"names":[],"mappings":"AAAA,SAAS,OAAT,EAAkB,QAAlB,QAAkC,YAAlC;AAEA;;;;;;;AAOG;;AACH,OAAM,SAAU,SAAV,CAAoB,KAApB,EAAmC,KAAnC,EAAkD,GAAlD,EAA6D;AACjE,MAAM,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,GAAhB,CAAZ;AACA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,EAAgB,GAAhB,CAAZ;AAEA,SAAO,KAAK,IAAI,GAAT,IAAgB,KAAK,IAAI,GAAhC;AACD;AAED;;;;;;;;;AASG;;AACH,OAAM,SAAU,MAAV,CAAiB,MAAjB,EAAyC,YAAzC,EAA+D,QAA/D,EAA4E;AAChF,MAAI,QAAQ,CAAC,MAAD,CAAZ,EAAsB;AACpB,WAAO,MAAM,CAAC,MAAP,CAAc,YAAd,EAA4B,QAA5B,CAAP;AACD,GAFD,MAEO,IAAI,OAAO,CAAC,MAAD,CAAX,EAAqB;AAC1B,QAAM,YAAY,GAAG,MAAM,CAAC,MAA5B;;AACA,QAAI,YAAY,GAAG,YAAnB,EAAiC;AAC/B,UAAM,IAAI,GAAG,YAAY,GAAG,YAA5B;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAApB,EAA0B,CAAC,EAA3B,EAA+B;AAC7B,QAAA,MAAM,CAAC,IAAP,CAAY,QAAZ;AACD;AACF;AACF;;AAED,SAAO,MAAP;AACD;AAED;;;;;AAKG;;AACH,OAAM,SAAU,IAAV,CAAwB,GAAxB,EAAgC,IAAhC,EAA8C;AAClD,EAAA,IAAI,CAAC,OAAL,CAAa,UAAC,GAAD,EAAY;AACvB,WAAO,GAAG,CAAC,GAAD,CAAV;AACD,GAFD;AAIA,SAAO,GAAP;AACD;AAED;;;;;AAKG;;AACH,OAAM,SAAU,IAAV,CAAe,WAAf,EAAmC,WAAnC,EAA4D,GAA5D,EAA4E;AAAzC,MAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,WAAA,GAAA,EAAA;AAAuB;;AAAE,MAAA,GAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,GAAA,GAAA,EAAA;AAAgB;;AAChF,OAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,aAAA,GAAA,WAArB,EAAqB,EAAA,GAAA,aAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAkC;AAA7B,QAAM,MAAM,GAAA,aAAA,CAAA,EAAA,CAAZ;;AACH,QAAI,CAAC,GAAG,CAAC,MAAD,CAAR,EAAkB;AAChB,MAAA,WAAW,CAAC,IAAZ,CAAiB,MAAjB;AACA,MAAA,GAAG,CAAC,MAAD,CAAH,GAAc,IAAd;AACD;AACF;;AACD,SAAO,WAAP;AACD","sourcesContent":["import { isArray, isString } from '@antv/util';\n\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value: number, start: number, end: number): boolean {\n  const min = Math.min(start, end);\n  const max = Math.max(start, end);\n\n  return value >= min && value <= max;\n}\n\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source: string | any[], targetLength: number, padValue: any) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    const sourceLength = source.length;\n    if (sourceLength < targetLength) {\n      const diff = targetLength - sourceLength;\n      for (let i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n\n  return source;\n}\n\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit<T = any>(obj: T, keys: string[]): T {\n  keys.forEach((key: string) => {\n    delete obj[key];\n  });\n\n  return obj;\n}\n\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray: any[], targetArray: any[] = [], map: object = {}) {\n  for (const source of sourceArray) {\n    if (!map[source]) {\n      targetArray.push(source);\n      map[source] = true;\n    }\n  }\n  return targetArray;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}