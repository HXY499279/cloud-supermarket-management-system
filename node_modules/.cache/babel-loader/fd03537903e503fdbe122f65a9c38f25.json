{"ast":null,"code":"/**\n * @fileoverview 文本\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\nimport { isNil, isString, each } from '../util/util';\nimport { getTextHeight, assembleFont } from '@antv/g-base';\n\nvar Text =\n/** @class */\nfunction (_super) {\n  __extends(Text, _super);\n\n  function Text() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // 默认文本属性\n\n\n  Text.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n\n    return __assign(__assign({}, attrs), {\n      x: 0,\n      y: 0,\n      text: null,\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      fontStyle: 'normal',\n      fontWeight: 'normal',\n      fontVariant: 'normal',\n      textAlign: 'start',\n      textBaseline: 'bottom'\n    });\n  }; // 仅仅使用包围盒检测来进行拾取\n\n\n  Text.prototype.isOnlyHitBox = function () {\n    return true;\n  }; // 初始化时组合 font，同时判断 text 是否换行\n\n\n  Text.prototype.initAttrs = function (attrs) {\n    this._assembleFont();\n\n    if (attrs.text) {\n      this._setText(attrs.text);\n    }\n  }; // 组装字体\n\n\n  Text.prototype._assembleFont = function () {\n    var attrs = this.attrs;\n    attrs.font = assembleFont(attrs);\n  }; // 如果文本换行，则缓存数组\n\n\n  Text.prototype._setText = function (text) {\n    var textArr = null;\n\n    if (isString(text) && text.indexOf('\\n') !== -1) {\n      textArr = text.split('\\n');\n    }\n\n    this.set('textArr', textArr);\n  }; // 更新属性时，检测是否更改了 font、text\n\n\n  Text.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n\n    if (name.startsWith('font')) {\n      this._assembleFont();\n    }\n\n    if (name === 'text') {\n      this._setText(value);\n    }\n  }; // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\n  // createPath(context) {\n  // }\n  // 如果文本多行，需要获取文本间距\n\n\n  Text.prototype._getSpaceingY = function () {\n    var attrs = this.attrs;\n    var lineHeight = attrs.lineHeight;\n    var fontSize = attrs.fontSize * 1;\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n  }; // 绘制文本，考虑多行的场景\n\n\n  Text.prototype._drawTextArr = function (context, textArr, isFill) {\n    var attrs = this.attrs;\n    var textBaseline = attrs.textBaseline;\n    var x = attrs.x;\n    var y = attrs.y;\n    var fontSize = attrs.fontSize * 1;\n\n    var spaceingY = this._getSpaceingY();\n\n    var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\n    var subY;\n    each(textArr, function (subText, index) {\n      subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n\n      if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;\n      if (textBaseline === 'top') subY += height - fontSize;\n\n      if (subText) {\n        if (isFill) {\n          context.fillText(subText, x, subY);\n        } else {\n          context.strokeText(subText, x, subY);\n        }\n      }\n    });\n  }; // 绘制文本，同时考虑填充和绘制边框\n\n\n  Text.prototype._drawText = function (context, isFill) {\n    var attrs = this.attr();\n    var x = attrs.x;\n    var y = attrs.y;\n    var textArr = this.get('textArr');\n\n    if (textArr) {\n      this._drawTextArr(context, textArr, isFill);\n    } else {\n      var text = attrs.text;\n\n      if (text) {\n        if (isFill) {\n          context.fillText(text, x, y);\n        } else {\n          context.strokeText(text, x, y);\n        }\n      }\n    }\n  }; // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\n\n\n  Text.prototype.strokeAndFill = function (context) {\n    var _a = this.attrs,\n        lineWidth = _a.lineWidth,\n        opacity = _a.opacity,\n        strokeOpacity = _a.strokeOpacity,\n        fillOpacity = _a.fillOpacity;\n\n    if (this.isStroke()) {\n      if (lineWidth > 0) {\n        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = opacity;\n        }\n\n        this.stroke(context);\n      }\n    }\n\n    if (this.isFill()) {\n      if (!isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        this.fill(context);\n        context.globalAlpha = opacity;\n      } else {\n        this.fill(context);\n      }\n    }\n\n    this.afterDrawPath(context);\n  }; // 复写填充逻辑\n\n\n  Text.prototype.fill = function (context) {\n    this._drawText(context, true);\n  }; // 复写绘制边框的逻辑\n\n\n  Text.prototype.stroke = function (context) {\n    this._drawText(context, false);\n  };\n\n  return Text;\n}(ShapeBase);\n\nexport default Text;","map":{"version":3,"sources":["../../src/shape/text.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileoverview 文本\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\nimport { isNil, isString, each } from '../util/util';\nimport { getTextHeight, assembleFont } from '@antv/g-base';\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // 默认文本属性\n    Text.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: 'sans-serif', fontStyle: 'normal', fontWeight: 'normal', fontVariant: 'normal', textAlign: 'start', textBaseline: 'bottom' });\n    };\n    // 仅仅使用包围盒检测来进行拾取\n    Text.prototype.isOnlyHitBox = function () {\n        return true;\n    };\n    // 初始化时组合 font，同时判断 text 是否换行\n    Text.prototype.initAttrs = function (attrs) {\n        this._assembleFont();\n        if (attrs.text) {\n            this._setText(attrs.text);\n        }\n    };\n    // 组装字体\n    Text.prototype._assembleFont = function () {\n        var attrs = this.attrs;\n        attrs.font = assembleFont(attrs);\n    };\n    // 如果文本换行，则缓存数组\n    Text.prototype._setText = function (text) {\n        var textArr = null;\n        if (isString(text) && text.indexOf('\\n') !== -1) {\n            textArr = text.split('\\n');\n        }\n        this.set('textArr', textArr);\n    };\n    // 更新属性时，检测是否更改了 font、text\n    Text.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (name.startsWith('font')) {\n            this._assembleFont();\n        }\n        if (name === 'text') {\n            this._setText(value);\n        }\n    };\n    // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\n    // createPath(context) {\n    // }\n    // 如果文本多行，需要获取文本间距\n    Text.prototype._getSpaceingY = function () {\n        var attrs = this.attrs;\n        var lineHeight = attrs.lineHeight;\n        var fontSize = attrs.fontSize * 1;\n        return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n    };\n    // 绘制文本，考虑多行的场景\n    Text.prototype._drawTextArr = function (context, textArr, isFill) {\n        var attrs = this.attrs;\n        var textBaseline = attrs.textBaseline;\n        var x = attrs.x;\n        var y = attrs.y;\n        var fontSize = attrs.fontSize * 1;\n        var spaceingY = this._getSpaceingY();\n        var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\n        var subY;\n        each(textArr, function (subText, index) {\n            subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n            if (textBaseline === 'middle')\n                subY += height - fontSize - (height - fontSize) / 2;\n            if (textBaseline === 'top')\n                subY += height - fontSize;\n            if (subText) {\n                if (isFill) {\n                    context.fillText(subText, x, subY);\n                }\n                else {\n                    context.strokeText(subText, x, subY);\n                }\n            }\n        });\n    };\n    // 绘制文本，同时考虑填充和绘制边框\n    Text.prototype._drawText = function (context, isFill) {\n        var attrs = this.attr();\n        var x = attrs.x;\n        var y = attrs.y;\n        var textArr = this.get('textArr');\n        if (textArr) {\n            this._drawTextArr(context, textArr, isFill);\n        }\n        else {\n            var text = attrs.text;\n            if (text) {\n                if (isFill) {\n                    context.fillText(text, x, y);\n                }\n                else {\n                    context.strokeText(text, x, y);\n                }\n            }\n        }\n    };\n    // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\n    Text.prototype.strokeAndFill = function (context) {\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\n        if (this.isStroke()) {\n            if (lineWidth > 0) {\n                if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = opacity;\n                }\n                this.stroke(context);\n            }\n        }\n        if (this.isFill()) {\n            if (!isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                this.fill(context);\n                context.globalAlpha = opacity;\n            }\n            else {\n                this.fill(context);\n            }\n        }\n        this.afterDrawPath(context);\n    };\n    // 复写填充逻辑\n    Text.prototype.fill = function (context) {\n        this._drawText(context, true);\n    };\n    // 复写绘制边框的逻辑\n    Text.prototype.stroke = function (context) {\n        this._drawText(context, false);\n    };\n    return Text;\n}(ShapeBase));\nexport default Text;\n//# sourceMappingURL=text.js.map"]},"metadata":{},"sourceType":"module"}