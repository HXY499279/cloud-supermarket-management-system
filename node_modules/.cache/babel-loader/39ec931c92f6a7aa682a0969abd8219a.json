{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\n\nvar LineCrosshair =\n/** @class */\nfunction (_super) {\n  __extends(LineCrosshair, _super);\n\n  function LineCrosshair() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  LineCrosshair.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: 100,\n      startAngle: -Math.PI / 2,\n      endAngle: Math.PI * 3 / 2\n    });\n  };\n\n  LineCrosshair.prototype.getRotateAngle = function () {\n    var _a = this.getLocation(),\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle;\n\n    var position = this.get('text').position;\n    var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n    return tangentAngle;\n  };\n\n  LineCrosshair.prototype.getTextPoint = function () {\n    var text = this.get('text');\n    var position = text.position,\n        offset = text.offset;\n\n    var _a = this.getLocation(),\n        center = _a.center,\n        radius = _a.radius,\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle;\n\n    var angle = position === 'start' ? startAngle : endAngle;\n    var tangentAngle = this.getRotateAngle() - Math.PI;\n    var point = getCirclePoint(center, radius, angle); // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n    // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n    // const offsetVector = vec2.scale([], tangent, offset);\n\n    var offsetX = Math.cos(tangentAngle) * offset;\n    var offsetY = Math.sin(tangentAngle) * offset;\n    return {\n      x: point.x + offsetX,\n      y: point.y + offsetY\n    };\n  };\n\n  LineCrosshair.prototype.getLinePath = function () {\n    var _a = this.getLocation(),\n        center = _a.center,\n        radius = _a.radius,\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle;\n\n    var path = null;\n\n    if (endAngle - startAngle === Math.PI * 2) {\n      // 整圆\n      var x = center.x,\n          y = center.y;\n      path = [['M', x, y - radius], ['A', radius, radius, 0, 1, 1, x, y + radius], ['A', radius, radius, 0, 1, 1, x, y - radius], ['Z']];\n    } else {\n      var startPoint = getCirclePoint(center, radius, startAngle);\n      var endPoint = getCirclePoint(center, radius, endAngle);\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n      path = [['M', startPoint.x, startPoint.y], ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y]];\n    }\n\n    return path;\n  };\n\n  return LineCrosshair;\n}(CrosshairBase);\n\nexport default LineCrosshair;","map":{"version":3,"sources":["../../src/crosshair/circle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */ (function (_super) {\n    __extends(LineCrosshair, _super);\n    function LineCrosshair() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LineCrosshair.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'circle', locationType: 'circle', center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: (Math.PI * 3) / 2 });\n    };\n    LineCrosshair.prototype.getRotateAngle = function () {\n        var _a = this.getLocation(), startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var position = this.get('text').position;\n        var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n        return tangentAngle;\n    };\n    LineCrosshair.prototype.getTextPoint = function () {\n        var text = this.get('text');\n        var position = text.position, offset = text.offset;\n        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var angle = position === 'start' ? startAngle : endAngle;\n        var tangentAngle = this.getRotateAngle() - Math.PI;\n        var point = getCirclePoint(center, radius, angle);\n        // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n        // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n        // const offsetVector = vec2.scale([], tangent, offset);\n        var offsetX = Math.cos(tangentAngle) * offset;\n        var offsetY = Math.sin(tangentAngle) * offset;\n        return {\n            x: point.x + offsetX,\n            y: point.y + offsetY,\n        };\n    };\n    LineCrosshair.prototype.getLinePath = function () {\n        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var path = null;\n        if (endAngle - startAngle === Math.PI * 2) {\n            // 整圆\n            var x = center.x, y = center.y;\n            path = [\n                ['M', x, y - radius],\n                ['A', radius, radius, 0, 1, 1, x, y + radius],\n                ['A', radius, radius, 0, 1, 1, x, y - radius],\n                ['Z'],\n            ];\n        }\n        else {\n            var startPoint = getCirclePoint(center, radius, startAngle);\n            var endPoint = getCirclePoint(center, radius, endAngle);\n            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n            var sweep = startAngle > endAngle ? 0 : 1;\n            path = [\n                ['M', startPoint.x, startPoint.y],\n                ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y],\n            ];\n        }\n        return path;\n    };\n    return LineCrosshair;\n}(CrosshairBase));\nexport default LineCrosshair;\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"module"}