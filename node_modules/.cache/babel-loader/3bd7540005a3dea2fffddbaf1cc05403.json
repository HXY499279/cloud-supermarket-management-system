{"ast":null,"code":"/**\n * view 中缓存 scale 的类\n */\nimport { deepMix, each, get, isNumber, last } from '@antv/util';\nimport { createScaleByField, syncScale, getDefaultCategoryScaleRange } from '../../util/scale';\n/** @ignore */\n\nvar ScalePool =\n/** @class */\nfunction () {\n  function ScalePool() {\n    /** 所有的 scales */\n    this.scales = new Map();\n    /** 需要同步的 scale 分组， key: scaleKeyArray */\n\n    this.syncScales = new Map();\n  }\n  /**\n   * 创建 scale\n   * @param field\n   * @param data\n   * @param scaleDef\n   * @param key\n   */\n\n\n  ScalePool.prototype.createScale = function (field, data, scaleDef, key) {\n    var finalScaleDef = scaleDef;\n    var cacheScaleMeta = this.getScaleMeta(key);\n\n    if (data.length === 0 && cacheScaleMeta) {\n      // 在更新过程中数据变为空，同时 key 对应的 scale 已存在则保持 scale 同类型\n      var cacheScale = cacheScaleMeta.scale;\n      var cacheScaleDef = {\n        type: cacheScale.type\n      };\n\n      if (cacheScale.isCategory) {\n        // 如果是分类类型，保持 values\n        cacheScaleDef.values = cacheScale.values;\n      }\n\n      finalScaleDef = deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);\n    }\n\n    var scale = createScaleByField(field, data, finalScaleDef); // 缓存起来\n\n    this.cacheScale(scale, scaleDef, key);\n    return scale;\n  };\n  /**\n   * 同步 scale\n   */\n\n\n  ScalePool.prototype.sync = function (coordinate, theme) {\n    var _this = this; // 对于 syncScales 中每一个 syncKey 下面的 scale 数组进行同步处理\n\n\n    this.syncScales.forEach(function (scaleKeys, syncKey) {\n      // min, max, values, ranges\n      var min = Number.MAX_SAFE_INTEGER;\n      var max = Number.MIN_SAFE_INTEGER;\n      var values = []; // 1. 遍历求得最大最小值，values 等\n\n      each(scaleKeys, function (key) {\n        var scale = _this.getScale(key);\n\n        max = isNumber(scale.max) ? Math.max(max, scale.max) : max;\n        min = isNumber(scale.min) ? Math.min(min, scale.min) : min; // 去重\n\n        each(scale.values, function (v) {\n          if (!values.includes(v)) {\n            values.push(v);\n          }\n        });\n      }); // 2. 同步\n\n      each(scaleKeys, function (key) {\n        var scale = _this.getScale(key);\n\n        if (scale.isContinuous) {\n          scale.change({\n            min: min,\n            max: max,\n            values: values\n          });\n        } else if (scale.isCategory) {\n          var range = scale.range;\n\n          var cacheScaleMeta = _this.getScaleMeta(key); // 存在 value 值，且用户没有配置 range 配置 to fix https://github.com/antvis/G2/issues/2996\n\n\n          if (values && !get(cacheScaleMeta, ['scaleDef', 'range'])) {\n            // 更新 range\n            range = getDefaultCategoryScaleRange(deepMix({}, scale, {\n              values: values\n            }), coordinate, theme);\n          }\n\n          scale.change({\n            values: values,\n            range: range\n          });\n        }\n      });\n    });\n  };\n  /**\n   * 缓存一个 scale\n   * @param scale\n   * @param scaleDef\n   * @param key\n   */\n\n\n  ScalePool.prototype.cacheScale = function (scale, scaleDef, key) {\n    // 1. 缓存到 scales\n    var sm = this.getScaleMeta(key); // 存在则更新，同时检测类型是否一致\n\n    if (sm && sm.scale.type === scale.type) {\n      syncScale(sm.scale, scale);\n      sm.scaleDef = scaleDef; // 更新 scaleDef\n    } else {\n      sm = {\n        key: key,\n        scale: scale,\n        scaleDef: scaleDef\n      };\n      this.scales.set(key, sm);\n    } // 2. 缓存到 syncScales，构造 Record<sync, string[]> 数据结构\n\n\n    var syncKey = this.getSyncKey(sm);\n    sm.syncKey = syncKey; // 设置 sync 同步的 key\n    // 因为存在更新 scale 机制，所以在缓存之前，先从原 syncScales 中去除 sync 的缓存引用\n\n    this.removeFromSyncScales(key); // 存在 sync 标记才进行 sync\n\n    if (syncKey) {\n      // 不存在这个 syncKey，则创建一个空数组\n      var scaleKeys = this.syncScales.get(syncKey);\n\n      if (!scaleKeys) {\n        scaleKeys = [];\n        this.syncScales.set(syncKey, scaleKeys);\n      }\n\n      scaleKeys.push(key);\n    }\n  };\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n\n\n  ScalePool.prototype.getScale = function (key) {\n    var scaleMeta = this.getScaleMeta(key);\n\n    if (!scaleMeta) {\n      var field = last(key.split('-'));\n      var scaleKeys = this.syncScales.get(field);\n\n      if (scaleKeys && scaleKeys.length) {\n        scaleMeta = this.getScaleMeta(scaleKeys[0]);\n      }\n    }\n\n    return scaleMeta && scaleMeta.scale;\n  };\n  /**\n   * 在 view 销毁的时候，删除 scale 实例，防止内存泄露\n   * @param key\n   */\n\n\n  ScalePool.prototype.deleteScale = function (key) {\n    var scaleMeta = this.getScaleMeta(key);\n\n    if (scaleMeta) {\n      var syncKey = scaleMeta.syncKey;\n      var scaleKeys = this.syncScales.get(syncKey); // 移除同步的关系\n\n      if (scaleKeys && scaleKeys.length) {\n        var idx = scaleKeys.indexOf(key);\n\n        if (idx !== -1) {\n          scaleKeys.splice(idx, 1);\n        }\n      }\n    } // 删除 scale 实例\n\n\n    this.scales.delete(key);\n  };\n  /**\n   * 清空\n   */\n\n\n  ScalePool.prototype.clear = function () {\n    this.scales.clear();\n    this.syncScales.clear();\n  };\n  /**\n   * 删除 sync scale 引用\n   * @param key\n   */\n\n\n  ScalePool.prototype.removeFromSyncScales = function (key) {\n    var _this = this;\n\n    this.syncScales.forEach(function (scaleKeys, syncKey) {\n      var idx = scaleKeys.indexOf(key);\n\n      if (idx !== -1) {\n        scaleKeys.splice(idx, 1); // 删除空数组值\n\n        if (scaleKeys.length === 0) {\n          _this.syncScales.delete(syncKey);\n        }\n\n        return false; // 跳出循环\n      }\n    });\n  };\n  /**\n   * get sync key\n   * @param sm\n   */\n\n\n  ScalePool.prototype.getSyncKey = function (sm) {\n    var scale = sm.scale,\n        scaleDef = sm.scaleDef;\n    var field = scale.field;\n    var sync = get(scaleDef, ['sync']); // 如果 sync = true，则直接使用字段名作为 syncKey\n\n    return sync === true ? field : sync === false ? undefined : sync;\n  };\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n\n\n  ScalePool.prototype.getScaleMeta = function (key) {\n    return this.scales.get(key);\n  };\n\n  return ScalePool;\n}();\n\nexport { ScalePool };","map":{"version":3,"sources":["../../../src/chart/util/scale-pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * view 中缓存 scale 的类\n */\nimport { deepMix, each, get, isNumber, last } from '@antv/util';\nimport { Scale, Coordinate } from '../../dependents';\nimport { Data, LooseObject, ScaleOption, ViewCfg } from '../../interface';\nimport { createScaleByField, syncScale, getDefaultCategoryScaleRange } from '../../util/scale';\n\n/** @ignore */\ninterface ScaleMeta {\n  readonly key: string;\n  readonly scale: Scale;\n  scaleDef: ScaleOption;\n  syncKey?: string;\n}\n\n/** @ignore */\nexport class ScalePool {\n  /** 所有的 scales */\n  private scales = new Map<string, ScaleMeta>();\n  /** 需要同步的 scale 分组， key: scaleKeyArray */\n  private syncScales = new Map<string, string[]>();\n\n  /**\n   * 创建 scale\n   * @param field\n   * @param data\n   * @param scaleDef\n   * @param key\n   */\n  public createScale(field: string, data: Data, scaleDef: ScaleOption, key: string): Scale {\n    let finalScaleDef = scaleDef;\n\n    const cacheScaleMeta = this.getScaleMeta(key);\n    if (data.length === 0 && cacheScaleMeta) {\n      // 在更新过程中数据变为空，同时 key 对应的 scale 已存在则保持 scale 同类型\n      const cacheScale = cacheScaleMeta.scale;\n      const cacheScaleDef: LooseObject = {\n        type: cacheScale.type,\n      };\n      if (cacheScale.isCategory) {\n        // 如果是分类类型，保持 values\n        cacheScaleDef.values = cacheScale.values;\n      }\n      finalScaleDef = deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);\n    }\n\n    const scale = createScaleByField(field, data, finalScaleDef);\n\n    // 缓存起来\n    this.cacheScale(scale, scaleDef, key);\n\n    return scale;\n  }\n\n  /**\n   * 同步 scale\n   */\n  public sync(coordinate: Coordinate, theme: ViewCfg['theme']) {\n    // 对于 syncScales 中每一个 syncKey 下面的 scale 数组进行同步处理\n    this.syncScales.forEach((scaleKeys: string[], syncKey: string) => {\n      // min, max, values, ranges\n      let min = Number.MAX_SAFE_INTEGER;\n      let max = Number.MIN_SAFE_INTEGER;\n      const values = [];\n\n      // 1. 遍历求得最大最小值，values 等\n      each(scaleKeys, (key: string) => {\n        const scale = this.getScale(key);\n\n        max = isNumber(scale.max) ? Math.max(max, scale.max) : max;\n        min = isNumber(scale.min) ? Math.min(min, scale.min) : min;\n\n        // 去重\n        each(scale.values, (v: any) => {\n          if (!values.includes(v)) {\n            values.push(v);\n          }\n        });\n      });\n\n      // 2. 同步\n      each(scaleKeys, (key: string) => {\n        const scale = this.getScale(key);\n\n        if (scale.isContinuous) {\n          scale.change({\n            min,\n            max,\n            values,\n          });\n        } else if (scale.isCategory) {\n          let range = scale.range;\n          const cacheScaleMeta = this.getScaleMeta(key);\n\n          // 存在 value 值，且用户没有配置 range 配置 to fix https://github.com/antvis/G2/issues/2996\n          if (values && !get(cacheScaleMeta, ['scaleDef', 'range'])) {\n            // 更新 range\n            range = getDefaultCategoryScaleRange(deepMix({}, scale, {\n              values\n            }), coordinate, theme);\n          } \n          scale.change({\n            values,\n            range,\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * 缓存一个 scale\n   * @param scale\n   * @param scaleDef\n   * @param key\n   */\n  private cacheScale(scale: Scale, scaleDef: ScaleOption, key: string) {\n    // 1. 缓存到 scales\n\n    let sm = this.getScaleMeta(key);\n    // 存在则更新，同时检测类型是否一致\n    if (sm && sm.scale.type === scale.type) {\n      syncScale(sm.scale, scale);\n      sm.scaleDef = scaleDef;\n      // 更新 scaleDef\n    } else {\n      sm = {\n        key,\n        scale,\n        scaleDef,\n      };\n\n      this.scales.set(key, sm);\n    }\n\n    // 2. 缓存到 syncScales，构造 Record<sync, string[]> 数据结构\n    const syncKey = this.getSyncKey(sm);\n    sm.syncKey = syncKey; // 设置 sync 同步的 key\n\n    // 因为存在更新 scale 机制，所以在缓存之前，先从原 syncScales 中去除 sync 的缓存引用\n    this.removeFromSyncScales(key);\n\n    // 存在 sync 标记才进行 sync\n    if (syncKey) {\n      // 不存在这个 syncKey，则创建一个空数组\n      let scaleKeys = this.syncScales.get(syncKey);\n      if (!scaleKeys) {\n        scaleKeys = [];\n        this.syncScales.set(syncKey, scaleKeys);\n      }\n      scaleKeys.push(key);\n    }\n  }\n\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n  public getScale(key: string): Scale {\n    let scaleMeta = this.getScaleMeta(key);\n    if (!scaleMeta) {\n      const field = last(key.split('-'));\n      const scaleKeys = this.syncScales.get(field);\n      if (scaleKeys && scaleKeys.length) {\n        scaleMeta = this.getScaleMeta(scaleKeys[0]);\n      }\n    }\n    return scaleMeta && scaleMeta.scale;\n  }\n\n  /**\n   * 在 view 销毁的时候，删除 scale 实例，防止内存泄露\n   * @param key\n   */\n  public deleteScale(key: string) {\n    const scaleMeta = this.getScaleMeta(key);\n    if (scaleMeta) {\n      const { syncKey } = scaleMeta;\n\n      const scaleKeys = this.syncScales.get(syncKey);\n\n      // 移除同步的关系\n      if (scaleKeys && scaleKeys.length) {\n        const idx = scaleKeys.indexOf(key);\n\n        if (idx !== -1) {\n          scaleKeys.splice(idx, 1);\n        }\n      }\n    }\n\n    // 删除 scale 实例\n    this.scales.delete(key);\n  }\n\n  /**\n   * 清空\n   */\n  public clear() {\n    this.scales.clear();\n    this.syncScales.clear();\n  }\n\n  /**\n   * 删除 sync scale 引用\n   * @param key\n   */\n  private removeFromSyncScales(key: string) {\n    this.syncScales.forEach((scaleKeys: string[], syncKey: string) => {\n      const idx = scaleKeys.indexOf(key);\n\n      if (idx !== -1) {\n        scaleKeys.splice(idx, 1);\n\n        // 删除空数组值\n        if (scaleKeys.length === 0) {\n          this.syncScales.delete(syncKey);\n        }\n\n        return false; // 跳出循环\n      }\n    });\n  }\n\n  /**\n   * get sync key\n   * @param sm\n   */\n  private getSyncKey(sm: ScaleMeta): string {\n    const { scale, scaleDef } = sm;\n    const { field } = scale;\n    const sync = get(scaleDef, ['sync']);\n\n    // 如果 sync = true，则直接使用字段名作为 syncKey\n    return sync === true ? field : sync === false ? undefined : sync;\n  }\n\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n  private getScaleMeta(key: string): ScaleMeta {\n    return this.scales.get(key);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}