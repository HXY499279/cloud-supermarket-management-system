{"ast":null,"code":"import { each, isEmpty, isNumber, isNumberEqual } from '@antv/util'; // 获取图形的包围盒\n\nfunction getPointsBox(points) {\n  if (isEmpty(points)) {\n    return null;\n  }\n\n  var minX = points[0].x;\n  var maxX = points[0].x;\n  var minY = points[0].y;\n  var maxY = points[0].y;\n  each(points, function (point) {\n    minX = minX > point.x ? point.x : minX;\n    maxX = maxX < point.x ? point.x : maxX;\n    minY = minY > point.y ? point.y : minY;\n    maxY = maxY < point.y ? point.y : maxY;\n  });\n  return {\n    minX: minX,\n    maxX: maxX,\n    minY: minY,\n    maxY: maxY,\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2\n  };\n}\n/**\n * @ignore\n * 根据弧度计算极坐标系下的坐标点\n * @param centerX\n * @param centerY\n * @param radius\n * @param angleInRadian\n * @returns\n */\n\n\nexport function polarToCartesian(centerX, centerY, radius, angleInRadian) {\n  return {\n    x: centerX + radius * Math.cos(angleInRadian),\n    y: centerY + radius * Math.sin(angleInRadian)\n  };\n}\n/**\n * @ignore\n * 根据起始角度计算绘制扇形的 path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\n\nexport function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {\n  if (innerRadius === void 0) {\n    innerRadius = 0;\n  }\n\n  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n\n  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n    // 整个圆是分割成两个圆\n    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n    var circlePathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, end.x, end.y], ['M', innerStart.x, innerStart.y]];\n\n    if (innerRadius) {\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n    }\n\n    circlePathCommands.push(['M', start.x, start.y]);\n    circlePathCommands.push(['Z']);\n    return circlePathCommands;\n  }\n\n  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  var sectorPathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y], ['L', innerEnd.x, innerEnd.y]];\n\n  if (innerRadius) {\n    sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n  }\n\n  sectorPathCommands.push(['L', start.x, start.y]);\n  sectorPathCommands.push(['Z']);\n  return sectorPathCommands;\n}\n/**\n * @ignore\n * Gets arc path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\n\nexport function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {\n  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n\n  if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    return [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, start.x, start.y], ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 0, start.x, start.y], ['Z']];\n  }\n\n  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  return [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y]];\n}\n/**\n * @ignore\n * 从数据模型中的 points 换算角度\n * @param shapeModel\n * @param coordinate\n * @returns\n */\n\nexport function getAngle(shapeModel, coordinate) {\n  var points = shapeModel.points;\n  var box = getPointsBox(points);\n  var endAngle;\n  var startAngle;\n  var coordStartAngle = coordinate.startAngle,\n      coordEndAngle = coordinate.endAngle;\n  var diffAngle = coordEndAngle - coordStartAngle;\n\n  if (coordinate.isTransposed) {\n    endAngle = box.maxY * diffAngle;\n    startAngle = box.minY * diffAngle;\n  } else {\n    endAngle = box.maxX * diffAngle;\n    startAngle = box.minX * diffAngle;\n  }\n\n  endAngle += coordStartAngle;\n  startAngle += coordStartAngle;\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n}\n/**\n * @ignore\n * 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n */\n\nexport function getPolygonCentroid(xs, ys) {\n  if (isNumber(xs) && isNumber(ys)) {\n    // 普通色块图，xs 和 ys 是数值\n    return [xs, ys];\n  }\n\n  var i = -1;\n  var x = 0;\n  var y = 0;\n  var former;\n  var current = xs.length - 1;\n  var diff;\n  var k = 0;\n\n  while (++i < xs.length) {\n    former = current;\n    current = i;\n    k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n    x += (xs[former] + xs[current]) * diff;\n    y += (ys[former] + ys[current]) * diff;\n  }\n\n  k *= 3;\n  return [x / k, y / k];\n}\n/**\n * @ignore\n * 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined\n */\n\nexport function getReplaceAttrs(sourceShape, targetShape) {\n  var originAttrs = sourceShape.attr();\n  var newAttrs = targetShape.attr();\n  each(originAttrs, function (v, k) {\n    if (newAttrs[k] === undefined) {\n      newAttrs[k] = undefined;\n    }\n  });\n  return newAttrs;\n}","map":{"version":3,"sources":["../../src/util/graphics.ts"],"names":[],"mappings":"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","sourcesContent":["import { BBox } from '@antv/g-svg';\nimport { each, isEmpty, isNumber, isNumberEqual } from '@antv/util';\nimport { Coordinate, IShape, Point } from '../dependents';\nimport { ShapeInfo } from '../interface';\n\n// 获取图形的包围盒\nfunction getPointsBox(points) {\n  if (isEmpty(points)) {\n    return null;\n  }\n\n  let minX = points[0].x;\n  let maxX = points[0].x;\n  let minY = points[0].y;\n  let maxY = points[0].y;\n  each(points, (point) => {\n    minX = minX > point.x ? point.x : minX;\n    maxX = maxX < point.x ? point.x : maxX;\n    minY = minY > point.y ? point.y : minY;\n    maxY = maxY < point.y ? point.y : maxY;\n  });\n\n  return {\n    minX,\n    maxX,\n    minY,\n    maxY,\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n  };\n}\n\n/**\n * @ignore\n * 根据弧度计算极坐标系下的坐标点\n * @param centerX\n * @param centerY\n * @param radius\n * @param angleInRadian\n * @returns\n */\nexport function polarToCartesian(centerX: number, centerY: number, radius: number, angleInRadian: number) {\n  return {\n    x: centerX + radius * Math.cos(angleInRadian),\n    y: centerY + radius * Math.sin(angleInRadian),\n  };\n}\n\n/**\n * @ignore\n * 根据起始角度计算绘制扇形的 path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getSectorPath(\n  centerX: number,\n  centerY: number,\n  radius: number,\n  startAngleInRadian: number,\n  endAngleInRadian: number,\n  innerRadius: number = 0\n) {\n  const start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  const end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n\n  const innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n  const innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n\n  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n    // 整个圆是分割成两个圆\n    const middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    const innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n    const circlePathCommands = [\n      ['M', start.x, start.y],\n      ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 1, end.x, end.y],\n      ['M', innerStart.x, innerStart.y],\n    ];\n    if (innerRadius) {\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n    }\n\n    circlePathCommands.push(['M', start.x, start.y]);\n    circlePathCommands.push(['Z']);\n\n    return circlePathCommands;\n  }\n\n  const arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  const sectorPathCommands = [\n    ['M', start.x, start.y],\n    ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n    ['L', innerEnd.x, innerEnd.y],\n  ];\n  if (innerRadius) {\n    sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n  }\n  sectorPathCommands.push(['L', start.x, start.y]);\n  sectorPathCommands.push(['Z']);\n\n  return sectorPathCommands;\n}\n\n/**\n * @ignore\n * Gets arc path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getArcPath(\n  centerX: number,\n  centerY: number,\n  radius: number,\n  startAngleInRadian: number,\n  endAngleInRadian: number\n) {\n  const start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  const end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n\n  if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n    const middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    return [\n      ['M', start.x, start.y],\n      ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 1, start.x, start.y],\n      ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 0, start.x, start.y],\n      ['Z'],\n    ];\n  }\n  const arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  return [\n    ['M', start.x, start.y],\n    ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n  ];\n}\n\n/**\n * @ignore\n * 从数据模型中的 points 换算角度\n * @param shapeModel\n * @param coordinate\n * @returns\n */\nexport function getAngle(shapeModel: ShapeInfo, coordinate: Coordinate) {\n  const points = shapeModel.points;\n  const box = getPointsBox(points);\n  let endAngle;\n  let startAngle;\n  const { startAngle: coordStartAngle, endAngle: coordEndAngle } = coordinate;\n  const diffAngle = coordEndAngle - coordStartAngle;\n\n  if (coordinate.isTransposed) {\n    endAngle = box.maxY * diffAngle;\n    startAngle = box.minY * diffAngle;\n  } else {\n    endAngle = box.maxX * diffAngle;\n    startAngle = box.minX * diffAngle;\n  }\n  endAngle += coordStartAngle;\n  startAngle += coordStartAngle;\n  return {\n    startAngle,\n    endAngle,\n  };\n}\n\n/**\n * @ignore\n * 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n */\nexport function getPolygonCentroid(xs: number | number[], ys: number | number[]) {\n  if (isNumber(xs) && isNumber(ys)) {\n    // 普通色块图，xs 和 ys 是数值\n    return [xs, ys];\n  }\n  let i = -1;\n  let x = 0;\n  let y = 0;\n  let former;\n  let current = (xs as number[]).length - 1;\n  let diff;\n  let k = 0;\n  while (++i < (xs as number[]).length) {\n    former = current;\n    current = i;\n    k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n    x += (xs[former] + xs[current]) * diff;\n    y += (ys[former] + ys[current]) * diff;\n  }\n  k *= 3;\n  return [x / k, y / k];\n}\n\n/**\n * @ignore\n * 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined\n */\nexport function getReplaceAttrs(sourceShape: IShape, targetShape: IShape) {\n  const originAttrs = sourceShape.attr();\n  const newAttrs = targetShape.attr();\n  each(originAttrs, (v, k) => {\n    if (newAttrs[k] === undefined) {\n      newAttrs[k] = undefined;\n    }\n  });\n  return newAttrs;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}