{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { deepMix, each, get, isUndefined } from '@antv/util';\nimport { DIRECTION, COMPONENT_TYPE, LAYER } from '../../constant';\nimport { CircleAxis, CircleGrid, LineAxis, LineGrid } from '../../dependents';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate/';\nimport { getAxisDirection, getAxisFactorByRegion, getAxisRegion, getAxisThemeCfg, getAxisTitleOptions, getAxisTitleText, getCircleAxisCenterRadius, isVertical } from '../../util/axis';\nimport { getAxisOption } from '../../util/axis';\nimport { getCircleGridItems, getGridThemeCfg, getLineGridItems, showGrid } from '../../util/grid';\nimport { omit } from '../../util/helper';\nimport { Controller } from './base'; // update 组件的时候，忽略的数据更新\n\nvar OMIT_CFG = ['container']; // 坐标轴默认动画配置\n\nvar AXIS_DEFAULT_ANIMATE_CFG = __assign(__assign({}, DEFAULT_ANIMATE_CFG), {\n  appear: null\n});\n/**\n * @ignore\n * G2 Axis controller, will:\n *  - create component\n *    - axis\n *    - grid\n *  - life circle\n */\n\n\nvar Axis =\n/** @class */\nfunction (_super) {\n  __extends(Axis, _super);\n\n  function Axis(view) {\n    var _this = _super.call(this, view) || this;\n    /** 使用 object 存储组件 */\n\n\n    _this.cache = new Map(); // 先创建 gridContainer，将 grid 放到 axis 底层\n\n    _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();\n    _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();\n    _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();\n    _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();\n    return _this;\n  }\n\n  Object.defineProperty(Axis.prototype, \"name\", {\n    get: function () {\n      return 'axis';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Axis.prototype.init = function () {};\n\n  Axis.prototype.render = function () {\n    this.update();\n  };\n  /**\n   * 更新组件布局，位置大小\n   */\n\n\n  Axis.prototype.layout = function () {\n    var _this = this;\n\n    var coordinate = this.view.getCoordinate();\n    each(this.getComponents(), function (co) {\n      var component = co.component,\n          direction = co.direction,\n          type = co.type,\n          extra = co.extra;\n      var dim = extra.dim,\n          scale = extra.scale,\n          alignTick = extra.alignTick;\n      var updated;\n\n      if (type === COMPONENT_TYPE.AXIS) {\n        if (coordinate.isPolar) {\n          if (dim === 'x') {\n            updated = coordinate.isTransposed ? getAxisRegion(coordinate, direction) : getCircleAxisCenterRadius(coordinate);\n          } else if (dim === 'y') {\n            updated = coordinate.isTransposed ? getCircleAxisCenterRadius(coordinate) : getAxisRegion(coordinate, direction);\n          }\n        } else {\n          updated = getAxisRegion(coordinate, direction);\n        }\n      } else if (type === COMPONENT_TYPE.GRID) {\n        if (coordinate.isPolar) {\n          var items = void 0;\n\n          if (coordinate.isTransposed) {\n            items = dim === 'x' ? getCircleGridItems(coordinate, _this.view.getYScales()[0], scale, alignTick, dim) : getLineGridItems(coordinate, scale, dim, alignTick);\n          } else {\n            items = dim === 'x' ? getLineGridItems(coordinate, scale, dim, alignTick) : getCircleGridItems(coordinate, _this.view.getXScale(), scale, alignTick, dim);\n          }\n\n          updated = {\n            items: items,\n            // coordinate 更新之后，center 也变化了\n            center: _this.view.getCoordinate().getCenter()\n          };\n        } else {\n          updated = {\n            items: getLineGridItems(coordinate, scale, dim, alignTick)\n          };\n        }\n      }\n\n      component.update(updated);\n    });\n  };\n  /**\n   * 更新 axis 组件\n   */\n\n\n  Axis.prototype.update = function () {\n    this.option = this.view.getOptions().axes;\n    var updatedCache = new Map();\n    this.updateXAxes(updatedCache);\n    this.updateYAxes(updatedCache); // 处理完成之后，销毁删除的\n    // 不在处理中的\n\n    var newCache = new Map();\n    this.cache.forEach(function (co, key) {\n      if (updatedCache.has(key)) {\n        newCache.set(key, co);\n      } else {\n        // 不存在，则是所有需要被销毁的组件\n        co.component.destroy();\n      }\n    }); // 更新缓存\n\n    this.cache = newCache;\n  };\n\n  Axis.prototype.clear = function () {\n    _super.prototype.clear.call(this);\n\n    this.cache.clear();\n    this.gridContainer.clear();\n    this.gridForeContainer.clear();\n    this.axisContainer.clear();\n    this.axisForeContainer.clear();\n  };\n\n  Axis.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.gridContainer.remove(true);\n    this.gridForeContainer.remove(true);\n    this.axisContainer.remove(true);\n    this.axisForeContainer.remove(true);\n  };\n  /**\n   * @override\n   */\n\n\n  Axis.prototype.getComponents = function () {\n    var co = [];\n    this.cache.forEach(function (value) {\n      co.push(value);\n    });\n    return co;\n  };\n  /**\n   * 更新 x axis\n   * @param updatedCache\n   */\n\n\n  Axis.prototype.updateXAxes = function (updatedCache) {\n    // x axis\n    var scale = this.view.getXScale();\n\n    if (!scale || scale.isIdentity) {\n      return;\n    }\n\n    var xAxisOption = getAxisOption(this.option, scale.field);\n\n    if (xAxisOption === false) {\n      return;\n    }\n\n    var direction = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);\n    var layer = LAYER.BG;\n    var dim = 'x';\n    var coordinate = this.view.getCoordinate();\n    var axisId = this.getId('axis', scale.field);\n    var gridId = this.getId('grid', scale.field);\n\n    if (coordinate.isRect) {\n      // 1. do axis update\n      var axis = this.cache.get(axisId); // 存在则更新\n\n      if (axis) {\n        var cfg = this.getLineAxisCfg(scale, xAxisOption, direction);\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      } // 2. do grid update\n\n\n      var grid = this.cache.get(gridId); // 存在则更新\n\n      if (grid) {\n        var cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);\n\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else if (coordinate.isPolar) {\n      // 1. do axis update\n      var axis = this.cache.get(axisId); // 存在则更新\n\n      if (axis) {\n        var cfg = coordinate.isTransposed ? this.getLineAxisCfg(scale, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale, xAxisOption, direction);\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            // 默认不渲染转置极坐标下的坐标轴\n            return;\n          } else {\n            // 如果用户打开了隐藏的坐标轴 chart.axis(true)/chart.axis('x', true)\n            // 那么对于转置了的极坐标，半径轴显示的是 x 轴对应的数据\n            axis = this.createLineAxis(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);\n        }\n\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      } // 2. do grid update\n\n\n      var grid = this.cache.get(gridId); // 存在则更新\n\n      if (grid) {\n        var cfg = coordinate.isTransposed ? this.getCircleGridCfg(scale, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale, xAxisOption, DIRECTION.CIRCLE, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            return;\n          } else {\n            grid = this.createCircleGrid(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          // grid，极坐标下的 x 轴网格线沿着半径方向绘制\n          grid = this.createLineGrid(scale, xAxisOption, layer, DIRECTION.CIRCLE, dim);\n        }\n\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else {// helix and other, do not draw axis\n    }\n  };\n\n  Axis.prototype.updateYAxes = function (updatedCache) {\n    var _this = this; // y axes\n\n\n    var yScales = this.view.getYScales();\n    each(yScales, function (scale, idx) {\n      // @ts-ignore\n      if (!scale || scale.isIdentity) {\n        return;\n      }\n\n      var field = scale.field;\n      var yAxisOption = getAxisOption(_this.option, field);\n\n      if (yAxisOption !== false) {\n        var layer = LAYER.BG;\n        var dim = 'y';\n\n        var axisId = _this.getId('axis', field);\n\n        var gridId = _this.getId('grid', field);\n\n        var coordinate = _this.view.getCoordinate();\n\n        if (coordinate.isRect) {\n          var direction = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT); // 1. do axis update\n\n          var axis = _this.cache.get(axisId); // 存在则更新\n\n\n          if (axis) {\n            var cfg = _this.getLineAxisCfg(scale, yAxisOption, direction);\n\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            axis = _this.createLineAxis(scale, yAxisOption, layer, direction, dim);\n\n            _this.cache.set(axisId, axis);\n\n            updatedCache.set(axisId, axis);\n          } // 2. do grid update\n\n\n          var grid = _this.cache.get(gridId); // 存在则更新\n\n\n          if (grid) {\n            var cfg = _this.getLineGridCfg(scale, yAxisOption, direction, dim);\n\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            grid = _this.createLineGrid(scale, yAxisOption, layer, direction, dim);\n\n            if (grid) {\n              _this.cache.set(gridId, grid);\n\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else if (coordinate.isPolar) {\n          // 1. do axis update\n          var axis = _this.cache.get(axisId); // 存在则更新\n\n\n          if (axis) {\n            var cfg = coordinate.isTransposed ? _this.getCircleAxisCfg(scale, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale, yAxisOption, DIRECTION.RADIUS); // @ts-ignore\n\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                axis = _this.createCircleAxis(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              axis = _this.createLineAxis(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n\n            _this.cache.set(axisId, axis);\n\n            updatedCache.set(axisId, axis);\n          } // 2. do grid update\n\n\n          var grid = _this.cache.get(gridId); // 存在则更新\n\n\n          if (grid) {\n            var cfg = coordinate.isTransposed ? _this.getLineGridCfg(scale, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale, yAxisOption, DIRECTION.RADIUS, dim);\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                grid = _this.createLineGrid(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              grid = _this.createCircleGrid(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n\n            if (grid) {\n              _this.cache.set(gridId, grid);\n\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else {// helix and other, do not draw axis\n        }\n      }\n    });\n  };\n  /**\n   * 创建 line axis\n   * @param scale\n   * @param option\n   * @param layer\n   * @param direction\n   * @param dim\n   */\n\n\n  Axis.prototype.createLineAxis = function (scale, option, layer, direction, dim) {\n    // axis\n    var axis = {\n      component: new LineAxis(this.getLineAxisCfg(scale, option, direction)),\n      layer: layer,\n      direction: direction === DIRECTION.RADIUS ? DIRECTION.NONE : direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: {\n        dim: dim,\n        scale: scale\n      }\n    };\n    axis.component.set('field', scale.field);\n    axis.component.init();\n    return axis;\n  };\n\n  Axis.prototype.createLineGrid = function (scale, option, layer, direction, dim) {\n    var cfg = this.getLineGridCfg(scale, option, direction, dim);\n\n    if (cfg) {\n      var grid = {\n        component: new LineGrid(cfg),\n        layer: layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim: dim,\n          scale: scale,\n          alignTick: get(cfg, 'alignTick', true)\n        }\n      };\n      grid.component.init();\n      return grid;\n    }\n  };\n\n  Axis.prototype.createCircleAxis = function (scale, option, layer, direction, dim) {\n    var axis = {\n      component: new CircleAxis(this.getCircleAxisCfg(scale, option, direction)),\n      layer: layer,\n      direction: direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: {\n        dim: dim,\n        scale: scale\n      }\n    };\n    axis.component.set('field', scale.field);\n    axis.component.init();\n    return axis;\n  };\n\n  Axis.prototype.createCircleGrid = function (scale, option, layer, direction, dim) {\n    var cfg = this.getCircleGridCfg(scale, option, direction, dim);\n\n    if (cfg) {\n      var grid = {\n        component: new CircleGrid(cfg),\n        layer: layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim: dim,\n          scale: scale,\n          alignTick: get(cfg, 'alignTick', true)\n        }\n      };\n      grid.component.init();\n      return grid;\n    }\n  };\n  /**\n   * generate line axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return line axis cfg\n   */\n\n\n  Axis.prototype.getLineAxisCfg = function (scale, axisOption, direction) {\n    var container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    var coordinate = this.view.getCoordinate();\n    var region = getAxisRegion(coordinate, direction);\n    var titleText = getAxisTitleText(scale, axisOption);\n    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction); // the cfg order should be ensure\n\n    var optionWithTitle = get(axisOption, ['title']) ? deepMix({\n      title: {\n        style: {\n          text: titleText\n        }\n      }\n    }, {\n      title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title)\n    }, axisOption) : axisOption;\n    var cfg = deepMix(__assign(__assign({\n      container: container\n    }, region), {\n      ticks: scale.getTicks().map(function (tick) {\n        return {\n          id: \"\" + tick.tickValue,\n          name: tick.text,\n          value: tick.value\n        };\n      }),\n      verticalFactor: coordinate.isPolar ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate.getCenter()),\n      theme: axisThemeCfg\n    }), axisThemeCfg, optionWithTitle);\n\n    var _a = this.getAnimateCfg(cfg),\n        animate = _a.animate,\n        animateOption = _a.animateOption;\n\n    cfg.animateOption = animateOption;\n    cfg.animate = animate; // 计算 verticalLimitLength\n\n    var isAxisVertical = isVertical(region); // TODO: 1 / 3 等默认值需要有一个全局的配置的地方\n\n    var verticalLimitLength = get(cfg, 'verticalLimitLength', isAxisVertical ? 1 / 3 : 1 / 2);\n\n    if (verticalLimitLength <= 1) {\n      // 配置的相对值，相对于画布\n      var canvasWidth = this.view.getCanvas().get('width');\n      var canvasHeight = this.view.getCanvas().get('height');\n      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);\n    }\n\n    return cfg;\n  };\n  /**\n   * generate line grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @param dim\n   * @return line grid cfg\n   */\n\n\n  Axis.prototype.getLineGridCfg = function (scale, axisOption, direction, dim) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    }\n\n    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction); // the cfg order should be ensure\n    // grid 动画以 axis 为准\n\n    var gridCfg = deepMix({\n      container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer\n    }, gridThemeCfg, get(axisOption, 'grid'), this.getAnimateCfg(axisOption));\n    gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale, dim, get(gridCfg, 'alignTick', true));\n    return gridCfg;\n  };\n  /**\n   * generate circle axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle axis cfg\n   */\n\n\n  Axis.prototype.getCircleAxisCfg = function (scale, axisOption, direction) {\n    var container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    var coordinate = this.view.getCoordinate();\n    var ticks = scale.getTicks().map(function (tick) {\n      return {\n        id: \"\" + tick.tickValue,\n        name: tick.text,\n        value: tick.value\n      };\n    });\n\n    if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {\n      // x 轴对应的值如果是非 cat 类型，在整圆的情况下坐标轴第一个和最后一个文本会重叠，默认只展示第一个文本\n      ticks.pop();\n    }\n\n    var titleText = getAxisTitleText(scale, axisOption);\n    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE); // the cfg order should be ensure\n\n    var optionWithTitle = get(axisOption, ['title']) ? deepMix({\n      title: {\n        style: {\n          text: titleText\n        }\n      }\n    }, {\n      title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title)\n    }, axisOption) : axisOption;\n    var cfg = deepMix(__assign(__assign({\n      container: container\n    }, getCircleAxisCenterRadius(this.view.getCoordinate())), {\n      ticks: ticks,\n      verticalFactor: 1,\n      theme: axisThemeCfg\n    }), axisThemeCfg, optionWithTitle);\n\n    var _a = this.getAnimateCfg(cfg),\n        animate = _a.animate,\n        animateOption = _a.animateOption;\n\n    cfg.animate = animate;\n    cfg.animateOption = animateOption;\n    return cfg;\n  };\n  /**\n   * generate circle grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle grid cfg\n   */\n\n\n  Axis.prototype.getCircleGridCfg = function (scale, axisOption, direction, dim) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    } // the cfg order should be ensure\n    // grid 动画以 axis 为准\n\n\n    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);\n    var gridCfg = deepMix({\n      container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,\n      center: this.view.getCoordinate().getCenter()\n    }, gridThemeCfg, get(axisOption, 'grid'), this.getAnimateCfg(axisOption));\n    var alignTick = get(gridCfg, 'alignTick', true);\n    var verticalScale = dim === 'x' ? this.view.getYScales()[0] : this.view.getXScale();\n    gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale, alignTick, dim); // the cfg order should be ensure\n    // grid 动画以 axis 为准\n\n    return gridCfg;\n  };\n\n  Axis.prototype.getId = function (name, key) {\n    var coordinate = this.view.getCoordinate(); // 坐标系类型也作为组件的 key\n\n    return name + \"-\" + key + \"-\" + coordinate.type;\n  };\n\n  Axis.prototype.getAnimateCfg = function (cfg) {\n    return {\n      animate: this.view.getOptions().animate && get(cfg, 'animate'),\n      animateOption: cfg && cfg.animateOption ? deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG\n    };\n  };\n\n  return Axis;\n}(Controller);\n\nexport default Axis;","map":{"version":3,"sources":["../../../src/chart/controller/axis.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepMix, each, get, isUndefined } from '@antv/util';\nimport { DIRECTION, COMPONENT_TYPE, LAYER } from '../../constant';\nimport { CircleAxis, CircleGrid, IGroup, LineAxis, LineGrid, Scale } from '../../dependents';\nimport { AxisCfg, AxisOption, ComponentOption } from '../../interface';\n\nimport { DEFAULT_ANIMATE_CFG } from '../../animate/';\n\nimport {\n  getAxisDirection,\n  getAxisFactorByRegion,\n  getAxisRegion,\n  getAxisThemeCfg,\n  getAxisTitleOptions,\n  getAxisTitleText,\n  getCircleAxisCenterRadius,\n  isVertical,\n} from '../../util/axis';\nimport { getAxisOption } from '../../util/axis';\nimport { getCircleGridItems, getGridThemeCfg, getLineGridItems, showGrid } from '../../util/grid';\nimport { omit } from '../../util/helper';\nimport View from '../view';\nimport { Controller } from './base';\n\ntype Option = Record<string, AxisOption> | boolean;\n\ntype Cache = Map<string, ComponentOption>;\n\n// update 组件的时候，忽略的数据更新\nconst OMIT_CFG = ['container'];\n\n// 坐标轴默认动画配置\nconst AXIS_DEFAULT_ANIMATE_CFG = {\n  ...DEFAULT_ANIMATE_CFG,\n  appear: null,\n};\n\n/**\n * @ignore\n * G2 Axis controller, will:\n *  - create component\n *    - axis\n *    - grid\n *  - life circle\n */\nexport default class Axis extends Controller<Option> {\n  /** the draw group of axis */\n  private axisContainer: IGroup;\n  private axisForeContainer: IGroup;\n  private gridContainer: IGroup;\n  private gridForeContainer: IGroup;\n\n  /** 使用 object 存储组件 */\n  private cache: Cache = new Map<string, ComponentOption>();\n\n  constructor(view: View) {\n    super(view);\n\n    // 先创建 gridContainer，将 grid 放到 axis 底层\n    this.gridContainer = this.view.getLayer(LAYER.BG).addGroup();\n    this.gridForeContainer = this.view.getLayer(LAYER.FORE).addGroup();\n    this.axisContainer = this.view.getLayer(LAYER.BG).addGroup();\n    this.axisForeContainer = this.view.getLayer(LAYER.FORE).addGroup();\n  }\n\n  public get name(): string {\n    return 'axis';\n  }\n\n  public init() {}\n\n  public render() {\n    this.update();\n  }\n\n  /**\n   * 更新组件布局，位置大小\n   */\n  public layout() {\n    const coordinate = this.view.getCoordinate();\n\n    each(this.getComponents(), (co: ComponentOption) => {\n      const { component, direction, type, extra } = co;\n      const { dim, scale, alignTick } = extra;\n\n      let updated;\n\n      if (type === COMPONENT_TYPE.AXIS) {\n        if (coordinate.isPolar) {\n          if (dim === 'x') {\n            updated = coordinate.isTransposed\n              ? getAxisRegion(coordinate, direction)\n              : getCircleAxisCenterRadius(coordinate);\n          } else if (dim === 'y') {\n            updated = coordinate.isTransposed\n              ? getCircleAxisCenterRadius(coordinate)\n              : getAxisRegion(coordinate, direction);\n          }\n        } else {\n          updated = getAxisRegion(coordinate, direction);\n        }\n      } else if (type === COMPONENT_TYPE.GRID) {\n        if (coordinate.isPolar) {\n          let items;\n          if (coordinate.isTransposed) {\n            items =\n              dim === 'x'\n                ? getCircleGridItems(coordinate, this.view.getYScales()[0], scale, alignTick, dim)\n                : getLineGridItems(coordinate, scale, dim, alignTick);\n          } else {\n            items =\n              dim === 'x'\n                ? getLineGridItems(coordinate, scale, dim, alignTick)\n                : getCircleGridItems(coordinate, this.view.getXScale(), scale, alignTick, dim);\n          }\n          updated = {\n            items,\n            // coordinate 更新之后，center 也变化了\n            center: this.view.getCoordinate().getCenter(),\n          };\n        } else {\n          updated = { items: getLineGridItems(coordinate, scale, dim, alignTick) };\n        }\n      }\n      component.update(updated);\n    });\n  }\n\n  /**\n   * 更新 axis 组件\n   */\n  public update() {\n    this.option = this.view.getOptions().axes;\n\n    const updatedCache = new Map<string, ComponentOption>();\n\n    this.updateXAxes(updatedCache);\n    this.updateYAxes(updatedCache);\n\n    // 处理完成之后，销毁删除的\n    // 不在处理中的\n    const newCache = new Map<string, ComponentOption>();\n\n    this.cache.forEach((co: ComponentOption, key: string) => {\n      if (updatedCache.has(key)) {\n        newCache.set(key, co);\n      } else {\n        // 不存在，则是所有需要被销毁的组件\n        co.component.destroy();\n      }\n    });\n\n    // 更新缓存\n    this.cache = newCache;\n  }\n\n  public clear() {\n    super.clear();\n\n    this.cache.clear();\n    this.gridContainer.clear();\n    this.gridForeContainer.clear();\n    this.axisContainer.clear();\n    this.axisForeContainer.clear();\n  }\n\n  public destroy() {\n    super.destroy();\n\n    this.gridContainer.remove(true);\n    this.gridForeContainer.remove(true);\n    this.axisContainer.remove(true);\n    this.axisForeContainer.remove(true);\n  }\n\n  /**\n   * @override\n   */\n  public getComponents(): ComponentOption[] {\n    const co = [];\n\n    this.cache.forEach((value: ComponentOption) => {\n      co.push(value);\n    });\n\n    return co;\n  }\n\n  /**\n   * 更新 x axis\n   * @param updatedCache\n   */\n  private updateXAxes(updatedCache: Cache) {\n    // x axis\n    const scale = this.view.getXScale();\n\n    if (!scale || scale.isIdentity) {\n      return;\n    }\n\n    const xAxisOption = getAxisOption(this.option, scale.field);\n    if (xAxisOption === false) {\n      return;\n    }\n\n    const direction = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);\n    const layer = LAYER.BG;\n    const dim = 'x';\n\n    const coordinate = this.view.getCoordinate();\n\n    const axisId = this.getId('axis', scale.field);\n    const gridId = this.getId('grid', scale.field);\n\n    if (coordinate.isRect) {\n      // 1. do axis update\n      let axis = this.cache.get(axisId);\n      // 存在则更新\n      if (axis) {\n        const cfg = this.getLineAxisCfg(scale, xAxisOption, direction);\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      }\n\n      // 2. do grid update\n      let grid = this.cache.get(gridId);\n      // 存在则更新\n      if (grid) {\n        const cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else if (coordinate.isPolar) {\n      // 1. do axis update\n      let axis = this.cache.get(axisId);\n      // 存在则更新\n      if (axis) {\n        const cfg = coordinate.isTransposed\n          ? this.getLineAxisCfg(scale, xAxisOption, DIRECTION.RADIUS)\n          : this.getCircleAxisCfg(scale, xAxisOption, direction);\n\n        omit(cfg, OMIT_CFG);\n        axis.component.update(cfg);\n        updatedCache.set(axisId, axis);\n      } else {\n        // 不存在，则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            // 默认不渲染转置极坐标下的坐标轴\n            return;\n          } else {\n            // 如果用户打开了隐藏的坐标轴 chart.axis(true)/chart.axis('x', true)\n            // 那么对于转置了的极坐标，半径轴显示的是 x 轴对应的数据\n            axis = this.createLineAxis(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);\n        }\n        this.cache.set(axisId, axis);\n        updatedCache.set(axisId, axis);\n      }\n\n      // 2. do grid update\n      let grid = this.cache.get(gridId);\n      // 存在则更新\n      if (grid) {\n        const cfg = coordinate.isTransposed\n          ? this.getCircleGridCfg(scale, xAxisOption, DIRECTION.RADIUS, dim)\n          : this.getLineGridCfg(scale, xAxisOption, DIRECTION.CIRCLE, dim);\n        omit(cfg, OMIT_CFG);\n        grid.component.update(cfg);\n        updatedCache.set(gridId, grid);\n      } else {\n        // 不存在则创建\n        if (coordinate.isTransposed) {\n          if (isUndefined(xAxisOption)) {\n            return;\n          } else {\n            grid = this.createCircleGrid(scale, xAxisOption, layer, DIRECTION.RADIUS, dim);\n          }\n        } else {\n          // grid，极坐标下的 x 轴网格线沿着半径方向绘制\n          grid = this.createLineGrid(scale, xAxisOption, layer, DIRECTION.CIRCLE, dim);\n        }\n\n        if (grid) {\n          this.cache.set(gridId, grid);\n          updatedCache.set(gridId, grid);\n        }\n      }\n    } else {\n      // helix and other, do not draw axis\n    }\n  }\n\n  private updateYAxes(updatedCache: Cache) {\n    // y axes\n    const yScales = this.view.getYScales();\n\n    each(yScales, (scale: Scale, idx: number) => {\n      // @ts-ignore\n      if (!scale || scale.isIdentity) {\n        return;\n      }\n      const { field } = scale;\n      const yAxisOption = getAxisOption(this.option, field);\n\n      if (yAxisOption !== false) {\n        const layer = LAYER.BG;\n        const dim = 'y';\n        const axisId = this.getId('axis', field);\n        const gridId = this.getId('grid', field);\n\n        const coordinate = this.view.getCoordinate();\n\n        if (coordinate.isRect) {\n          const direction = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);\n\n          // 1. do axis update\n          let axis = this.cache.get(axisId);\n          // 存在则更新\n          if (axis) {\n            const cfg = this.getLineAxisCfg(scale, yAxisOption, direction);\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            axis = this.createLineAxis(scale, yAxisOption, layer, direction, dim);\n            this.cache.set(axisId, axis);\n            updatedCache.set(axisId, axis);\n          }\n\n          // 2. do grid update\n          let grid = this.cache.get(gridId);\n          // 存在则更新\n          if (grid) {\n            const cfg = this.getLineGridCfg(scale, yAxisOption, direction, dim);\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            grid = this.createLineGrid(scale, yAxisOption, layer, direction, dim);\n            if (grid) {\n              this.cache.set(gridId, grid);\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else if (coordinate.isPolar) {\n          // 1. do axis update\n          let axis = this.cache.get(axisId);\n          // 存在则更新\n          if (axis) {\n            const cfg = coordinate.isTransposed\n              ? this.getCircleAxisCfg(scale, yAxisOption, DIRECTION.CIRCLE)\n              : this.getLineAxisCfg(scale, yAxisOption, DIRECTION.RADIUS);\n\n            // @ts-ignore\n            omit(cfg, OMIT_CFG);\n            axis.component.update(cfg);\n            updatedCache.set(axisId, axis);\n          } else {\n            // 不存在，则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                axis = this.createCircleAxis(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              axis = this.createLineAxis(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n\n            this.cache.set(axisId, axis);\n            updatedCache.set(axisId, axis);\n          }\n\n          // 2. do grid update\n          let grid = this.cache.get(gridId);\n          // 存在则更新\n          if (grid) {\n            const cfg = coordinate.isTransposed\n              ? this.getLineGridCfg(scale, yAxisOption, DIRECTION.CIRCLE, dim)\n              : this.getCircleGridCfg(scale, yAxisOption, DIRECTION.RADIUS, dim);\n            omit(cfg, OMIT_CFG);\n            grid.component.update(cfg);\n            updatedCache.set(gridId, grid);\n          } else {\n            // 不存在则创建\n            if (coordinate.isTransposed) {\n              if (isUndefined(yAxisOption)) {\n                return;\n              } else {\n                grid = this.createLineGrid(scale, yAxisOption, layer, DIRECTION.CIRCLE, dim);\n              }\n            } else {\n              grid = this.createCircleGrid(scale, yAxisOption, layer, DIRECTION.RADIUS, dim);\n            }\n\n            if (grid) {\n              this.cache.set(gridId, grid);\n              updatedCache.set(gridId, grid);\n            }\n          }\n        } else {\n          // helix and other, do not draw axis\n        }\n      }\n    });\n  }\n\n  /**\n   * 创建 line axis\n   * @param scale\n   * @param option\n   * @param layer\n   * @param direction\n   * @param dim\n   */\n  private createLineAxis(\n    scale: Scale,\n    option: AxisCfg,\n    layer: LAYER,\n    direction: DIRECTION,\n    dim: string\n  ): ComponentOption {\n    // axis\n    const axis = {\n      component: new LineAxis(this.getLineAxisCfg(scale, option, direction)),\n      layer,\n      direction: direction === DIRECTION.RADIUS ? DIRECTION.NONE : direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: { dim, scale },\n    };\n    axis.component.set('field', scale.field);\n    axis.component.init();\n\n    return axis;\n  }\n\n  private createLineGrid(\n    scale: Scale,\n    option: AxisCfg,\n    layer: LAYER,\n    direction: DIRECTION,\n    dim: string\n  ): ComponentOption {\n    const cfg = this.getLineGridCfg(scale, option, direction, dim);\n    if (cfg) {\n      const grid = {\n        component: new LineGrid(cfg),\n        layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim,\n          scale,\n          alignTick: get(cfg, 'alignTick', true),\n        },\n      };\n      grid.component.init();\n\n      return grid;\n    }\n  }\n\n  private createCircleAxis(\n    scale: Scale,\n    option: AxisCfg,\n    layer: LAYER,\n    direction: DIRECTION,\n    dim: string\n  ): ComponentOption {\n    const axis = {\n      component: new CircleAxis(this.getCircleAxisCfg(scale, option, direction)),\n      layer,\n      direction,\n      type: COMPONENT_TYPE.AXIS,\n      extra: { dim, scale },\n    };\n    axis.component.set('field', scale.field);\n\n    axis.component.init();\n\n    return axis;\n  }\n\n  private createCircleGrid(\n    scale: Scale,\n    option: AxisCfg,\n    layer: LAYER,\n    direction: DIRECTION,\n    dim: string\n  ): ComponentOption {\n    const cfg = this.getCircleGridCfg(scale, option, direction, dim);\n    if (cfg) {\n      const grid = {\n        component: new CircleGrid(cfg),\n        layer,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.GRID,\n        extra: {\n          dim,\n          scale,\n          alignTick: get(cfg, 'alignTick', true),\n        },\n      };\n\n      grid.component.init();\n      return grid;\n    }\n  }\n\n  /**\n   * generate line axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return line axis cfg\n   */\n  private getLineAxisCfg(scale: Scale, axisOption: AxisCfg, direction: DIRECTION) {\n    const container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    const coordinate = this.view.getCoordinate();\n    const region = getAxisRegion(coordinate, direction);\n    const titleText = getAxisTitleText(scale, axisOption);\n    const axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction);\n    // the cfg order should be ensure\n    const optionWithTitle = get(axisOption, ['title'])\n      ? deepMix(\n          { title: { style: { text: titleText } } },\n          { title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title) },\n          axisOption\n        )\n      : axisOption;\n\n    const cfg = deepMix(\n      {\n        container,\n        ...region,\n        ticks: scale.getTicks().map((tick) => ({ id: `${tick.tickValue}`, name: tick.text, value: tick.value })),\n        verticalFactor: coordinate.isPolar\n          ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1\n          : getAxisFactorByRegion(region, coordinate.getCenter()),\n        theme: axisThemeCfg,\n      },\n      axisThemeCfg,\n      optionWithTitle\n    );\n    const { animate, animateOption } = this.getAnimateCfg(cfg);\n    cfg.animateOption = animateOption;\n    cfg.animate = animate;\n\n    // 计算 verticalLimitLength\n    const isAxisVertical = isVertical(region);\n    // TODO: 1 / 3 等默认值需要有一个全局的配置的地方\n    const verticalLimitLength = get(cfg, 'verticalLimitLength', isAxisVertical ? 1 / 3 : 1 / 2);\n    if (verticalLimitLength <= 1) {\n      // 配置的相对值，相对于画布\n      const canvasWidth = this.view.getCanvas().get('width');\n      const canvasHeight = this.view.getCanvas().get('height');\n      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);\n    }\n\n    return cfg;\n  }\n\n  /**\n   * generate line grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @param dim\n   * @return line grid cfg\n   */\n  private getLineGridCfg(scale: Scale, axisOption: AxisCfg, direction: DIRECTION, dim: string) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    }\n    const gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction);\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    const gridCfg = deepMix(\n      {\n        container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,\n      },\n      gridThemeCfg,\n      get(axisOption, 'grid'),\n      this.getAnimateCfg(axisOption)\n    );\n    gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale, dim, get(gridCfg, 'alignTick', true));\n\n    return gridCfg;\n  }\n\n  /**\n   * generate circle axis cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle axis cfg\n   */\n  private getCircleAxisCfg(scale: Scale, axisOption: AxisCfg, direction: DIRECTION) {\n    const container = get(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;\n    const coordinate = this.view.getCoordinate();\n\n    const ticks = scale.getTicks().map((tick) => ({ id: `${tick.tickValue}`, name: tick.text, value: tick.value }));\n    if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {\n      // x 轴对应的值如果是非 cat 类型，在整圆的情况下坐标轴第一个和最后一个文本会重叠，默认只展示第一个文本\n      ticks.pop();\n    }\n\n    const titleText = getAxisTitleText(scale, axisOption);\n    const axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);\n    // the cfg order should be ensure\n    const optionWithTitle = get(axisOption, ['title'])\n      ? deepMix(\n          { title: { style: { text: titleText } } },\n          { title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title) },\n          axisOption\n        )\n      : axisOption;\n    const cfg = deepMix(\n      {\n        container,\n        ...getCircleAxisCenterRadius(this.view.getCoordinate()),\n        ticks,\n        verticalFactor: 1,\n        theme: axisThemeCfg,\n      },\n      axisThemeCfg,\n      optionWithTitle\n    );\n    const { animate, animateOption } = this.getAnimateCfg(cfg);\n    cfg.animate = animate;\n    cfg.animateOption = animateOption;\n\n    return cfg;\n  }\n\n  /**\n   * generate circle grid cfg\n   * @param scale\n   * @param axisOption\n   * @param direction\n   * @return circle grid cfg\n   */\n  private getCircleGridCfg(scale: Scale, axisOption: AxisCfg, direction: DIRECTION, dim: string) {\n    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {\n      return undefined;\n    }\n\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    const gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);\n    const gridCfg = deepMix(\n      {\n        container: get(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,\n        center: this.view.getCoordinate().getCenter(),\n      },\n      gridThemeCfg,\n      get(axisOption, 'grid'),\n      this.getAnimateCfg(axisOption)\n    );\n    const alignTick = get(gridCfg, 'alignTick', true);\n    const verticalScale = dim === 'x' ? this.view.getYScales()[0] : this.view.getXScale();\n    gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale, alignTick, dim);\n    // the cfg order should be ensure\n    // grid 动画以 axis 为准\n    return gridCfg;\n  }\n\n  private getId(name: string, key: string): string {\n    const coordinate = this.view.getCoordinate();\n    // 坐标系类型也作为组件的 key\n    return `${name}-${key}-${coordinate.type}`;\n  }\n\n  private getAnimateCfg(cfg) {\n    return {\n      animate: this.view.getOptions().animate && get(cfg, 'animate'), // 如果 view 关闭动画，则不执行动画\n      animateOption:\n        cfg && cfg.animateOption ? deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG,\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}