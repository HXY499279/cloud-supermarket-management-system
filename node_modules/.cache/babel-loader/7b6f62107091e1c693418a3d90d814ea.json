{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { deepMix, each, get, isArray, isNull } from '@antv/util';\nimport { doAnimate } from '../animate';\nimport { getGeometryLabelLayout } from '../geometry/label';\nimport { getlLabelBackgroundInfo } from '../geometry/label/util';\nimport { polarToCartesian } from '../util/graphics';\nimport { rotate, translate } from '../util/transform';\nimport { FIELD_ORIGIN } from '../constant';\nimport { updateLabel } from './update-label';\n/**\n * Geometry labels 渲染组件\n */\n\nvar Labels =\n/** @class */\nfunction () {\n  function Labels(cfg) {\n    /** 存储当前 shape 的映射表，键值为 shape id */\n    this.shapesMap = {};\n    this.lastShapesMap = {};\n    var layout = cfg.layout,\n        container = cfg.container;\n    this.layout = layout;\n    this.container = container;\n  }\n  /**\n   * 渲染文本\n   */\n\n\n  Labels.prototype.render = function (items, shapes, isUpdate) {\n    var _this = this;\n\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    this.shapesMap = {};\n    var container = this.container;\n    var offscreenGroup = this.createOffscreenGroup(); // 创建虚拟分组\n\n    if (items.length) {\n      // 如果 items 空的话就不进行绘制调整操作\n      // step 1: 在虚拟 group 中创建 shapes\n      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n        var item = items_1[_i];\n\n        if (item) {\n          this.renderLabel(item, offscreenGroup);\n        }\n      } // step 2: 根据布局，调整 labels\n\n\n      this.doLayout(items, shapes); // step 3.1: 绘制 labelLine\n\n      this.renderLabelLine(items); // step 3.2: 绘制 labelBackground\n\n      this.renderLabelBackground(items); // step 4: 根据用户设置的偏移量调整 label\n\n      this.adjustLabel(items);\n    } // 进行添加、更新、销毁操作\n\n\n    var lastShapesMap = this.lastShapesMap;\n    var shapesMap = this.shapesMap;\n    each(shapesMap, function (shape, id) {\n      if (shape.destroyed) {\n        // label 在布局调整环节被删除了（doLayout）\n        delete shapesMap[id];\n      } else {\n        if (lastShapesMap[id]) {\n          // 图形发生更新\n          var data = shape.get('data');\n          var origin_1 = shape.get('origin');\n          var coordinate = shape.get('coordinate');\n          var currentAnimateCfg = shape.get('animateCfg');\n          var currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape\n\n          updateLabel(currentShape, shapesMap[id], {\n            data: data,\n            origin: origin_1,\n            animateCfg: currentAnimateCfg,\n            coordinate: coordinate\n          });\n          _this.shapesMap[id] = currentShape; // 保存引用\n        } else {\n          // 新生成的 shape\n          container.add(shape);\n          var animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');\n\n          if (animateCfg) {\n            doAnimate(shape, animateCfg, {\n              toAttrs: __assign({}, shape.attr()),\n              coordinate: shape.get('coordinate')\n            });\n          }\n        }\n\n        delete lastShapesMap[id];\n      }\n    }); // 移除\n\n    each(lastShapesMap, function (deleteShape) {\n      var animateCfg = get(deleteShape.get('animateCfg'), 'leave');\n\n      if (animateCfg) {\n        doAnimate(deleteShape, animateCfg, {\n          toAttrs: null,\n          coordinate: deleteShape.get('coordinate')\n        });\n      } else {\n        deleteShape.remove(true); // 移除\n      }\n    });\n    this.lastShapesMap = shapesMap;\n    offscreenGroup.destroy();\n  };\n  /** 清除当前 labels */\n\n\n  Labels.prototype.clear = function () {\n    this.container.clear();\n    this.shapesMap = {};\n    this.lastShapesMap = {};\n  };\n  /** 销毁 */\n\n\n  Labels.prototype.destroy = function () {\n    this.container.destroy();\n    this.shapesMap = null;\n    this.lastShapesMap = null;\n  };\n\n  Labels.prototype.renderLabel = function (cfg, container) {\n    var id = cfg.id,\n        elementId = cfg.elementId,\n        data = cfg.data,\n        mappingData = cfg.mappingData,\n        coordinate = cfg.coordinate,\n        animate = cfg.animate,\n        content = cfg.content;\n    var shapeAppendCfg = {\n      id: id,\n      elementId: elementId,\n      data: data,\n      origin: __assign(__assign({}, mappingData), {\n        data: mappingData[FIELD_ORIGIN]\n      }),\n      coordinate: coordinate\n    };\n    var labelGroup = container.addGroup(__assign({\n      name: 'label',\n      // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并\n      animateCfg: this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate)\n    }, shapeAppendCfg));\n    var labelShape;\n\n    if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {\n      // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup\n      var _a = content.getCanvasBBox(),\n          width = _a.width,\n          height = _a.height;\n\n      var textAlign = get(cfg, 'textAlign', 'left');\n      var x = cfg.x;\n      var y = cfg.y - height / 2;\n\n      if (textAlign === 'center') {\n        x = x - width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        x = x - width;\n      }\n\n      translate(content, x, y); // 将 label 平移至 x, y 指定的位置\n\n      labelShape = content;\n      labelGroup.add(content);\n    } else {\n      var fill = get(cfg, ['style', 'fill']);\n      labelShape = labelGroup.addShape('text', __assign({\n        attrs: __assign(__assign({\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          textBaseline: get(cfg, 'textBaseline', 'middle'),\n          text: cfg.content\n        }, cfg.style), {\n          fill: isNull(fill) ? cfg.color : fill\n        })\n      }, shapeAppendCfg));\n    }\n\n    if (cfg.rotate) {\n      rotate(labelShape, cfg.rotate);\n    }\n\n    this.shapesMap[id] = labelGroup;\n  }; // 根据type对label布局\n\n\n  Labels.prototype.doLayout = function (items, shapes) {\n    var _this = this;\n\n    if (this.layout) {\n      var layouts = isArray(this.layout) ? this.layout : [this.layout];\n      each(layouts, function (layout) {\n        var layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));\n\n        if (layoutFn) {\n          var labelShapes_1 = [];\n          var geometryShapes_1 = [];\n          each(_this.shapesMap, function (labelShape, id) {\n            labelShapes_1.push(labelShape);\n            geometryShapes_1.push(shapes[labelShape.get('elementId')]);\n          });\n          layoutFn(items, labelShapes_1, geometryShapes_1, _this.region, layout.cfg);\n        }\n      });\n    }\n  };\n\n  Labels.prototype.renderLabelLine = function (labelItems) {\n    var _this = this;\n\n    each(labelItems, function (labelItem) {\n      var coordinate = get(labelItem, 'coordinate');\n\n      if (!labelItem || !coordinate) {\n        return;\n      }\n\n      var center = coordinate.getCenter();\n      var radius = coordinate.getRadius();\n\n      if (!labelItem.labelLine) {\n        // labelLine: null | false，关闭 label 对应的 labelLine\n        return;\n      }\n\n      var labelLineCfg = get(labelItem, 'labelLine', {});\n      var id = labelItem.id;\n      var path = labelLineCfg.path;\n\n      if (!path) {\n        var start = polarToCartesian(center.x, center.y, radius, labelItem.angle);\n        path = [['M', start.x, start.y], ['L', labelItem.x, labelItem.y]];\n      }\n\n      var labelGroup = _this.shapesMap[id];\n\n      if (!labelGroup.destroyed) {\n        labelGroup.addShape('path', {\n          capture: false,\n          attrs: __assign({\n            path: path,\n            stroke: labelItem.color ? labelItem.color : get(labelItem, ['style', 'fill'], '#000'),\n            fill: null\n          }, labelLineCfg.style),\n          id: id,\n          origin: labelItem.mappingData,\n          data: labelItem.data,\n          coordinate: labelItem.coordinate\n        });\n      }\n    });\n  };\n  /**\n   * 绘制标签背景\n   * @param labelItems\n   */\n\n\n  Labels.prototype.renderLabelBackground = function (labelItems) {\n    var _this = this;\n\n    each(labelItems, function (labelItem) {\n      var coordinate = get(labelItem, 'coordinate');\n      var background = get(labelItem, 'background');\n\n      if (!background || !coordinate) {\n        return;\n      }\n\n      var id = labelItem.id;\n      var labelGroup = _this.shapesMap[id];\n\n      if (!labelGroup.destroyed) {\n        var labelContentShape = labelGroup.getChildren()[0];\n\n        if (labelContentShape) {\n          var _a = getlLabelBackgroundInfo(labelGroup, labelItem, background.padding),\n              rotation = _a.rotation,\n              box = __rest(_a, [\"rotation\"]);\n\n          var backgroundShape = labelGroup.addShape('rect', {\n            attrs: __assign(__assign({}, box), background.style || {}),\n            id: id,\n            origin: labelItem.mappingData,\n            data: labelItem.data,\n            coordinate: labelItem.coordinate\n          });\n          backgroundShape.setZIndex(-1);\n\n          if (rotation) {\n            var matrix = labelContentShape.getMatrix();\n            backgroundShape.setMatrix(matrix);\n          }\n        }\n      }\n    });\n  };\n\n  Labels.prototype.createOffscreenGroup = function () {\n    var container = this.container;\n    var GroupClass = container.getGroupBase(); // 获取分组的构造函数\n\n    var newGroup = new GroupClass({});\n    return newGroup;\n  };\n\n  Labels.prototype.adjustLabel = function (items) {\n    var _this = this;\n\n    each(items, function (item) {\n      if (item) {\n        var id = item.id;\n        var labelGroup = _this.shapesMap[id];\n\n        if (!labelGroup.destroyed) {\n          // fix: 如果说开发者的 label content 是一个 group，此处的偏移无法对 整个 content group 生效；场景类似 饼图 spider label 是一个含 2 个 textShape 的 gorup\n          var labelShapes = labelGroup.findAll(function (ele) {\n            return ele.get('type') !== 'path';\n          });\n          each(labelShapes, function (labelShape) {\n            if (labelShape) {\n              if (item.offsetX) {\n                labelShape.attr('x', labelShape.attr('x') + item.offsetX);\n              }\n\n              if (item.offsetY) {\n                labelShape.attr('y', labelShape.attr('y') + item.offsetY);\n              }\n            }\n          });\n        }\n      }\n    });\n  };\n\n  return Labels;\n}();\n\nexport default Labels;","map":{"version":3,"sources":["../../src/component/labels.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepMix, each, get, isArray, isNull } from '@antv/util';\nimport { BBox, Coordinate, IGroup, IShape } from '../dependents';\nimport { LabelItem } from '../geometry/label/interface';\nimport { AnimateOption, GeometryLabelLayoutCfg } from '../interface';\nimport { doAnimate } from '../animate';\nimport { getGeometryLabelLayout } from '../geometry/label';\nimport { getlLabelBackgroundInfo } from '../geometry/label/util';\nimport { polarToCartesian } from '../util/graphics';\nimport { rotate, translate } from '../util/transform';\nimport { FIELD_ORIGIN } from '../constant';\nimport { updateLabel } from './update-label';\n\n/**\n * Labels 实例创建时，传入构造函数的参数定义\n */\nexport interface LabelsGroupCfg {\n  /** label 容器 */\n  container: IGroup;\n  /** label 布局配置 */\n  layout?: GeometryLabelLayoutCfg | GeometryLabelLayoutCfg[];\n}\n\n/**\n * Geometry labels 渲染组件\n */\nexport default class Labels {\n  /** 用于指定 labels 布局的类型 */\n  public layout: GeometryLabelLayoutCfg | GeometryLabelLayoutCfg[];\n  /** 图形容器 */\n  public container: IGroup;\n  /** 动画配置 */\n  public animate: AnimateOption | false;\n  /** label 绘制的区域 */\n  public region: BBox;\n\n  /** 存储当前 shape 的映射表，键值为 shape id */\n  public shapesMap: Record<string, IGroup> = {};\n  private lastShapesMap: Record<string, IGroup> = {};\n\n  constructor(cfg: LabelsGroupCfg) {\n    const { layout, container } = cfg;\n\n    this.layout = layout;\n    this.container = container;\n  }\n\n  /**\n   * 渲染文本\n   */\n  public render(items: LabelItem[], shapes: Record<string, IShape | IGroup>, isUpdate: boolean = false) {\n    this.shapesMap = {};\n    const container = this.container;\n    const offscreenGroup = this.createOffscreenGroup(); // 创建虚拟分组\n    if (items.length) {\n      // 如果 items 空的话就不进行绘制调整操作\n      // step 1: 在虚拟 group 中创建 shapes\n      for (const item of items) {\n        if (item) {\n          this.renderLabel(item, offscreenGroup);\n        }\n      }\n      // step 2: 根据布局，调整 labels\n      this.doLayout(items, shapes);\n      // step 3.1: 绘制 labelLine\n      this.renderLabelLine(items);\n      // step 3.2: 绘制 labelBackground\n      this.renderLabelBackground(items);\n      // step 4: 根据用户设置的偏移量调整 label\n      this.adjustLabel(items);\n    }\n\n    // 进行添加、更新、销毁操作\n    const lastShapesMap = this.lastShapesMap;\n    const shapesMap = this.shapesMap;\n    each(shapesMap, (shape, id) => {\n      if (shape.destroyed) {\n        // label 在布局调整环节被删除了（doLayout）\n        delete shapesMap[id];\n      } else {\n        if (lastShapesMap[id]) {\n          // 图形发生更新\n          const data = shape.get('data');\n          const origin = shape.get('origin');\n          const coordinate = shape.get('coordinate');\n          const currentAnimateCfg = shape.get('animateCfg');\n\n          const currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape\n          updateLabel(currentShape, shapesMap[id], {\n            data,\n            origin,\n            animateCfg: currentAnimateCfg,\n            coordinate,\n          });\n\n          this.shapesMap[id] = currentShape; // 保存引用\n        } else {\n          // 新生成的 shape\n          container.add(shape);\n\n          const animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');\n          if (animateCfg) {\n            doAnimate(shape, animateCfg, {\n              toAttrs: {\n                ...shape.attr(),\n              },\n              coordinate: shape.get('coordinate'),\n            });\n          }\n        }\n        delete lastShapesMap[id];\n      }\n    });\n\n    // 移除\n    each(lastShapesMap, (deleteShape) => {\n      const animateCfg = get(deleteShape.get('animateCfg'), 'leave');\n      if (animateCfg) {\n        doAnimate(deleteShape, animateCfg, {\n          toAttrs: null,\n          coordinate: deleteShape.get('coordinate'),\n        });\n      } else {\n        deleteShape.remove(true); // 移除\n      }\n    });\n\n    this.lastShapesMap = shapesMap;\n    offscreenGroup.destroy();\n  }\n\n  /** 清除当前 labels */\n  public clear() {\n    this.container.clear();\n    this.shapesMap = {};\n    this.lastShapesMap = {};\n  }\n\n  /** 销毁 */\n  public destroy() {\n    this.container.destroy();\n    this.shapesMap = null;\n    this.lastShapesMap = null;\n  }\n\n  private renderLabel(cfg: LabelItem, container: IGroup) {\n    const { id, elementId, data, mappingData, coordinate, animate, content } = cfg;\n    const shapeAppendCfg = {\n      id,\n      elementId,\n      data,\n      origin: {\n        ...mappingData,\n        data: mappingData[FIELD_ORIGIN],\n      },\n      coordinate,\n    };\n    const labelGroup = container.addGroup({\n      name: 'label',\n      // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并\n      animateCfg:\n        this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate),\n      ...shapeAppendCfg,\n    });\n    let labelShape;\n    if ((content.isGroup && content.isGroup()) || (content.isShape && content.isShape())) {\n      // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup\n      const { width, height } = content.getCanvasBBox();\n      const textAlign = get(cfg, 'textAlign', 'left');\n\n      let x = cfg.x;\n      const y = cfg.y - height / 2;\n\n      if (textAlign === 'center') {\n        x = x - width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        x = x - width;\n      }\n\n      translate(content, x, y); // 将 label 平移至 x, y 指定的位置\n      labelShape = content;\n      labelGroup.add(content);\n    } else {\n      const fill = get(cfg, ['style', 'fill']);\n      labelShape = labelGroup.addShape('text', {\n        attrs: {\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          textBaseline: get(cfg, 'textBaseline', 'middle'),\n          text: cfg.content,\n          ...cfg.style,\n          fill: isNull(fill) ? cfg.color : fill,\n        },\n        ...shapeAppendCfg,\n      });\n    }\n\n    if (cfg.rotate) {\n      rotate(labelShape, cfg.rotate);\n    }\n    this.shapesMap[id] = labelGroup;\n  }\n\n  // 根据type对label布局\n  private doLayout(items: LabelItem[], shapes: Record<string, IShape | IGroup>) {\n    if (this.layout) {\n      const layouts = isArray(this.layout) ? this.layout : [this.layout];\n      each(layouts, (layout: GeometryLabelLayoutCfg) => {\n        const layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));\n        if (layoutFn) {\n          const labelShapes = [];\n          const geometryShapes = [];\n          each(this.shapesMap, (labelShape, id) => {\n            labelShapes.push(labelShape);\n            geometryShapes.push(shapes[labelShape.get('elementId')]);\n          });\n\n          layoutFn(items, labelShapes, geometryShapes, this.region, layout.cfg);\n        }\n      });\n    }\n  }\n\n  private renderLabelLine(labelItems: LabelItem[]) {\n    each(labelItems, (labelItem) => {\n      const coordinate: Coordinate = get(labelItem, 'coordinate');\n      if (!labelItem || !coordinate) {\n        return;\n      }\n      const center = coordinate.getCenter();\n      const radius = coordinate.getRadius();\n      if (!labelItem.labelLine) {\n        // labelLine: null | false，关闭 label 对应的 labelLine\n        return;\n      }\n      const labelLineCfg = get(labelItem, 'labelLine', {});\n      const id = labelItem.id;\n      let path = labelLineCfg.path;\n      if (!path) {\n        const start = polarToCartesian(center.x, center.y, radius, labelItem.angle);\n        path = [\n          ['M', start.x, start.y],\n          ['L', labelItem.x, labelItem.y],\n        ];\n      }\n      const labelGroup = this.shapesMap[id];\n      if (!labelGroup.destroyed) {\n        labelGroup.addShape('path', {\n          capture: false, // labelLine 默认不参与事件捕获\n          attrs: {\n            path,\n            stroke: labelItem.color ? labelItem.color : get(labelItem, ['style', 'fill'], '#000'),\n            fill: null,\n            ...labelLineCfg.style,\n          },\n          id,\n          origin: labelItem.mappingData,\n          data: labelItem.data,\n          coordinate: labelItem.coordinate,\n        });\n      }\n    });\n  }\n\n  /**\n   * 绘制标签背景\n   * @param labelItems\n   */\n  private renderLabelBackground(labelItems: LabelItem[]) {\n    each(labelItems, (labelItem) => {\n      const coordinate: Coordinate = get(labelItem, 'coordinate');\n      const background: LabelItem['background'] = get(labelItem, 'background');\n      if (!background || !coordinate) {\n        return;\n      }\n\n      const id = labelItem.id;\n      const labelGroup = this.shapesMap[id];\n      if (!labelGroup.destroyed) {\n        const labelContentShape = labelGroup.getChildren()[0];\n        if (labelContentShape) {\n          const { rotation, ...box } = getlLabelBackgroundInfo(labelGroup, labelItem, background.padding);\n          const backgroundShape = labelGroup.addShape('rect', {\n            attrs: {\n              ...box,\n              ...(background.style || {}),\n            },\n            id,\n            origin: labelItem.mappingData,\n            data: labelItem.data,\n            coordinate: labelItem.coordinate,\n          });\n          backgroundShape.setZIndex(-1);\n\n          if (rotation) {\n            const matrix = labelContentShape.getMatrix();\n            backgroundShape.setMatrix(matrix);\n          }\n        }\n      }\n    });\n  }\n\n  private createOffscreenGroup() {\n    const container = this.container;\n    const GroupClass = container.getGroupBase(); // 获取分组的构造函数\n    const newGroup = new GroupClass({});\n    return newGroup;\n  }\n\n  private adjustLabel(items: LabelItem[]) {\n    each(items, (item) => {\n      if (item) {\n        const id = item.id;\n        const labelGroup = this.shapesMap[id];\n        if (!labelGroup.destroyed) {\n          // fix: 如果说开发者的 label content 是一个 group，此处的偏移无法对 整个 content group 生效；场景类似 饼图 spider label 是一个含 2 个 textShape 的 gorup\n          const labelShapes = labelGroup.findAll((ele) => ele.get('type') !== 'path');\n          each(labelShapes, (labelShape) => {\n            if (labelShape) {\n              if (item.offsetX) {\n                labelShape.attr('x', labelShape.attr('x') + item.offsetX);\n              }\n              if (item.offsetY) {\n                labelShape.attr('y', labelShape.attr('y') + item.offsetY);\n              }\n            }\n          });\n        }\n      }\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}