{"ast":null,"code":"import { ext, vec2, vec3 } from '@antv/matrix-util';\nvar identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\nexport function getMatrixByAngle(point, angle, matrix) {\n  if (matrix === void 0) {\n    matrix = identityMatrix;\n  }\n\n  if (!angle) {\n    // 角度为 0 或者 null 时返回 null\n    return null;\n  }\n\n  var m = ext.transform(matrix, [['t', -point.x, -point.y], ['r', angle], ['t', point.x, point.y]]);\n  return m;\n}\nexport function getMatrixByTranslate(point, currentMatrix) {\n  if (!point.x && !point.y) {\n    // 0，0 或者 nan 的情况下返回 null\n    return null;\n  }\n\n  return ext.transform(currentMatrix || identityMatrix, [['t', point.x, point.y]]);\n} // 从矩阵获取旋转的角度\n\nexport function getAngleByMatrix(matrix) {\n  var xVector = [1, 0, 0];\n  var out = [0, 0, 0];\n  vec3.transformMat3(out, xVector, matrix);\n  return Math.atan2(out[1], out[0]);\n} // 矩阵 * 向量\n\nfunction multiplyVec2(matrix, v) {\n  var out = [0, 0];\n  vec2.transformMat3(out, v, matrix);\n  return out;\n}\n\nexport function applyMatrix2BBox(matrix, bbox) {\n  var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);\n  var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);\n  var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);\n  var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);\n  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n  var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n  return {\n    x: minX,\n    y: minY,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nexport function applyRotate(shape, rotate, x, y) {\n  if (rotate) {\n    var matrix = getMatrixByAngle({\n      x: x,\n      y: y\n    }, rotate, shape.getMatrix());\n    shape.setMatrix(matrix);\n  }\n}\nexport function applyTranslate(shape, x, y) {\n  var translateMatrix = getMatrixByTranslate({\n    x: x,\n    y: y\n  });\n  shape.attr('matrix', translateMatrix);\n}","map":{"version":3,"sources":["../../src/util/matrix.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ext, vec2, vec3 } from '@antv/matrix-util';\nvar identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\nexport function getMatrixByAngle(point, angle, matrix) {\n    if (matrix === void 0) { matrix = identityMatrix; }\n    if (!angle) {\n        // 角度为 0 或者 null 时返回 null\n        return null;\n    }\n    var m = ext.transform(matrix, [\n        ['t', -point.x, -point.y],\n        ['r', angle],\n        ['t', point.x, point.y],\n    ]);\n    return m;\n}\nexport function getMatrixByTranslate(point, currentMatrix) {\n    if (!point.x && !point.y) {\n        // 0，0 或者 nan 的情况下返回 null\n        return null;\n    }\n    return ext.transform(currentMatrix || identityMatrix, [['t', point.x, point.y]]);\n}\n// 从矩阵获取旋转的角度\nexport function getAngleByMatrix(matrix) {\n    var xVector = [1, 0, 0];\n    var out = [0, 0, 0];\n    vec3.transformMat3(out, xVector, matrix);\n    return Math.atan2(out[1], out[0]);\n}\n// 矩阵 * 向量\nfunction multiplyVec2(matrix, v) {\n    var out = [0, 0];\n    vec2.transformMat3(out, v, matrix);\n    return out;\n}\nexport function applyMatrix2BBox(matrix, bbox) {\n    var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);\n    var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);\n    var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);\n    var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);\n    var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n    var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n    var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n    var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n    return {\n        x: minX,\n        y: minY,\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY,\n        width: maxX - minX,\n        height: maxY - minY,\n    };\n}\nexport function applyRotate(shape, rotate, x, y) {\n    if (rotate) {\n        var matrix = getMatrixByAngle({ x: x, y: y }, rotate, shape.getMatrix());\n        shape.setMatrix(matrix);\n    }\n}\nexport function applyTranslate(shape, x, y) {\n    var translateMatrix = getMatrixByTranslate({ x: x, y: y });\n    shape.attr('matrix', translateMatrix);\n}\n//# sourceMappingURL=matrix.js.map"]},"metadata":{},"sourceType":"module"}