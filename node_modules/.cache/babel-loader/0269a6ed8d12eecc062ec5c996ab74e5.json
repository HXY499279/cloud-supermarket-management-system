{"ast":null,"code":"import { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\n/** 拐点偏移量, 暂不可配置 */\n\nvar INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\n\nvar LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\n\nvar LABEL_TEXT_LINE_OFFSET = 4;\n\nfunction drawLabelline(item, coordinate, inRight) {\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n\n  var radius = coordinate.getRadius();\n  var startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y\n  };\n  var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  var p1 = {\n    x: startPoint.x,\n    y: startPoint.y\n  };\n  var p2 = {\n    x: inflectionPoint.x,\n    y: inflectionPoint.y\n  };\n  var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  var path = ''; // 文本被调整下去了，则添加拐点连接线\n\n  if (startPoint.y !== inflectionPoint.y) {\n    var offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n    /** 是否在第一象限 */\n\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n\n\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n\n\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n\n\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n\n  path = [\"M \" + startPoint.x + \",\" + startPoint.y, \"L \" + p1.x + \",\" + p1.y, \"L \" + p2.x + \",\" + p2.y, \"L \" + inflectionPoint.x + \",\" + inflectionPoint.y, \"L \" + endPoint.x + \",\" + endPoint.y].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, {\n    path: path\n  });\n}\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\n\n\nexport function pieSpiderLabelLayout(items, labels, shapes, region) {\n  /** 坐标系 */\n  var coordinate = labels[0] && labels[0].get('coordinate');\n\n  if (!coordinate) {\n    return;\n  }\n  /** 坐标圆心 */\n\n\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n\n  var radius = coordinate.getRadius();\n  /** label shapes */\n\n  var labelsMap = {};\n\n  for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {\n    var labelShape = labels_1[_i];\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  var labelHeight = get(items[0], 'labelHeight', 14);\n  var labelOffset = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET); // step 1: adjust items to spider\n\n  each(items, function (item) {\n    var label = get(labelsMap, [item.id]);\n\n    if (!label) {\n      return;\n    }\n\n    var inRight = item.x > center.x || item.x === center.x && item.y > center.y;\n    var offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n    var totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n  var start = coordinate.start,\n      end = coordinate.end;\n  var LEFT_HALF_KEY = 'left';\n  var RIGHT_HALF_KEY = 'right'; // step 1: separate labels\n\n  var seperateLabels = groupBy(items, function (item) {\n    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;\n  }); // step2: calculate totalHeight\n\n  var totalHeight = (radius + labelOffset) * 2 + labelHeight;\n  each(seperateLabels, function (half) {\n    var halfHeight = half.length * labelHeight;\n\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n\n  var labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2\n  }; // step 3: antiCollision\n\n  each(seperateLabels, function (half, key) {\n    var maxLabelsCountForOneSide = totalHeight / labelHeight;\n\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort(function (a, b) {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n      each(half, function (labelItem, idx) {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n  var startY = labelsContainerRange.minY;\n  var endY = labelsContainerRange.maxY; // step4: applyTo labels and adjust labelLines\n\n  each(seperateLabels, function (half, key) {\n    var inRight = key === RIGHT_HALF_KEY;\n    each(half, function (item) {\n      var label = get(labelsMap, item && [item.id]);\n\n      if (!label) {\n        return;\n      } // out of range, hidden\n\n\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n\n      var labelContent = label.getChildByIndex(0);\n      var box = labelContent.getCanvasBBox();\n      var originalPos = {\n        x: inRight ? box.x : box.maxX,\n        y: box.y + box.height / 2\n        /** vertical-align: middle */\n\n      };\n      translate(labelContent, item.x - originalPos.x\n      /** 从 pos.x 移动到 item.x */\n      , item.y - originalPos.y); // adjust labelLines\n\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/geometry/label/layout/pie/spider.ts"],"names":[],"mappings":"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","sourcesContent":["import { BBox, IGroup, IShape } from '@antv/g-base';\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { LabelItem, PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\nimport { Coordinate } from '@antv/coord';\n\n/** 拐点偏移量, 暂不可配置 */\nconst INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nconst LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nconst LABEL_TEXT_LINE_OFFSET = 4;\n\nfunction drawLabelline(item: PolarLabelItem, coordinate: Coordinate, inRight: boolean) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  const startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y,\n  };\n  const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  const p1 = { x: startPoint.x, y: startPoint.y };\n  const p2 = { x: inflectionPoint.x, y: inflectionPoint.y };\n\n  const endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  let path = '';\n\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    const offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n\n  path = [\n    `M ${startPoint.x},${startPoint.y}`,\n    `L ${p1.x},${p1.y}`,\n    `L ${p2.x},${p2.y}`,\n    `L ${inflectionPoint.x},${inflectionPoint.y}`,\n    `L ${endPoint.x},${endPoint.y}`,\n  ].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, { path });\n}\n\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n\n  // step 1: adjust items to spider\n  each(items, (item) => {\n    const label = get(labelsMap, [item.id]);\n    if (!label) {\n      return;\n    }\n\n    const inRight = item.x > center.x || (item.x === center.x && item.y > center.y);\n    const offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n\n    const totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n\n  const { start, end } = coordinate;\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const seperateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  // step2: calculate totalHeight\n  let totalHeight = (radius + labelOffset) * 2 + labelHeight;\n\n  each(seperateLabels, (half: PolarLabelItem[]) => {\n    const halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2,\n  };\n\n  // step 3: antiCollision\n  each(seperateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  const startY = labelsContainerRange.minY;\n  const endY = labelsContainerRange.maxY;\n\n  // step4: applyTo labels and adjust labelLines\n  each(seperateLabels, (half, key) => {\n    const inRight = key === RIGHT_HALF_KEY;\n\n    each(half, (item) => {\n      const label: IGroup = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n\n      const labelContent = label.getChildByIndex(0);\n      const box = labelContent.getCanvasBBox();\n      const originalPos = { x: inRight ? box.x : box.maxX, y: box.y + box.height / 2 /** vertical-align: middle */ };\n\n      translate(labelContent as any, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}