{"ast":null,"code":"import { each, groupBy, uniq, map, size } from '@antv/util';\nimport { checkShapeOverlap } from '../../util';\n\nfunction filterLabel(labels) {\n  var MAX_CNT = 500; // 最多显示 500 个数据标签\n\n  var filteredLabels = [];\n  var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);\n  each(labels, function (label, idx) {\n    if (idx % pages === 0) {\n      filteredLabels.push(label);\n    } else {\n      label.set('visible', false);\n    }\n  });\n  return filteredLabels;\n}\n/**\n * 为 interval geometry 定制的数据标签重叠自动隐藏布局方法\n * @param items\n * @param labels\n * @param shapes\n */\n\n\nexport function intervalHideOverlap(items, labels, shapes) {\n  var _a;\n\n  if (shapes.length === 0) {\n    return;\n  }\n\n  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');\n  var geometry = element === null || element === void 0 ? void 0 : element.geometry;\n\n  if (!geometry || geometry.type !== 'interval') {\n    return;\n  }\n\n  var filteredLabels = filterLabel(labels);\n  var xField = geometry.getXYFields()[0];\n  var dones = [];\n  var todo = [];\n  var groupedLabels = groupBy(filteredLabels, function (label) {\n    return label.get('data')[xField];\n  });\n  var xValues = uniq(map(filteredLabels, function (label) {\n    return label.get('data')[xField];\n  }));\n  var xValue;\n  filteredLabels.forEach(function (label) {\n    label.set('visible', true);\n  });\n\n  var addCurrentGroup = function (curItems) {\n    if (curItems) {\n      if (curItems.length) {\n        // 最后一个\n        todo.push(curItems.pop());\n      }\n\n      todo.push.apply(todo, curItems);\n    }\n  };\n\n  if (size(xValues) > 0) {\n    // 第一组\n    xValue = xValues.shift();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n\n  if (size(xValues) > 0) {\n    // 最后一组\n    xValue = xValues.pop();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n\n  each(xValues.reverse(), function (val) {\n    // 其他组\n    addCurrentGroup(groupedLabels[val]);\n  });\n\n  while (todo.length > 0) {\n    var cur = todo.shift();\n\n    if (cur.get('visible')) {\n      if (checkShapeOverlap(cur, dones)) {\n        cur.set('visible', false);\n      } else {\n        dones.push(cur);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../src/geometry/label/layout/interval/hide-overlap.ts"],"names":[],"mappings":"AACA,SAAS,IAAT,EAAe,OAAf,EAAwB,IAAxB,EAA8B,GAA9B,EAAmC,IAAnC,QAAuD,YAAvD;AAIA,SAAS,iBAAT,QAAkC,YAAlC;;AAEA,SAAS,WAAT,CAAqB,MAArB,EAAgD;AAC9C,MAAM,OAAO,GAAG,GAAhB,CAD8C,CACzB;;AACrB,MAAM,cAAc,GAAG,EAAvB;AACA,MAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,KAAL,CAAW,MAAM,CAAC,MAAP,GAAgB,OAA3B,CAAT,EAA8C,CAA9C,CAAd;AACA,EAAA,IAAI,CAAC,MAAD,EAAS,UAAC,KAAD,EAAQ,GAAR,EAAW;AACtB,QAAI,GAAG,GAAG,KAAN,KAAgB,CAApB,EAAuB;AACrB,MAAA,cAAc,CAAC,IAAf,CAAoB,KAApB;AACD,KAFD,MAEO;AACL,MAAA,KAAK,CAAC,GAAN,CAAU,SAAV,EAAqB,KAArB;AACD;AACF,GANG,CAAJ;AAQA,SAAO,cAAP;AACD;AAED;;;;;AAKG;;;AACH,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAAkD,MAAlD,EAAoE,MAApE,EAA+F;;;AACnG,MAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB;AACvB;AACD;;AACD,MAAM,OAAO,GAAA,CAAA,EAAA,GAAY,MAAM,CAAC,CAAD,CAAlB,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,KAAA,CAArB,GAAqB,EAAA,CAAE,GAAF,CAAM,SAAN,CAAlC;AACA,MAAM,QAAQ,GAAa,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,QAApC;;AACA,MAAI,CAAC,QAAD,IAAa,QAAQ,CAAC,IAAT,KAAkB,UAAnC,EAA+C;AAC7C;AACD;;AAED,MAAM,cAAc,GAAG,WAAW,CAAC,MAAD,CAAlC;AACO,MAAA,MAAM,GAAI,QAAQ,CAAC,WAAT,GAAJ,CAAI,CAAV;AACP,MAAM,KAAK,GAAa,EAAxB;AACA,MAAM,IAAI,GAAa,EAAvB;AACA,MAAM,aAAa,GAAG,OAAO,CAAC,cAAD,EAAiB,UAAC,KAAD,EAAM;AAAK,WAAA,KAAK,CAAC,GAAN,CAAU,MAAV,EAAA,MAAA,CAAA;AAAyB,GAArD,CAA7B;AACA,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,cAAD,EAAiB,UAAC,KAAD,EAAc;AAAK,WAAA,KAAK,CAAC,GAAN,CAAU,MAAV,EAAA,MAAA,CAAA;AAAyB,GAA7D,CAAJ,CAApB;AACA,MAAI,MAAJ;AAEA,EAAA,cAAc,CAAC,OAAf,CAAuB,UAAC,KAAD,EAAM;AAC3B,IAAA,KAAK,CAAC,GAAN,CAAU,SAAV,EAAqB,IAArB;AACD,GAFD;;AAIA,MAAM,eAAe,GAAG,UAAC,QAAD,EAAmB;AACzC,QAAI,QAAJ,EAAc;AACZ,UAAI,QAAQ,CAAC,MAAb,EAAqB;AACnB;AACA,QAAA,IAAI,CAAC,IAAL,CAAU,QAAQ,CAAC,GAAT,EAAV;AACD;;AACD,MAAA,IAAI,CAAC,IAAL,CAAS,KAAT,CAAA,IAAA,EAAa,QAAb;AACD;AACF,GARD;;AAUA,MAAI,IAAI,CAAC,OAAD,CAAJ,GAAgB,CAApB,EAAuB;AACrB;AACA,IAAA,MAAM,GAAG,OAAO,CAAC,KAAR,EAAT;AACA,IAAA,eAAe,CAAC,aAAa,CAAC,MAAD,CAAd,CAAf;AACD;;AACD,MAAI,IAAI,CAAC,OAAD,CAAJ,GAAgB,CAApB,EAAuB;AACrB;AACA,IAAA,MAAM,GAAG,OAAO,CAAC,GAAR,EAAT;AACA,IAAA,eAAe,CAAC,aAAa,CAAC,MAAD,CAAd,CAAf;AACD;;AACD,EAAA,IAAI,CAAC,OAAO,CAAC,OAAR,EAAD,EAAoB,UAAC,GAAD,EAAI;AAC1B;AACA,IAAA,eAAe,CAAC,aAAa,CAAC,GAAD,CAAd,CAAf;AACD,GAHG,CAAJ;;AAKA,SAAO,IAAI,CAAC,MAAL,GAAc,CAArB,EAAwB;AACtB,QAAM,GAAG,GAAG,IAAI,CAAC,KAAL,EAAZ;;AACA,QAAI,GAAG,CAAC,GAAJ,CAAQ,SAAR,CAAJ,EAAwB;AACtB,UAAI,iBAAiB,CAAC,GAAD,EAAM,KAAN,CAArB,EAAmC;AACjC,QAAA,GAAG,CAAC,GAAJ,CAAQ,SAAR,EAAmB,KAAnB;AACD,OAFD,MAEO;AACL,QAAA,KAAK,CAAC,IAAN,CAAW,GAAX;AACD;AACF;AACF;AACF","sourcesContent":["import { IGroup, IShape } from '../../../../dependents';\nimport { each, groupBy, uniq, map, size, filter } from '@antv/util';\nimport Geometry from '../../../base';\nimport Element from '../../../element';\nimport { LabelItem } from '../../interface';\nimport { checkShapeOverlap } from '../../util';\n\nfunction filterLabel(labels: IShape[] | IGroup[]) {\n  const MAX_CNT = 500; // 最多显示 500 个数据标签\n  const filteredLabels = [];\n  const pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);\n  each(labels, (label, idx) => {\n    if (idx % pages === 0) {\n      filteredLabels.push(label);\n    } else {\n      label.set('visible', false);\n    }\n  });\n\n  return filteredLabels;\n}\n\n/**\n * 为 interval geometry 定制的数据标签重叠自动隐藏布局方法\n * @param items\n * @param labels\n * @param shapes\n */\nexport function intervalHideOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[]) {\n  if (shapes.length === 0) {\n    return;\n  }\n  const element: Element = shapes[0]?.get('element');\n  const geometry: Geometry = element?.geometry;\n  if (!geometry || geometry.type !== 'interval') {\n    return;\n  }\n\n  const filteredLabels = filterLabel(labels);\n  const [xField] = geometry.getXYFields();\n  const dones: IShape[] = [];\n  const todo: IShape[] = [];\n  const groupedLabels = groupBy(filteredLabels, (label) => label.get('data')[xField]);\n  const xValues = uniq(map(filteredLabels, (label: IShape) => label.get('data')[xField]));\n  let xValue;\n\n  filteredLabels.forEach((label) => {\n    label.set('visible', true);\n  });\n\n  const addCurrentGroup = (curItems: IShape[]) => {\n    if (curItems) {\n      if (curItems.length) {\n        // 最后一个\n        todo.push(curItems.pop());\n      }\n      todo.push(...curItems);\n    }\n  };\n\n  if (size(xValues) > 0) {\n    // 第一组\n    xValue = xValues.shift();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n  if (size(xValues) > 0) {\n    // 最后一组\n    xValue = xValues.pop();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n  each(xValues.reverse(), (val) => {\n    // 其他组\n    addCurrentGroup(groupedLabels[val]);\n  });\n\n  while (todo.length > 0) {\n    const cur = todo.shift();\n    if (cur.get('visible')) {\n      if (checkShapeOverlap(cur, dones)) {\n        cur.set('visible', false);\n      } else {\n        dones.push(cur);\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}