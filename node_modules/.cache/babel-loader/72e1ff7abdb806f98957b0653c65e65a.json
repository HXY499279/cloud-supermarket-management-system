{"ast":null,"code":"import getArcParams from './get-arc-params';\nimport { isSamePoint } from './get-arc-params';\nimport parsePath from './parse-path'; // 点对称\n\nfunction toSymmetry(point, center) {\n  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];\n}\n\nexport default function getSegments(path) {\n  path = parsePath(path);\n  var segments = [];\n  var currentPoint = null; // 当前图形\n\n  var nextParams = null; // 下一节点的 path 参数\n\n  var startMovePoint = null; // 开始 M 的点，可能会有多个\n\n  var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n\n  var count = path.length;\n\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    nextParams = path[i + 1];\n    var command = params[0]; // 数学定义上的参数，便于后面的计算\n\n    var segment = {\n      command: command,\n      prePoint: currentPoint,\n      params: params,\n      startTangent: null,\n      endTangent: null\n    };\n\n    switch (command) {\n      case 'M':\n        startMovePoint = [params[1], params[2]];\n        lastStartMovePointIndex = i;\n        break;\n\n      case 'A':\n        var arcParams = getArcParams(currentPoint, params);\n        segment['arcParams'] = arcParams;\n        break;\n\n      default:\n        break;\n    }\n\n    if (command === 'Z') {\n      // 有了 Z 后，当前节点从开始 M 的点开始\n      currentPoint = startMovePoint; // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n\n      nextParams = path[lastStartMovePointIndex + 1];\n    } else {\n      var len = params.length;\n      currentPoint = [params[len - 2], params[len - 1]];\n    }\n\n    if (nextParams && nextParams[0] === 'Z') {\n      // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n      nextParams = path[lastStartMovePointIndex];\n\n      if (segments[lastStartMovePointIndex]) {\n        // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n        segments[lastStartMovePointIndex].prePoint = currentPoint;\n      }\n    }\n\n    segment['currentPoint'] = currentPoint; // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n\n    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {\n      segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n    }\n\n    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;\n    segment['nextPoint'] = nextPoint; // Add startTangent and endTangent\n\n    var prePoint = segment.prePoint;\n\n    if (['L', 'H', 'V'].includes(command)) {\n      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n    } else if (command === 'Q') {\n      // 二次贝塞尔曲线只有一个控制点\n      var cp = [params[1], params[2]]; // 二次贝塞尔曲线的终点为 currentPoint\n\n      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n    } else if (command === 'T') {\n      var preSegment = segments[i - 1];\n      var cp = toSymmetry(preSegment.currentPoint, prePoint);\n\n      if (preSegment.command === 'Q') {\n        segment.command = 'Q';\n        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n      } else {\n        segment.command = 'TL';\n        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n      }\n    } else if (command === 'C') {\n      // 三次贝塞尔曲线有两个控制点\n      var cp1 = [params[1], params[2]];\n      var cp2 = [params[3], params[4]];\n      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n    } else if (command === 'S') {\n      var preSegment = segments[i - 1];\n      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);\n      var cp2 = [params[1], params[2]];\n\n      if (preSegment.command === 'C') {\n        segment.command = 'C'; // 将 S 命令变换为 C 命令\n\n        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      } else {\n        segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\n\n        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];\n        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      }\n    } else if (command === 'A') {\n      var d = 0.001;\n\n      var _a = segment['arcParams'] || {},\n          _b = _a.cx,\n          cx = _b === void 0 ? 0 : _b,\n          _c = _a.cy,\n          cy = _c === void 0 ? 0 : _c,\n          _d = _a.rx,\n          rx = _d === void 0 ? 0 : _d,\n          _e = _a.ry,\n          ry = _e === void 0 ? 0 : _e,\n          _f = _a.sweepFlag,\n          sweepFlag = _f === void 0 ? 0 : _f,\n          _g = _a.startAngle,\n          startAngle = _g === void 0 ? 0 : _g,\n          _h = _a.endAngle,\n          endAngle = _h === void 0 ? 0 : _h;\n\n      if (sweepFlag === 0) {\n        d *= -1;\n      }\n\n      var dx1 = rx * Math.cos(startAngle - d) + cx;\n      var dy1 = ry * Math.sin(startAngle - d) + cy;\n      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];\n      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\n      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\n      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];\n    }\n\n    segments.push(segment);\n  }\n\n  return segments;\n}","map":{"version":3,"sources":["../src/path-2-segments.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import getArcParams from './get-arc-params';\nimport { isSamePoint } from './get-arc-params';\nimport parsePath from './parse-path';\n// 点对称\nfunction toSymmetry(point, center) {\n    return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];\n}\nexport default function getSegments(path) {\n    path = parsePath(path);\n    var segments = [];\n    var currentPoint = null; // 当前图形\n    var nextParams = null; // 下一节点的 path 参数\n    var startMovePoint = null; // 开始 M 的点，可能会有多个\n    var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n    var count = path.length;\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        nextParams = path[i + 1];\n        var command = params[0];\n        // 数学定义上的参数，便于后面的计算\n        var segment = {\n            command: command,\n            prePoint: currentPoint,\n            params: params,\n            startTangent: null,\n            endTangent: null,\n        };\n        switch (command) {\n            case 'M':\n                startMovePoint = [params[1], params[2]];\n                lastStartMovePointIndex = i;\n                break;\n            case 'A':\n                var arcParams = getArcParams(currentPoint, params);\n                segment['arcParams'] = arcParams;\n                break;\n            default:\n                break;\n        }\n        if (command === 'Z') {\n            // 有了 Z 后，当前节点从开始 M 的点开始\n            currentPoint = startMovePoint;\n            // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n            nextParams = path[lastStartMovePointIndex + 1];\n        }\n        else {\n            var len = params.length;\n            currentPoint = [params[len - 2], params[len - 1]];\n        }\n        if (nextParams && nextParams[0] === 'Z') {\n            // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n            nextParams = path[lastStartMovePointIndex];\n            if (segments[lastStartMovePointIndex]) {\n                // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n                segments[lastStartMovePointIndex].prePoint = currentPoint;\n            }\n        }\n        segment['currentPoint'] = currentPoint;\n        // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n        if (segments[lastStartMovePointIndex] &&\n            isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {\n            segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n        }\n        var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;\n        segment['nextPoint'] = nextPoint;\n        // Add startTangent and endTangent\n        var prePoint = segment.prePoint;\n        if (['L', 'H', 'V'].includes(command)) {\n            segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n            segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n        }\n        else if (command === 'Q') {\n            // 二次贝塞尔曲线只有一个控制点\n            var cp = [params[1], params[2]];\n            // 二次贝塞尔曲线的终点为 currentPoint\n            segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n            segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n        }\n        else if (command === 'T') {\n            var preSegment = segments[i - 1];\n            var cp = toSymmetry(preSegment.currentPoint, prePoint);\n            if (preSegment.command === 'Q') {\n                segment.command = 'Q';\n                segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n                segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n            }\n            else {\n                segment.command = 'TL';\n                segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n                segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n            }\n        }\n        else if (command === 'C') {\n            // 三次贝塞尔曲线有两个控制点\n            var cp1 = [params[1], params[2]];\n            var cp2 = [params[3], params[4]];\n            segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n            segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n        }\n        else if (command === 'S') {\n            var preSegment = segments[i - 1];\n            var cp1 = toSymmetry(preSegment.currentPoint, prePoint);\n            var cp2 = [params[1], params[2]];\n            if (preSegment.command === 'C') {\n                segment.command = 'C'; // 将 S 命令变换为 C 命令\n                segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n                segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n            }\n            else {\n                segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\n                segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];\n                segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n            }\n        }\n        else if (command === 'A') {\n            var d = 0.001;\n            var _a = segment['arcParams'] || {}, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, _d = _a.rx, rx = _d === void 0 ? 0 : _d, _e = _a.ry, ry = _e === void 0 ? 0 : _e, _f = _a.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a.endAngle, endAngle = _h === void 0 ? 0 : _h;\n            if (sweepFlag === 0) {\n                d *= -1;\n            }\n            var dx1 = rx * Math.cos(startAngle - d) + cx;\n            var dy1 = ry * Math.sin(startAngle - d) + cy;\n            segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];\n            var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\n            var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\n            segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];\n        }\n        segments.push(segment);\n    }\n    return segments;\n}\n//# sourceMappingURL=path-2-segments.js.map"]},"metadata":{},"sourceType":"module"}