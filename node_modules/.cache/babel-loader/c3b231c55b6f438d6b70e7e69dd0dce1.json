{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { each, head, last } from '@antv/util';\nimport Continuous from './base';\n/**\n * 分段度量\n */\n\nvar Quantize =\n/** @class */\nfunction (_super) {\n  __extends(Quantize, _super);\n\n  function Quantize() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'quantize';\n    return _this;\n  }\n\n  Quantize.prototype.invert = function (value) {\n    var ticks = this.ticks;\n    var length = ticks.length;\n    var percent = this.getInvertPercent(value);\n    var minIndex = Math.floor(percent * (length - 1)); // 最后一个\n\n    if (minIndex >= length - 1) {\n      return last(ticks);\n    } // 超出左边界， 则取第一个\n\n\n    if (minIndex < 0) {\n      return head(ticks);\n    }\n\n    var minTick = ticks[minIndex];\n    var nextTick = ticks[minIndex + 1]; // 比当前值小的 tick 在度量上的占比\n\n    var minIndexPercent = minIndex / (length - 1);\n    var maxIndexPercent = (minIndex + 1) / (length - 1);\n    return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);\n  };\n\n  Quantize.prototype.initCfg = function () {\n    this.tickMethod = 'r-pretty';\n    this.tickCount = 5;\n    this.nice = true;\n  };\n\n  Quantize.prototype.calculateTicks = function () {\n    var ticks = _super.prototype.calculateTicks.call(this);\n\n    if (!this.nice) {\n      // 如果 nice = false ,补充 min, max\n      if (last(ticks) !== this.max) {\n        ticks.push(this.max);\n      }\n\n      if (head(ticks) !== this.min) {\n        ticks.unshift(this.min);\n      }\n    }\n\n    return ticks;\n  }; // 计算当前值在刻度中的占比\n\n\n  Quantize.prototype.getScalePercent = function (value) {\n    var ticks = this.ticks; // 超出左边界\n\n    if (value < head(ticks)) {\n      return 0;\n    } // 超出右边界\n\n\n    if (value > last(ticks)) {\n      return 1;\n    }\n\n    var minIndex = 0;\n    each(ticks, function (tick, index) {\n      if (value >= tick) {\n        minIndex = index;\n      } else {\n        return false;\n      }\n    });\n    return minIndex / (ticks.length - 1);\n  };\n\n  return Quantize;\n}(Continuous);\n\nexport default Quantize;","map":{"version":3,"sources":["../../src/continuous/quantize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { each, head, last } from '@antv/util';\nimport Continuous from './base';\n/**\n * 分段度量\n */\nvar Quantize = /** @class */ (function (_super) {\n    __extends(Quantize, _super);\n    function Quantize() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'quantize';\n        return _this;\n    }\n    Quantize.prototype.invert = function (value) {\n        var ticks = this.ticks;\n        var length = ticks.length;\n        var percent = this.getInvertPercent(value);\n        var minIndex = Math.floor(percent * (length - 1));\n        // 最后一个\n        if (minIndex >= length - 1) {\n            return last(ticks);\n        }\n        // 超出左边界， 则取第一个\n        if (minIndex < 0) {\n            return head(ticks);\n        }\n        var minTick = ticks[minIndex];\n        var nextTick = ticks[minIndex + 1];\n        // 比当前值小的 tick 在度量上的占比\n        var minIndexPercent = minIndex / (length - 1);\n        var maxIndexPercent = (minIndex + 1) / (length - 1);\n        return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);\n    };\n    Quantize.prototype.initCfg = function () {\n        this.tickMethod = 'r-pretty';\n        this.tickCount = 5;\n        this.nice = true;\n    };\n    Quantize.prototype.calculateTicks = function () {\n        var ticks = _super.prototype.calculateTicks.call(this);\n        if (!this.nice) { // 如果 nice = false ,补充 min, max\n            if (last(ticks) !== this.max) {\n                ticks.push(this.max);\n            }\n            if (head(ticks) !== this.min) {\n                ticks.unshift(this.min);\n            }\n        }\n        return ticks;\n    };\n    // 计算当前值在刻度中的占比\n    Quantize.prototype.getScalePercent = function (value) {\n        var ticks = this.ticks;\n        // 超出左边界\n        if (value < head(ticks)) {\n            return 0;\n        }\n        // 超出右边界\n        if (value > last(ticks)) {\n            return 1;\n        }\n        var minIndex = 0;\n        each(ticks, function (tick, index) {\n            if (value >= tick) {\n                minIndex = index;\n            }\n            else {\n                return false;\n            }\n        });\n        return minIndex / (ticks.length - 1);\n    };\n    return Quantize;\n}(Continuous));\nexport default Quantize;\n//# sourceMappingURL=quantize.js.map"]},"metadata":{},"sourceType":"module"}