{"ast":null,"code":"import { each, isArray } from '@antv/util';\nimport { catmullRom2bezier, getLinePath } from '../../geometry/shape/util/path';\nimport { toPoints } from '../../util/bbox';\nimport { isPolygonsIntersect } from '@antv/path-util';\n\nfunction getMaskBBox(context, tolerance) {\n  var event = context.event;\n  var maskShape = event.target;\n  var maskBBox = maskShape.getCanvasBBox(); // 如果 bbox 过小则不返回\n\n  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {\n    return null;\n  }\n\n  return maskBBox;\n}\n\nfunction getMaskPath(context, tolerance) {\n  var event = context.event;\n  var maskShape = event.target;\n  var maskBBox = maskShape.getCanvasBBox(); // 如果 bbox 过小则不返回\n\n  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {\n    return null;\n  }\n\n  return maskShape.attr('path');\n}\n/**\n * 获取当前事件相关的图表元素\n * @param context 交互的上下文\n * @ignore\n */\n\n\nexport function getCurrentElement(context) {\n  var event = context.event;\n  var element;\n  var target = event.target;\n\n  if (target) {\n    element = target.get('element');\n  }\n\n  return element;\n}\n/**\n * 获取委托对象\n * @param context 上下文\n * @ignore\n */\n\nexport function getDelegationObject(context) {\n  var event = context.event;\n  var target = event.target;\n  var delegateObject;\n\n  if (target) {\n    delegateObject = target.get('delegateObject');\n  }\n\n  return delegateObject;\n}\nexport function isElementChange(context) {\n  var event = context.event.gEvent; // 在同一个 element 内部移动，label 和 shape 之间\n\n  if (event && event.fromShape && event.toShape && event.fromShape.get('element') === event.toShape.get('element')) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * 是否是列表组件\n * @param delegateObject 委托对象\n * @ignore\n */\n\nexport function isList(delegateObject) {\n  return delegateObject && delegateObject.component && delegateObject.component.isList();\n}\n/**\n * 是否是滑块组件\n * @param delegateObject 委托对象\n * @ignore\n */\n\nexport function isSlider(delegateObject) {\n  return delegateObject && delegateObject.component && delegateObject.component.isSlider();\n}\n/**\n * 是否由 mask 触发\n * @param context 上下文\n * @ignore\n */\n\nexport function isMask(context) {\n  var event = context.event;\n  var target = event.target;\n  return target && target.get('name') === 'mask';\n}\n/**\n * 获取被遮挡的 elements\n * @param context 上下文\n * @ignore\n */\n\nexport function getMaskedElements(context, tolerance) {\n  var target = context.event.target;\n\n  if (target.get('type') === 'path') {\n    var maskPath = getMaskPath(context, tolerance);\n\n    if (!maskPath) {\n      return;\n    }\n\n    return getElementsByPath(context.view, maskPath);\n  }\n\n  var maskBBox = getMaskBBox(context, tolerance); // 如果 bbox 过小则不返回\n\n  if (!maskBBox) {\n    return null;\n  }\n\n  return getIntersectElements(context.view, maskBBox);\n}\n/**\n * @ignore\n */\n\nexport function getSiblingMaskElements(context, sibling, tolerance) {\n  var maskBBox = getMaskBBox(context, tolerance); // 如果 bbox 过小则不返回\n\n  if (!maskBBox) {\n    return null;\n  }\n\n  var view = context.view;\n  var start = getSiblingPoint(view, sibling, {\n    x: maskBBox.x,\n    y: maskBBox.y\n  });\n  var end = getSiblingPoint(view, sibling, {\n    x: maskBBox.maxX,\n    y: maskBBox.maxY\n  });\n  var box = {\n    minX: start.x,\n    minY: start.y,\n    maxX: end.x,\n    maxY: end.y\n  };\n  return getIntersectElements(sibling, box);\n}\n/**\n * 获取所有的图表元素\n * @param view View/Chart\n * @ignore\n */\n\nexport function getElements(view) {\n  var geometries = view.geometries;\n  var rst = [];\n  each(geometries, function (geom) {\n    var elements = geom.elements;\n    rst = rst.concat(elements);\n  });\n\n  if (view.views && view.views.length) {\n    each(view.views, function (subView) {\n      rst = rst.concat(getElements(subView));\n    });\n  }\n\n  return rst;\n}\n/**\n * 获取所有的图表元素\n * @param view View/Chart\n * @param field 字段名\n * @param value 字段值\n * @ignore\n */\n\nexport function getElementsByField(view, field, value) {\n  var elements = getElements(view);\n  return elements.filter(function (el) {\n    return getElementValue(el, field) === value;\n  });\n}\n/**\n * 根据状态名获取图表元素\n * @param view View/Chart\n * @param stateName 状态名\n * @ignore\n */\n\nexport function getElementsByState(view, stateName) {\n  var geometries = view.geometries;\n  var rst = [];\n  each(geometries, function (geom) {\n    var elements = geom.getElementsBy(function (el) {\n      return el.hasState(stateName);\n    });\n    rst = rst.concat(elements);\n  });\n  return rst;\n}\n/**\n * 获取图表元素对应字段的值\n * @param element 图表元素\n * @param field 字段名\n * @ignore\n */\n\nexport function getElementValue(element, field) {\n  var model = element.getModel();\n  var record = model.data;\n  var value;\n\n  if (isArray(record)) {\n    value = record[0][field];\n  } else {\n    value = record[field];\n  }\n\n  return value;\n}\n/**\n * 两个包围盒是否相交\n * @param box1 包围盒1\n * @param box2 包围盒2\n * @ignore\n */\n\nexport function intersectRect(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\n/**\n * 获取包围盒内的图表元素\n * @param view View/Chart\n * @param box 包围盒\n * @ignore\n */\n\nexport function getIntersectElements(view, box) {\n  var elements = getElements(view);\n  var rst = [];\n  each(elements, function (el) {\n    var shape = el.shape;\n    var shapeBBox = shape.getCanvasBBox();\n\n    if (intersectRect(box, shapeBBox)) {\n      rst.push(el);\n    }\n  });\n  return rst;\n}\n\nfunction pathToPoints(path) {\n  var points = [];\n  each(path, function (seg) {\n    var command = seg[0];\n\n    if (command !== 'A') {\n      for (var i = 1; i < seg.length; i = i + 2) {\n        points.push([seg[i], seg[i + 1]]);\n      }\n    } else {\n      var length_1 = seg.length;\n      points.push([seg[length_1 - 2], seg[length_1 - 1]]);\n    }\n  });\n  return points;\n}\n/**\n * 获取包围盒内的图表元素\n * @param view View/Chart\n * @param path 路径\n * @ignore\n */\n\n\nexport function getElementsByPath(view, path) {\n  var elements = getElements(view);\n  var points = pathToPoints(path);\n  var rst = elements.filter(function (el) {\n    var shape = el.shape;\n    var shapePoints;\n\n    if (shape.get('type') === 'path') {\n      shapePoints = pathToPoints(shape.attr('path'));\n    } else {\n      var shapeBBox = shape.getCanvasBBox();\n      shapePoints = toPoints(shapeBBox);\n    }\n\n    return isPolygonsIntersect(points, shapePoints);\n  });\n  return rst;\n}\n/**\n * 获取当前 View 的所有组件\n * @param view View/Chart\n * @ignore\n */\n\nexport function getComponents(view) {\n  return view.getComponents().map(function (co) {\n    return co.component;\n  });\n}\n/** @ignore */\n\nexport function distance(p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n/** @ignore */\n\nexport function getSpline(points, z) {\n  if (points.length <= 2) {\n    return getLinePath(points, false);\n  }\n\n  var first = points[0];\n  var arr = [];\n  each(points, function (point) {\n    arr.push(point.x);\n    arr.push(point.y);\n  });\n  var path = catmullRom2bezier(arr, z, null);\n  path.unshift(['M', first.x, first.y]);\n  return path;\n}\n/**\n * 检测点是否在包围盒内\n * @param box 包围盒\n * @param point 点\n * @ignore\n */\n\nexport function isInBox(box, point) {\n  return box.x <= point.x && box.maxX >= point.x && box.y <= point.y && box.maxY > point.y;\n}\n/**\n * 获取同 view 同一级的 views\n * @param view 当前 view\n * @returns 同一级的 views\n * @ignore\n */\n\nexport function getSilbings(view) {\n  var parent = view.parent;\n  var siblings = null;\n\n  if (parent) {\n    siblings = parent.views.filter(function (sub) {\n      return sub !== view;\n    });\n  }\n\n  return siblings;\n}\n\nfunction point2Normalize(view, point) {\n  var coord = view.getCoordinate();\n  return coord.invert(point);\n}\n/**\n * 将 view 上的一点转换成另一个 view 的点\n * @param view 当前的 view\n * @param sibling 同一层级的 view\n * @param point 指定点\n * @ignore\n */\n\n\nexport function getSiblingPoint(view, sibling, point) {\n  var normalPoint = point2Normalize(view, point);\n  return sibling.getCoordinate().convert(normalPoint);\n}\n/**\n * 是否在记录中，临时因为所有的 view 中的数据不是引用，而使用的方法\n * 不同 view 上对数据的引用不相等，导致无法直接用 includes\n * 假设 x, y 值相等时是同一条数据，这个假设不完全正确，而改成 isEqual 则成本太高\n * 后面改成同一个引用时可以修改回来\n * @param records\n * @param record\n * @param xFiled\n * @param yField\n * @returns\n * @ignore\n */\n\nexport function isInRecords(records, record, xFiled, yField) {\n  var isIn = false;\n  each(records, function (r) {\n    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {\n      isIn = true;\n      return false;\n    }\n  });\n  return isIn;\n} // 级联获取 field 对应的 scale，如果 view 上没有，遍历子 view\n\nexport function getScaleByField(view, field) {\n  var scale = view.getScaleByField(field);\n\n  if (!scale && view.views) {\n    each(view.views, function (subView) {\n      scale = getScaleByField(subView, field);\n\n      if (scale) {\n        return false; // 终止循环\n      }\n    });\n  }\n\n  return scale;\n}","map":{"version":3,"sources":["../../../src/interaction/action/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { each, isArray } from '@antv/util';\nimport { View } from '../../chart';\nimport { BBox, PathCommand, Point } from '../../dependents';\nimport Geometry from '../../geometry/base';\nimport Element from '../../geometry/element/';\nimport { catmullRom2bezier, getLinePath } from '../../geometry/shape/util/path';\nimport { toPoints } from '../../util/bbox';\nimport { isPolygonsIntersect } from '@antv/path-util';\nimport { ComponentOption, IInteractionContext, LooseObject } from '../../interface';\n\nfunction getMaskBBox(context: IInteractionContext, tolerance: number) {\n  const event = context.event;\n  const maskShape = event.target;\n  const maskBBox = maskShape.getCanvasBBox();\n  // 如果 bbox 过小则不返回\n  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {\n    return null;\n  }\n  return maskBBox;\n}\n\nfunction getMaskPath(context: IInteractionContext, tolerance: number) {\n  const event = context.event;\n  const maskShape = event.target;\n  const maskBBox = maskShape.getCanvasBBox();\n  // 如果 bbox 过小则不返回\n  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {\n    return null;\n  }\n  return maskShape.attr('path');\n}\n\n/**\n * 获取当前事件相关的图表元素\n * @param context 交互的上下文\n * @ignore\n */\nexport function getCurrentElement(context: IInteractionContext): Element {\n  const event = context.event;\n  let element;\n  const target = event.target;\n  if (target) {\n    element = target.get('element');\n  }\n  return element;\n}\n\n/**\n * 获取委托对象\n * @param context 上下文\n * @ignore\n */\nexport function getDelegationObject(context: IInteractionContext): LooseObject {\n  const event = context.event;\n  const target = event.target;\n  let delegateObject;\n  if (target) {\n    delegateObject = target.get('delegateObject');\n  }\n  return delegateObject;\n}\n\nexport function isElementChange(context: IInteractionContext) {\n  const event = context.event.gEvent;\n  // 在同一个 element 内部移动，label 和 shape 之间\n  if (event && event.fromShape && event.toShape && event.fromShape.get('element') === event.toShape.get('element')) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * 是否是列表组件\n * @param delegateObject 委托对象\n * @ignore\n */\nexport function isList(delegateObject: LooseObject): boolean {\n  return delegateObject && delegateObject.component && delegateObject.component.isList();\n}\n\n/**\n * 是否是滑块组件\n * @param delegateObject 委托对象\n * @ignore\n */\nexport function isSlider(delegateObject: LooseObject): boolean {\n  return delegateObject && delegateObject.component && delegateObject.component.isSlider();\n}\n\n/**\n * 是否由 mask 触发\n * @param context 上下文\n * @ignore\n */\nexport function isMask(context: IInteractionContext): boolean {\n  const event = context.event;\n  const target = event.target;\n  return target && target.get('name') === 'mask';\n}\n\n/**\n * 获取被遮挡的 elements\n * @param context 上下文\n * @ignore\n */\nexport function getMaskedElements(context: IInteractionContext, tolerance: number): Element[] {\n  const target = context.event.target;\n  if (target.get('type') === 'path') {\n    const maskPath = getMaskPath(context, tolerance);\n    if (!maskPath) {\n      return;\n    }\n    return getElementsByPath(context.view, maskPath);\n  }\n  const maskBBox = getMaskBBox(context, tolerance);\n  // 如果 bbox 过小则不返回\n  if (!maskBBox) {\n    return null;\n  }\n  return getIntersectElements(context.view, maskBBox);\n}\n\n/**\n * @ignore\n */\nexport function getSiblingMaskElements(context: IInteractionContext, sibling: View, tolerance: number) {\n  const maskBBox = getMaskBBox(context, tolerance);\n  // 如果 bbox 过小则不返回\n  if (!maskBBox) {\n    return null;\n  }\n  const view = context.view;\n  const start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });\n  const end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });\n  const box = {\n    minX: start.x,\n    minY: start.y,\n    maxX: end.x,\n    maxY: end.y,\n  };\n  return getIntersectElements(sibling, box);\n}\n\n/**\n * 获取所有的图表元素\n * @param view View/Chart\n * @ignore\n */\nexport function getElements(view: View): Element[] {\n  const geometries = view.geometries;\n  let rst: Element[] = [];\n  each(geometries, (geom: Geometry) => {\n    const elements = geom.elements;\n    rst = rst.concat(elements);\n  });\n  if (view.views && view.views.length) {\n    each(view.views, (subView) => {\n      rst = rst.concat(getElements(subView));\n    });\n  }\n  return rst;\n}\n\n/**\n * 获取所有的图表元素\n * @param view View/Chart\n * @param field 字段名\n * @param value 字段值\n * @ignore\n */\nexport function getElementsByField(view: View, field: string, value: any) {\n  const elements = getElements(view);\n  return elements.filter((el) => {\n    return getElementValue(el, field) === value;\n  });\n}\n\n/**\n * 根据状态名获取图表元素\n * @param view View/Chart\n * @param stateName 状态名\n * @ignore\n */\nexport function getElementsByState(view: View, stateName: string): Element[] {\n  const geometries = view.geometries;\n  let rst: Element[] = [];\n  each(geometries, (geom: Geometry) => {\n    const elements = geom.getElementsBy((el) => el.hasState(stateName));\n    rst = rst.concat(elements);\n  });\n  return rst;\n}\n\n/**\n * 获取图表元素对应字段的值\n * @param element 图表元素\n * @param field 字段名\n * @ignore\n */\nexport function getElementValue(element: Element, field) {\n  const model = element.getModel();\n  const record = model.data;\n  let value;\n  if (isArray(record)) {\n    value = record[0][field];\n  } else {\n    value = record[field];\n  }\n  return value;\n}\n\n/**\n * 两个包围盒是否相交\n * @param box1 包围盒1\n * @param box2 包围盒2\n * @ignore\n */\nexport function intersectRect(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\n\n/**\n * 获取包围盒内的图表元素\n * @param view View/Chart\n * @param box 包围盒\n * @ignore\n */\nexport function getIntersectElements(view: View, box) {\n  const elements = getElements(view);\n  const rst = [];\n  each(elements, (el) => {\n    const shape = el.shape;\n    const shapeBBox = shape.getCanvasBBox();\n    if (intersectRect(box, shapeBBox)) {\n      rst.push(el);\n    }\n  });\n  return rst;\n}\nfunction pathToPoints(path: any[]) {\n  const points = [];\n  each(path, (seg) => {\n    const command = seg[0];\n    if (command !== 'A') {\n      for (let i = 1; i < seg.length; i = i + 2) {\n        points.push([seg[i], seg[i + 1]]);\n      }\n    } else {\n      const length = seg.length;\n      points.push([seg[length - 2], seg[length - 1]]);\n    }\n  });\n  return points;\n}\n/**\n * 获取包围盒内的图表元素\n * @param view View/Chart\n * @param path 路径\n * @ignore\n */\nexport function getElementsByPath(view: View, path: any[]) {\n  const elements = getElements(view);\n  const points = pathToPoints(path);\n  const rst = elements.filter((el: Element) => {\n    const shape = el.shape;\n    let shapePoints;\n    if (shape.get('type') === 'path') {\n      shapePoints = pathToPoints(shape.attr('path'));\n    } else {\n      const shapeBBox = shape.getCanvasBBox();\n      shapePoints = toPoints(shapeBBox);\n    }\n    return isPolygonsIntersect(points, shapePoints);\n  });\n  return rst;\n}\n\n/**\n * 获取当前 View 的所有组件\n * @param view View/Chart\n * @ignore\n */\nexport function getComponents(view) {\n  return view.getComponents().map((co: ComponentOption) => co.component);\n}\n\n/** @ignore */\nexport function distance(p1: Point, p2: Point) {\n  const dx = p2.x - p1.x;\n  const dy = p2.y - p1.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/** @ignore */\nexport function getSpline(points: Point[], z: boolean): PathCommand[] {\n  if (points.length <= 2) {\n    return getLinePath(points, false);\n  }\n  const first = points[0];\n  const arr = [];\n  each(points, (point) => {\n    arr.push(point.x);\n    arr.push(point.y);\n  });\n  const path = catmullRom2bezier(arr, z, null);\n  path.unshift(['M', first.x, first.y]);\n  return path;\n}\n\n/**\n * 检测点是否在包围盒内\n * @param box 包围盒\n * @param point 点\n * @ignore\n */\nexport function isInBox(box: BBox, point: Point) {\n  return box.x <= point.x && box.maxX >= point.x && box.y <= point.y && box.maxY > point.y;\n}\n\n/**\n * 获取同 view 同一级的 views\n * @param view 当前 view\n * @returns 同一级的 views\n * @ignore\n */\nexport function getSilbings(view: View): View[] {\n  const parent = view.parent;\n  let siblings = null;\n  if (parent) {\n    siblings = parent.views.filter((sub) => sub !== view);\n  }\n  return siblings;\n}\n\nfunction point2Normalize(view: View, point: Point): Point {\n  const coord = view.getCoordinate();\n  return coord.invert(point);\n}\n/**\n * 将 view 上的一点转换成另一个 view 的点\n * @param view 当前的 view\n * @param sibling 同一层级的 view\n * @param point 指定点\n * @ignore\n */\nexport function getSiblingPoint(view: View, sibling: View, point: Point): Point {\n  const normalPoint = point2Normalize(view, point);\n  return sibling.getCoordinate().convert(normalPoint);\n}\n\n/**\n * 是否在记录中，临时因为所有的 view 中的数据不是引用，而使用的方法\n * 不同 view 上对数据的引用不相等，导致无法直接用 includes\n * 假设 x, y 值相等时是同一条数据，这个假设不完全正确，而改成 isEqual 则成本太高\n * 后面改成同一个引用时可以修改回来\n * @param records\n * @param record\n * @param xFiled\n * @param yField\n * @returns\n * @ignore\n */\nexport function isInRecords(records: object[], record: object, xFiled: string, yField: string) {\n  let isIn = false;\n  each(records, (r) => {\n    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {\n      isIn = true;\n      return false;\n    }\n  });\n  return isIn;\n}\n\n// 级联获取 field 对应的 scale，如果 view 上没有，遍历子 view\nexport function getScaleByField(view: View, field: string) {\n  let scale = view.getScaleByField(field);\n  if (!scale && view.views) {\n    each(view.views, (subView) => {\n      scale = getScaleByField(subView, field);\n      if (scale) {\n        return false; // 终止循环\n      }\n    });\n  }\n  return scale;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}