{"ast":null,"code":"import { distance, piMod } from './util';\nimport ellipse from './ellipse'; // 偏导数 x\n\nfunction derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n  return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\n} // 偏导数 y\n\n\nfunction derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n  return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\n} // x 的极值\n\n\nfunction xExtrema(rx, ry, xRotation) {\n  return Math.atan(-ry / rx * Math.tan(xRotation));\n} // y 的极值\n\n\nfunction yExtrema(rx, ry, xRotation) {\n  return Math.atan(ry / (rx * Math.tan(xRotation)));\n} // 根据角度求 x 坐标\n\n\nfunction xAt(cx, cy, rx, ry, xRotation, angle) {\n  return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\n} // 根据角度求 y 坐标\n\n\nfunction yAt(cx, cy, rx, ry, xRotation, angle) {\n  return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\n} // 获取点在椭圆上的角度\n\n\nfunction getAngle(rx, ry, x0, y0) {\n  var angle = Math.atan2(y0 * rx, x0 * ry); // 转换到 0 - 2PI 内\n\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n} // 根据角度获取，x,y\n\n\nfunction getPoint(rx, ry, angle) {\n  return {\n    x: rx * Math.cos(angle),\n    y: ry * Math.sin(angle)\n  };\n} // 旋转\n\n\nfunction rotate(x, y, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return [x * cos - y * sin, x * sin + y * cos];\n}\n\nexport default {\n  /**\n   * 计算包围盒\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   * @return {object} 包围盒对象\n   */\n  box: function box(cx, cy, rx, ry, xRotation, startAngle, endAngle) {\n    var xDim = xExtrema(rx, ry, xRotation);\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var xs = [startAngle, endAngle];\n\n    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n      var xAngle = xDim + i;\n\n      if (startAngle < endAngle) {\n        if (startAngle < xAngle && xAngle < endAngle) {\n          xs.push(xAngle);\n        }\n      } else {\n        if (endAngle < xAngle && xAngle < startAngle) {\n          xs.push(xAngle);\n        }\n      }\n    }\n\n    for (var i = 0; i < xs.length; i++) {\n      var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n\n      if (x < minX) {\n        minX = x;\n      }\n\n      if (x > maxX) {\n        maxX = x;\n      }\n    }\n\n    var yDim = yExtrema(rx, ry, xRotation);\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var ys = [startAngle, endAngle];\n\n    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n      var yAngle = yDim + i;\n\n      if (startAngle < endAngle) {\n        if (startAngle < yAngle && yAngle < endAngle) {\n          ys.push(yAngle);\n        }\n      } else {\n        if (endAngle < yAngle && yAngle < startAngle) {\n          ys.push(yAngle);\n        }\n      }\n    }\n\n    for (var i = 0; i < ys.length; i++) {\n      var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n\n      if (y < minY) {\n        minY = y;\n      }\n\n      if (y > maxY) {\n        maxY = y;\n      }\n    }\n\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  },\n\n  /**\n   * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，\n   * 仅跟 rx, ry, startAngle, endAngle 相关\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   */\n  length: function length(cx, cy, rx, ry, xRotation, startAngle, endAngle) {},\n\n  /**\n   * 获取指定点到圆弧的最近距离的点\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   * @param {number} x0         指定点的 x\n   * @param {number} y0         指定点的 y\n   * @return {object} 到指定点最近距离的点\n   */\n  nearestPoint: function nearestPoint(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n    // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n    var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n    var x1 = relativeVector[0],\n        y1 = relativeVector[1]; // 计算点到椭圆的最近的点\n\n    var relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1); // 获取点在椭圆上的角度\n\n    var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y); // 点没有在圆弧上\n\n    if (angle < startAngle) {\n      // 小于起始圆弧\n      relativePoint = getPoint(rx, ry, startAngle);\n    } else if (angle > endAngle) {\n      // 大于结束圆弧\n      relativePoint = getPoint(rx, ry, endAngle);\n    } // 旋转到 xRotation 的角度\n\n\n    var vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n    return {\n      x: vector[0] + cx,\n      y: vector[1] + cy\n    };\n  },\n  pointDistance: function pointDistance(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n    var nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n  pointAt: function pointAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n    var angle = (endAngle - startAngle) * t + startAngle;\n    return {\n      x: xAt(cx, cy, rx, ry, xRotation, angle),\n      y: yAt(cx, cy, rx, ry, xRotation, angle)\n    };\n  },\n  tangentAngle: function tangentAngle(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n    var angle = (endAngle - startAngle) * t + startAngle;\n    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n    return piMod(Math.atan2(dy, dx));\n  }\n};","map":{"version":3,"sources":["../src/arc.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { distance, piMod } from './util';\nimport ellipse from './ellipse';\n// 偏导数 x\nfunction derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n    return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\n}\n// 偏导数 y\nfunction derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n    return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\n}\n// x 的极值\nfunction xExtrema(rx, ry, xRotation) {\n    return Math.atan((-ry / rx) * Math.tan(xRotation));\n}\n// y 的极值\nfunction yExtrema(rx, ry, xRotation) {\n    return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n// 根据角度求 x 坐标\nfunction xAt(cx, cy, rx, ry, xRotation, angle) {\n    return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\n}\n// 根据角度求 y 坐标\nfunction yAt(cx, cy, rx, ry, xRotation, angle) {\n    return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\n}\n// 获取点在椭圆上的角度\nfunction getAngle(rx, ry, x0, y0) {\n    var angle = Math.atan2(y0 * rx, x0 * ry);\n    // 转换到 0 - 2PI 内\n    return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n// 根据角度获取，x,y\nfunction getPoint(rx, ry, angle) {\n    return {\n        x: rx * Math.cos(angle),\n        y: ry * Math.sin(angle),\n    };\n}\n// 旋转\nfunction rotate(x, y, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return [x * cos - y * sin, x * sin + y * cos];\n}\nexport default {\n    /**\n     * 计算包围盒\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     * @return {object} 包围盒对象\n     */\n    box: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) {\n        var xDim = xExtrema(rx, ry, xRotation);\n        var minX = Infinity;\n        var maxX = -Infinity;\n        var xs = [startAngle, endAngle];\n        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n            var xAngle = xDim + i;\n            if (startAngle < endAngle) {\n                if (startAngle < xAngle && xAngle < endAngle) {\n                    xs.push(xAngle);\n                }\n            }\n            else {\n                if (endAngle < xAngle && xAngle < startAngle) {\n                    xs.push(xAngle);\n                }\n            }\n        }\n        for (var i = 0; i < xs.length; i++) {\n            var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n            if (x < minX) {\n                minX = x;\n            }\n            if (x > maxX) {\n                maxX = x;\n            }\n        }\n        var yDim = yExtrema(rx, ry, xRotation);\n        var minY = Infinity;\n        var maxY = -Infinity;\n        var ys = [startAngle, endAngle];\n        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n            var yAngle = yDim + i;\n            if (startAngle < endAngle) {\n                if (startAngle < yAngle && yAngle < endAngle) {\n                    ys.push(yAngle);\n                }\n            }\n            else {\n                if (endAngle < yAngle && yAngle < startAngle) {\n                    ys.push(yAngle);\n                }\n            }\n        }\n        for (var i = 0; i < ys.length; i++) {\n            var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n            if (y < minY) {\n                minY = y;\n            }\n            if (y > maxY) {\n                maxY = y;\n            }\n        }\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    },\n    /**\n     * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，\n     * 仅跟 rx, ry, startAngle, endAngle 相关\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     */\n    length: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) { },\n    /**\n     * 获取指定点到圆弧的最近距离的点\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     * @param {number} x0         指定点的 x\n     * @param {number} y0         指定点的 y\n     * @return {object} 到指定点最近距离的点\n     */\n    nearestPoint: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n        // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n        var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n        var x1 = relativeVector[0], y1 = relativeVector[1];\n        // 计算点到椭圆的最近的点\n        var relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1);\n        // 获取点在椭圆上的角度\n        var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n        // 点没有在圆弧上\n        if (angle < startAngle) {\n            // 小于起始圆弧\n            relativePoint = getPoint(rx, ry, startAngle);\n        }\n        else if (angle > endAngle) {\n            // 大于结束圆弧\n            relativePoint = getPoint(rx, ry, endAngle);\n        }\n        // 旋转到 xRotation 的角度\n        var vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n        return {\n            x: vector[0] + cx,\n            y: vector[1] + cy,\n        };\n    },\n    pointDistance: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n        var nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);\n        return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n    },\n    pointAt: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n        var angle = (endAngle - startAngle) * t + startAngle;\n        return {\n            x: xAt(cx, cy, rx, ry, xRotation, angle),\n            y: yAt(cx, cy, rx, ry, xRotation, angle),\n        };\n    },\n    tangentAngle: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n        var angle = (endAngle - startAngle) * t + startAngle;\n        var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n        var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n        return piMod(Math.atan2(dy, dx));\n    },\n};\n//# sourceMappingURL=arc.js.map"]},"metadata":{},"sourceType":"module"}