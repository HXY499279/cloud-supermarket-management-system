{"ast":null,"code":"import parsePathString from './parse-path-string';\nvar REGEX_MD = /[a-z]/;\n\nfunction toSymmetry(p, c) {\n  return [c[0] + (c[0] - p[0]), c[1] + (c[1] - p[1])];\n}\n\nexport default function pathToAbsolute(pathString) {\n  var pathArray = parsePathString(pathString);\n\n  if (!pathArray || !pathArray.length) {\n    return [['M', 0, 0]];\n  }\n\n  var needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\n\n  for (var i = 0; i < pathArray.length; i++) {\n    var cmd = pathArray[i][0]; // 如果存在相对位置的命令，则中断返回\n\n    if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {\n      needProcess = true;\n      break;\n    }\n  } // 如果不存在相对命令，则直接返回\n  // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\n\n\n  if (!needProcess) {\n    return pathArray;\n  }\n\n  var res = [];\n  var x = 0;\n  var y = 0;\n  var mx = 0;\n  var my = 0;\n  var start = 0;\n  var pa0;\n  var dots;\n  var first = pathArray[0];\n\n  if (first[0] === 'M' || first[0] === 'm') {\n    x = +first[1];\n    y = +first[2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = ['M', x, y];\n  }\n\n  for (var i = start, ii = pathArray.length; i < ii; i++) {\n    var pa = pathArray[i];\n    var preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\n\n    var r = [];\n    var cmd = pa[0];\n    var upCmd = cmd.toUpperCase();\n\n    if (cmd !== upCmd) {\n      r[0] = upCmd;\n\n      switch (upCmd) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n          break;\n        // for lint\n\n        default:\n          for (var j = 1, jj = pa.length; j < jj; j++) {\n            r[j] = +pa[j] + (j % 2 ? x : y);\n          }\n\n      }\n    } else {\n      // 如果本来已经大写，则不处理\n      r = pathArray[i];\n    } // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\n\n\n    switch (upCmd) {\n      case 'Z':\n        x = +mx;\n        y = +my;\n        break;\n\n      case 'H':\n        x = r[1];\n        r = ['L', x, y];\n        break;\n\n      case 'V':\n        y = r[1];\n        r = ['L', x, y];\n        break;\n\n      case 'T':\n        x = r[1];\n        y = r[2]; // 以 x, y 为中心的，上一个控制点的对称点\n        // 需要假设上一个节点的命令为 Q\n\n        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);\n        r = ['Q', symetricT[0], symetricT[1], x, y];\n        break;\n\n      case 'S':\n        x = r[r.length - 2];\n        y = r[r.length - 1]; // 以 x,y 为中心，取上一个控制点，\n        // 需要假设上一个线段为 C 或者 S\n\n        var length_1 = preParams.length;\n        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);\n        r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];\n        break;\n\n      case 'M':\n        mx = r[r.length - 2];\n        my = r[r.length - 1];\n        break;\n      // for lint\n\n      default:\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n    }\n\n    res.push(r);\n  }\n\n  return res;\n}","map":{"version":3,"sources":["../src/path-2-absolute.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import parsePathString from './parse-path-string';\nvar REGEX_MD = /[a-z]/;\nfunction toSymmetry(p, c) {\n    return [\n        c[0] + (c[0] - p[0]),\n        c[1] + (c[1] - p[1]),\n    ];\n}\nexport default function pathToAbsolute(pathString) {\n    var pathArray = parsePathString(pathString);\n    if (!pathArray || !pathArray.length) {\n        return [\n            ['M', 0, 0],\n        ];\n    }\n    var needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\n    for (var i = 0; i < pathArray.length; i++) {\n        var cmd = pathArray[i][0];\n        // 如果存在相对位置的命令，则中断返回\n        if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {\n            needProcess = true;\n            break;\n        }\n    }\n    // 如果不存在相对命令，则直接返回\n    // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\n    if (!needProcess) {\n        return pathArray;\n    }\n    var res = [];\n    var x = 0;\n    var y = 0;\n    var mx = 0;\n    var my = 0;\n    var start = 0;\n    var pa0;\n    var dots;\n    var first = pathArray[0];\n    if (first[0] === 'M' || first[0] === 'm') {\n        x = +first[1];\n        y = +first[2];\n        mx = x;\n        my = y;\n        start++;\n        res[0] = ['M', x, y];\n    }\n    for (var i = start, ii = pathArray.length; i < ii; i++) {\n        var pa = pathArray[i];\n        var preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\n        var r = [];\n        var cmd = pa[0];\n        var upCmd = cmd.toUpperCase();\n        if (cmd !== upCmd) {\n            r[0] = upCmd;\n            switch (upCmd) {\n                case 'A':\n                    r[1] = pa[1];\n                    r[2] = pa[2];\n                    r[3] = pa[3];\n                    r[4] = pa[4];\n                    r[5] = pa[5];\n                    r[6] = +pa[6] + x;\n                    r[7] = +pa[7] + y;\n                    break;\n                case 'V':\n                    r[1] = +pa[1] + y;\n                    break;\n                case 'H':\n                    r[1] = +pa[1] + x;\n                    break;\n                case 'M':\n                    mx = +pa[1] + x;\n                    my = +pa[2] + y;\n                    break; // for lint\n                default:\n                    for (var j = 1, jj = pa.length; j < jj; j++) {\n                        r[j] = +pa[j] + ((j % 2) ? x : y);\n                    }\n            }\n        }\n        else { // 如果本来已经大写，则不处理\n            r = pathArray[i];\n        }\n        // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\n        switch (upCmd) {\n            case 'Z':\n                x = +mx;\n                y = +my;\n                break;\n            case 'H':\n                x = r[1];\n                r = ['L', x, y];\n                break;\n            case 'V':\n                y = r[1];\n                r = ['L', x, y];\n                break;\n            case 'T':\n                x = r[1];\n                y = r[2];\n                // 以 x, y 为中心的，上一个控制点的对称点\n                // 需要假设上一个节点的命令为 Q\n                var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);\n                r = ['Q', symetricT[0], symetricT[1], x, y];\n                break;\n            case 'S':\n                x = r[r.length - 2];\n                y = r[r.length - 1];\n                // 以 x,y 为中心，取上一个控制点，\n                // 需要假设上一个线段为 C 或者 S\n                var length_1 = preParams.length;\n                var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);\n                r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];\n                break;\n            case 'M':\n                mx = r[r.length - 2];\n                my = r[r.length - 1];\n                break; // for lint\n            default:\n                x = r[r.length - 2];\n                y = r[r.length - 1];\n        }\n        res.push(r);\n    }\n    return res;\n}\n//# sourceMappingURL=path-2-absolute.js.map"]},"metadata":{},"sourceType":"module"}