{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { contains, filter, find, isArray, isFunction, isNil, isNumberEqual, isObject, memoize, values } from '@antv/util';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport { getName } from './scale';\n\nfunction snapEqual(v1, v2, scale) {\n  var value1 = scale.translate(v1);\n  var value2 = scale.translate(v2);\n  return isNumberEqual(value1, value2);\n}\n\nfunction getXValueByPoint(point, geometry) {\n  var coordinate = geometry.coordinate;\n  var xScale = geometry.getXScale();\n  var range = xScale.range;\n  var rangeMax = range[range.length - 1];\n  var rangeMin = range[0];\n  var invertPoint = coordinate.invert(point);\n  var xValue = invertPoint.x;\n\n  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n    xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n  }\n\n  return xScale.translate(xScale.invert(xValue));\n}\n\nfunction filterYValue(data, point, geometry) {\n  var coordinate = geometry.coordinate;\n  var yScale = geometry.getYScale();\n  var yField = yScale.field;\n  var invertPoint = coordinate.invert(point);\n  var yValue = yScale.invert(invertPoint.y);\n  var result = find(data, function (obj) {\n    var originData = obj[FIELD_ORIGIN];\n    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n  });\n  return result || data[data.length - 1];\n}\n\nvar getXDistance = memoize(function (scale) {\n  if (scale.isCategory) {\n    return 1;\n  }\n\n  var scaleValues = scale.values; // values 是无序的\n\n  var length = scaleValues.length;\n  var min = scale.translate(scaleValues[0]);\n  var max = min;\n\n  for (var index = 0; index < length; index++) {\n    var value = scaleValues[index]; // 时间类型需要 translate\n\n    var numericValue = scale.translate(value);\n\n    if (numericValue < min) {\n      min = numericValue;\n    }\n\n    if (numericValue > max) {\n      max = numericValue;\n    }\n  }\n\n  return (max - min) / (length - 1);\n});\n/**\n * 获得 tooltip 的 title\n * @param originData\n * @param geometry\n * @param title\n */\n\nfunction getTooltipTitle(originData, geometry, title) {\n  var positionAttr = geometry.getAttribute('position');\n  var fields = positionAttr.getFields();\n  var scales = geometry.scales;\n  var titleField = isFunction(title) || !title ? fields[0] : title;\n  var titleScale = scales[titleField]; // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n  // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n\n  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;\n  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;\n}\n\nfunction getAttributesForLegend(geometry) {\n  var attributes = values(geometry.attributes);\n  return filter(attributes, function (attribute) {\n    return contains(GROUP_ATTRS, attribute.type);\n  });\n}\n\nfunction getTooltipValueScale(geometry) {\n  var attributes = getAttributesForLegend(geometry);\n  var scale;\n\n  for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {\n    var attribute = attributes_1[_i];\n    var tmpScale = attribute.getScale(attribute.type);\n\n    if (tmpScale && tmpScale.isLinear) {\n      // 如果指定字段是非 position 的，同时是连续的\n      scale = tmpScale;\n      break;\n    }\n  }\n\n  var xScale = geometry.getXScale();\n  var yScale = geometry.getYScale();\n  return scale || yScale || xScale;\n}\n\nfunction getTooltipValue(originData, valueScale) {\n  var field = valueScale.field;\n  var value = originData[field];\n\n  if (isArray(value)) {\n    var texts = value.map(function (eachValue) {\n      return valueScale.getText(eachValue);\n    });\n    return texts.join('-');\n  }\n\n  return valueScale.getText(value);\n} // 根据原始数据获取 tooltip item 中 name 值\n\n\nfunction getTooltipName(originData, geometry) {\n  var nameScale;\n  var groupScales = geometry.getGroupScales();\n\n  if (groupScales.length) {\n    // 如果存在分组类型，取第一个分组类型\n    nameScale = groupScales[0];\n  }\n\n  if (nameScale) {\n    var field = nameScale.field;\n    return nameScale.getText(originData[field]);\n  }\n\n  var valueScale = getTooltipValueScale(geometry);\n  return getName(valueScale);\n}\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\n\n\nexport function findDataByPoint(point, data, geometry) {\n  if (data.length === 0) {\n    return null;\n  }\n\n  var geometryType = geometry.type;\n  var xScale = geometry.getXScale();\n  var yScale = geometry.getYScale();\n  var xField = xScale.field;\n  var yField = yScale.field;\n  var rst = null; // 热力图采用最小逼近策略查找 point 击中的数据\n\n  if (geometryType === 'heatmap' || geometryType === 'point') {\n    // 将 point 画布坐标转换为原始数据值\n    var coordinate = geometry.coordinate;\n    var invertPoint = coordinate.invert(point); // 转换成归一化的数据\n\n    var x = xScale.invert(invertPoint.x); // 转换为原始值\n\n    var y = yScale.invert(invertPoint.y); // 转换为原始值\n\n    var min = Infinity;\n\n    for (var index = 0; index < data.length; index++) {\n      var obj = data[index];\n      var originData = obj[FIELD_ORIGIN];\n      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);\n\n      if (range < min) {\n        min = range;\n        rst = obj;\n      }\n    }\n\n    return rst;\n  } // 其他 Geometry 类型按照 x 字段数据进行查找\n\n\n  var first = data[0];\n  var last = data[data.length - 1];\n  var xValue = getXValueByPoint(point, geometry);\n  var firstXValue = first[FIELD_ORIGIN][xField];\n  var firstYValue = first[FIELD_ORIGIN][yField];\n  var lastXValue = last[FIELD_ORIGIN][xField];\n  var isYArray = yScale.isLinear && isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n  // 如果 x 的值是数组\n\n  if (isArray(firstXValue)) {\n    for (var index = 0; index < data.length; index++) {\n      var record = data[index];\n      var originData = record[FIELD_ORIGIN]; // xValue 在 originData[xField] 的数值区间内\n\n      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n        if (isYArray) {\n          // 层叠直方图场景，x 和 y 都是数组区间\n          if (!isArray(rst)) {\n            rst = [];\n          }\n\n          rst.push(record);\n        } else {\n          rst = record;\n          break;\n        }\n      }\n    }\n\n    if (isArray(rst)) {\n      rst = filterYValue(rst, point, geometry);\n    }\n  } else {\n    var next = void 0;\n\n    if (!xScale.isLinear && xScale.type !== 'timeCat') {\n      // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n      for (var index = 0; index < data.length; index++) {\n        var record = data[index];\n        var originData = record[FIELD_ORIGIN];\n\n        if (snapEqual(originData[xField], xValue, xScale)) {\n          if (isYArray) {\n            if (!isArray(rst)) {\n              rst = [];\n            }\n\n            rst.push(record);\n          } else {\n            rst = record;\n            break;\n          }\n        } else if (xScale.translate(originData[xField]) <= xValue) {\n          last = record;\n          next = data[index + 1];\n        }\n      }\n\n      if (isArray(rst)) {\n        rst = filterYValue(rst, point, geometry);\n      }\n    } else {\n      // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {\n        // 不在数据范围内\n        return null;\n      }\n\n      var firstIdx = 0;\n      var lastIdx = data.length - 1;\n      var middleIdx = void 0;\n\n      while (firstIdx <= lastIdx) {\n        middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        var item = data[middleIdx][FIELD_ORIGIN][xField];\n\n        if (snapEqual(item, xValue, xScale)) {\n          return data[middleIdx];\n        }\n\n        if (xScale.translate(item) <= xScale.translate(xValue)) {\n          firstIdx = middleIdx + 1;\n          last = data[middleIdx];\n          next = data[middleIdx + 1];\n        } else {\n          if (lastIdx === 0) {\n            last = data[0];\n          }\n\n          lastIdx = middleIdx - 1;\n        }\n      }\n    }\n\n    if (last && next) {\n      // 计算最逼近的\n      if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {\n        last = next;\n      }\n    }\n  }\n\n  var distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n\n  if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n    rst = last;\n  }\n\n  return rst;\n}\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\n\nexport function getTooltipItems(data, geometry, title, showNil) {\n  if (title === void 0) {\n    title = '';\n  }\n\n  if (showNil === void 0) {\n    showNil = false;\n  }\n\n  var originData = data[FIELD_ORIGIN];\n  var tooltipTitle = getTooltipTitle(originData, geometry, title);\n  var tooltipOption = geometry.tooltipOption;\n  var defaultColor = geometry.theme.defaultColor;\n  var items = [];\n  var name;\n  var value;\n\n  function addItem(itemName, itemValue) {\n    if (showNil || !isNil(itemValue) && itemValue !== '') {\n      // 值为 null的时候，忽视\n      var item = {\n        title: tooltipTitle,\n        data: originData,\n        mappingData: data,\n        name: itemName,\n        value: itemValue,\n        color: data.color || defaultColor,\n        marker: true\n      };\n      items.push(item);\n    }\n  }\n\n  if (isObject(tooltipOption)) {\n    var fields = tooltipOption.fields,\n        callback = tooltipOption.callback;\n\n    if (callback) {\n      // 用户定义了回调函数\n      var callbackParams = fields.map(function (field) {\n        return data[FIELD_ORIGIN][field];\n      });\n      var cfg = callback.apply(void 0, callbackParams);\n\n      var itemCfg = __assign({\n        data: data[FIELD_ORIGIN],\n        mappingData: data,\n        title: tooltipTitle,\n        color: data.color || defaultColor,\n        marker: true\n      }, cfg);\n\n      items.push(itemCfg);\n    } else {\n      var scales = geometry.scales;\n\n      for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\n        var field = fields_1[_i];\n\n        if (!isNil(originData[field])) {\n          // 字段数据为null, undefined 时不显示\n          var scale = scales[field];\n          name = getName(scale);\n          value = scale.getText(originData[field]);\n          addItem(name, value);\n        }\n      }\n    }\n  } else {\n    var valueScale = getTooltipValueScale(geometry); // 字段数据为null ,undefined时不显示\n\n    value = getTooltipValue(originData, valueScale);\n    name = getTooltipName(originData, geometry);\n    addItem(name, value);\n  }\n\n  return items;\n}","map":{"version":3,"sources":["../../src/util/tooltip.ts"],"names":[],"mappings":"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","sourcesContent":["import { contains, filter, find, hasKey, isArray, isFunction, isNil, isNumberEqual, isObject, memoize, values } from '@antv/util';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport { Attribute, Scale } from '../dependents';\nimport Geometry from '../geometry/base';\nimport { Data, Datum, MappingDatum, Point, TooltipTitle } from '../interface';\nimport { getName } from './scale';\n\nfunction snapEqual(v1: any, v2: any, scale: Scale) {\n  const value1 = scale.translate(v1);\n  const value2 = scale.translate(v2);\n\n  return isNumberEqual(value1, value2);\n}\n\nfunction getXValueByPoint(point: Point, geometry: Geometry): number {\n  const coordinate = geometry.coordinate;\n  const xScale = geometry.getXScale();\n  const range = xScale.range;\n  const rangeMax = range[range.length - 1];\n  const rangeMin = range[0];\n\n  const invertPoint = coordinate.invert(point);\n\n  let xValue = invertPoint.x;\n  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n    xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n  }\n  return xScale.translate(xScale.invert(xValue));\n}\n\nfunction filterYValue(data: Data, point: Point, geometry: Geometry) {\n  const coordinate = geometry.coordinate;\n  const yScale = geometry.getYScale();\n  const yField = yScale.field;\n  const invertPoint = coordinate.invert(point);\n  const yValue = yScale.invert(invertPoint.y);\n\n  const result = find(data, (obj: Datum) => {\n    const originData = obj[FIELD_ORIGIN];\n    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n  });\n  return result || data[data.length - 1];\n}\n\nconst getXDistance = memoize((scale: Scale) => {\n  if (scale.isCategory) {\n    return 1;\n  }\n  const scaleValues = scale.values; // values 是无序的\n  const length = scaleValues.length;\n  let min = scale.translate(scaleValues[0]);\n  let max = min;\n\n  for (let index = 0; index < length; index++) {\n    const value = scaleValues[index];\n    // 时间类型需要 translate\n    const numericValue = scale.translate(value);\n    if (numericValue < min) {\n      min = numericValue;\n    }\n    if (numericValue > max) {\n      max = numericValue;\n    }\n  }\n  return (max - min) / (length - 1);\n});\n\n/**\n * 获得 tooltip 的 title\n * @param originData\n * @param geometry\n * @param title\n */\nfunction getTooltipTitle(originData: Datum, geometry: Geometry, title: TooltipTitle): string {\n  const positionAttr = geometry.getAttribute('position');\n  const fields = positionAttr.getFields();\n  const scales = geometry.scales;\n\n  const titleField = isFunction(title) || !title ? fields[0] : title;\n  const titleScale = scales[titleField];\n\n  // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n  // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n  const tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;\n\n  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;\n}\n\nfunction getAttributesForLegend(geometry: Geometry) {\n  const attributes = values(geometry.attributes);\n  return filter(attributes, (attribute: Attribute) => contains(GROUP_ATTRS, attribute.type));\n}\n\nfunction getTooltipValueScale(geometry: Geometry) {\n  const attributes = getAttributesForLegend(geometry);\n  let scale;\n  for (const attribute of attributes) {\n    const tmpScale = attribute.getScale(attribute.type);\n    if (tmpScale && tmpScale.isLinear) {\n      // 如果指定字段是非 position 的，同时是连续的\n      scale = tmpScale;\n      break;\n    }\n  }\n\n  const xScale = geometry.getXScale();\n  const yScale = geometry.getYScale();\n\n  return scale || yScale || xScale;\n}\n\nfunction getTooltipValue(originData: Datum, valueScale: Scale) {\n  const field = valueScale.field;\n  const value = originData[field];\n\n  if (isArray(value)) {\n    const texts = value.map((eachValue) => {\n      return valueScale.getText(eachValue);\n    });\n    return texts.join('-');\n  }\n  return valueScale.getText(value);\n}\n\n// 根据原始数据获取 tooltip item 中 name 值\nfunction getTooltipName(originData: Datum, geometry: Geometry) {\n  let nameScale: Scale;\n  const groupScales = geometry.getGroupScales();\n  if (groupScales.length) {\n    // 如果存在分组类型，取第一个分组类型\n    nameScale = groupScales[0];\n  }\n  if (nameScale) {\n    const field = nameScale.field;\n    return nameScale.getText(originData[field]);\n  }\n\n  const valueScale = getTooltipValueScale(geometry);\n  return getName(valueScale);\n}\n\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\nexport function findDataByPoint(point: Point, data: MappingDatum[], geometry: Geometry) {\n  if (data.length === 0) {\n    return null;\n  }\n\n  const geometryType = geometry.type;\n  const xScale = geometry.getXScale();\n  const yScale = geometry.getYScale();\n\n  const xField = xScale.field;\n  const yField = yScale.field;\n\n  let rst = null;\n\n  // 热力图采用最小逼近策略查找 point 击中的数据\n  if (geometryType === 'heatmap' || geometryType === 'point') {\n    // 将 point 画布坐标转换为原始数据值\n    const coordinate = geometry.coordinate;\n    const invertPoint = coordinate.invert(point); // 转换成归一化的数据\n    const x = xScale.invert(invertPoint.x); // 转换为原始值\n    const y = yScale.invert(invertPoint.y); // 转换为原始值\n\n    let min = Infinity;\n    for (let index = 0; index < data.length; index++) {\n      const obj = data[index];\n      const originData = obj[FIELD_ORIGIN];\n      const range = (originData[xField] - x) ** 2 + (originData[yField] - y) ** 2;\n      if (range < min) {\n        min = range;\n        rst = obj;\n      }\n    }\n\n    return rst;\n  }\n\n  // 其他 Geometry 类型按照 x 字段数据进行查找\n  const first = data[0];\n  let last = data[data.length - 1];\n  const xValue = getXValueByPoint(point, geometry);\n  const firstXValue = first[FIELD_ORIGIN][xField];\n  const firstYValue = first[FIELD_ORIGIN][yField];\n  const lastXValue = last[FIELD_ORIGIN][xField];\n  const isYArray = yScale.isLinear && isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n\n  // 如果 x 的值是数组\n  if (isArray(firstXValue)) {\n    for (let index = 0; index < data.length; index++) {\n      const record = data[index];\n      const originData = record[FIELD_ORIGIN];\n      // xValue 在 originData[xField] 的数值区间内\n      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n        if (isYArray) {\n          // 层叠直方图场景，x 和 y 都是数组区间\n          if (!isArray(rst)) {\n            rst = [];\n          }\n          rst.push(record);\n        } else {\n          rst = record;\n          break;\n        }\n      }\n    }\n    if (isArray(rst)) {\n      rst = filterYValue(rst, point, geometry);\n    }\n  } else {\n    let next;\n    if (!xScale.isLinear && xScale.type !== 'timeCat') {\n      // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n      for (let index = 0; index < data.length; index++) {\n        const record = data[index];\n        const originData = record[FIELD_ORIGIN];\n        if (snapEqual(originData[xField], xValue, xScale)) {\n          if (isYArray) {\n            if (!isArray(rst)) {\n              rst = [];\n            }\n            rst.push(record);\n          } else {\n            rst = record;\n            break;\n          }\n        } else if (xScale.translate(originData[xField]) <= xValue) {\n          last = record;\n          next = data[index + 1];\n        }\n      }\n\n      if (isArray(rst)) {\n        rst = filterYValue(rst, point, geometry);\n      }\n    } else {\n      // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n      if (\n        (xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) &&\n        (xValue > xScale.max || xValue < xScale.min)\n      ) {\n        // 不在数据范围内\n        return null;\n      }\n\n      let firstIdx = 0;\n      let lastIdx = data.length - 1;\n      let middleIdx;\n      while (firstIdx <= lastIdx) {\n        middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        const item = data[middleIdx][FIELD_ORIGIN][xField];\n        if (snapEqual(item, xValue, xScale)) {\n          return data[middleIdx];\n        }\n\n        if (xScale.translate(item) <= xScale.translate(xValue)) {\n          firstIdx = middleIdx + 1;\n          last = data[middleIdx];\n          next = data[middleIdx + 1];\n        } else {\n          if (lastIdx === 0) {\n            last = data[0];\n          }\n          lastIdx = middleIdx - 1;\n        }\n      }\n    }\n\n    if (last && next) {\n      // 计算最逼近的\n      if (\n        Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) >\n        Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)\n      ) {\n        last = next;\n      }\n    }\n  }\n\n  const distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n  if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n    rst = last;\n  }\n\n  return rst;\n}\n\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\nexport function getTooltipItems(data: MappingDatum, geometry: Geometry, title: TooltipTitle = '', showNil: boolean = false) {\n  const originData = data[FIELD_ORIGIN];\n  const tooltipTitle = getTooltipTitle(originData, geometry, title);\n  const tooltipOption = geometry.tooltipOption;\n  const { defaultColor } = geometry.theme;\n  const items = [];\n  let name;\n  let value;\n\n  function addItem(itemName, itemValue) {\n    if (showNil || (!isNil(itemValue) && itemValue !== '')) {\n      // 值为 null的时候，忽视\n      const item = {\n        title: tooltipTitle,\n        data: originData, // 原始数据\n        mappingData: data, // 映射后的数据\n        name: itemName,\n        value: itemValue,\n        color: data.color || defaultColor,\n        marker: true,\n      };\n\n      items.push(item);\n    }\n  }\n\n  if (isObject(tooltipOption)) {\n    const { fields, callback } = tooltipOption;\n    if (callback) {\n      // 用户定义了回调函数\n      const callbackParams = fields.map((field: string) => {\n        return data[FIELD_ORIGIN][field];\n      });\n      const cfg = callback(...callbackParams);\n      const itemCfg = {\n        data: data[FIELD_ORIGIN], // 原始数据\n        mappingData: data, // 映射后的数据\n        title: tooltipTitle,\n        color: data.color || defaultColor,\n        marker: true, // 默认展示 marker\n        ...cfg,\n      };\n\n      items.push(itemCfg);\n    } else {\n      const scales = geometry.scales;\n      for (const field of fields) {\n        if (!isNil(originData[field])) {\n          // 字段数据为null, undefined 时不显示\n          const scale = scales[field];\n          name = getName(scale);\n          value = scale.getText(originData[field]);\n          addItem(name, value);\n        }\n      }\n    }\n  } else {\n    const valueScale = getTooltipValueScale(geometry);\n    // 字段数据为null ,undefined时不显示\n    value = getTooltipValue(originData, valueScale);\n    name = getTooltipName(originData, geometry);\n    addItem(name, value);\n  }\n  return items;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}